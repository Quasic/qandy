<!DOCTYPE html>
<html><head>
<link rel="stylesheet" type="text/css" href="qandy.css">
</head><body><p><br>
<div id=txt class="txt"></div>
<div id="pop" class="pop" onMouseOver='PopUpVis="visible";' onMouseOut='PopUpVis=PForce; PUV=setTimeout("document.getElementById(\"pop\").style.visibility=PopUpVis;",100);'></div>
<div id="keyboard-container"></div>

<script src="dos.js"></script>
<script src="menus.js"></script>
<script>
var devteam=1;  // developer mode
var run="";
var txt="";
var mode="txt"; // gfx or txt display
var allowScriptESC=false; // if true, script handles ESC instead of universal termination

// RAM - Working memory for file editing
var RAM="";           // Current file content in memory
var RAMFILE="";       // Current filename loaded in RAM
var RAMTYPE="";       // Current file type (js, txt, etc)

var caps=0;  // caps lock state: 0=lowercase, 1=uppercase, 2=extended graphics
var shift=0; // shift key pressed  
var ctrl=0;  // ctrl key pressed
var alt=0;   // alt key pressed
var ctrlPhysical=false;  // track if ctrl was activated by physical keyboard
var altPhysical=false;   // track if alt was activated by physical keyboard
var keyon=1; // turn keyboard input on/off

// Normal character mapping for lowercase (caps level 0)
// User can edit these to customize keyboard layout
var normalKeys = {
  '1': '1', '2': '2', '3': '3', '4': '4', '5': '5',
  '6': '6', '7': '7', '8': '8', '9': '9', '0': '0',
  'q': 'q', 'w': 'w', 'e': 'e', 'r': 'r', 't': 't',
  'y': 'y', 'u': 'u', 'i': 'i', 'o': 'o', 'p': 'p',
  'a': 'a', 's': 's', 'd': 'd', 'f': 'f', 'g': 'g',
  'h': 'h', 'j': 'j', 'k': 'k', 'l': 'l',
  'z': 'z', 'x': 'x', 'c': 'c', 'v': 'v', 'b': 'b',
  'n': 'n', 'm': 'm',
  '[': '[', ']': ']', ';': ';', '\'': '\'',
  ',': ',', '.': '.', '/': '/', '=': '=', '-': '-',
  '\\': '\\', '`': '`'
};

// Shifted character mapping for uppercase and symbols (caps level 1)
// User can edit these to customize shifted key behavior
var shiftedKeys = {
  '1': '!', '2': '@', '3': '#', '4': '$', '5': '%',
  '6': '^', '7': '&', '8': '*', '9': '(', '0': ')',
  'q': 'Q', 'w': 'W', 'e': 'E', 'r': 'R', 't': 'T',
  'y': 'Y', 'u': 'U', 'i': 'I', 'o': 'O', 'p': 'P',
  'a': 'A', 's': 'S', 'd': 'D', 'f': 'F', 'g': 'G',
  'h': 'H', 'j': 'J', 'k': 'K', 'l': 'L',
  'z': 'Z', 'x': 'X', 'c': 'C', 'v': 'V', 'b': 'B',
  'n': 'N', 'm': 'M',
  '[': '{', ']': '}', ';': ':', '\'': '"',
  ',': '<', '.': '>', '/': '?', '=': '+', '-': '_',
  '\\': '|', '`': '~'
};

// Extended graphic character mapping for caps level 2
// User can edit these to customize extended characters for ASCII/ANSI art
var extendedChars = {
  'q': '┌', 'w': '┬', 'e': '┐', 'r': '─', 't': '╔',
  'a': '├', 's': '┼', 'd': '┤', 'f': '│', 'g': '╠',
  'z': '└', 'x': '┴', 'c': '┘', 'v': '╚', 'b': '╝',
  'y': '╦', 'u': '╗', 'i': '═', 'o': '╣',
  'h': '╬', 'j': '╩', 'k': '║', 'l': '▬',
  'n': '▀', 'm': '▄',
  'p': '●', '1': '↑', '2': '↓', '3': '←', '4': '→',
  '5': '■', '6': '□', '7': '◆', '8': '○',
  '9': '★', '0': '☆', '[': '♠', ']': '♥',
  ';': '♦', '\'': '♣', ',': '✓', '.': '✗',
  '/': '÷', '=': '×', '-': '±', ' ': '·',
  '\\': '¦', '`': '`'
};
var line=""; // input text line
var cursorPos=0; // cursor position in input line for editing
var inputScrollPos=0; // starting position of visible input window

// Command history support (like Linux terminal)
var commandHistory = [];  // Array to store command history
var historyIndex = -1;    // Current position in history (-1 = not browsing, typing new command)
var maxHistorySize = 50;  // Maximum number of commands to remember
var tempCommand = "";     // Temporary storage for command being typed when browsing history

// Text selection state
var selectionStart = -1;  // Start position of selection (-1 = no selection)
var selectionEnd = -1;    // End position of selection
var selectionBgColor = '#ffffff';   // Selection background color
var selectionFgColor = '#000000';   // Selection text color

var screenBuffer = [];
var cursorX = 0;
var cursorY = 0;
var cursorOn=0;
var prevCursor = { set: false, x: 0, y: 0, inverse: false };
var screenWidth = 32;
var screenHeight = 25;

// Pagination support for overflow text
var paginationEnabled = true;  // Enable/disable pagination feature
var paginationPaused = false;  // Is print() currently paused?
var paginationBuffer = [];     // Queued text waiting to be printed
var paginationLinesBeforePause = 25;  // Lines to show before pausing
var inInputMode = false;       // True when processing user input (prevents pagination)

var styleBuffer = [];
var currentStyle = {
  color: 37,      // white foreground
  bgcolor: 40,    // black background
  bold: false,
  inverse: false
};

var PopX=0;
var PopY=0;
var PopHide="hidden";
var PopAlign="center";
var PForce="hidden";
var mapx=7;
var mapy=11;
var map="";

// Keyboard data structure - array of key objects
var keyboardData = [
  // Row 0: ESC, BACKTICK, BACKSLASH, OPEN, CLOSE, DASH, EQUAL, BACK (y=446)
  {id:"esc", label:"ESC", keyCode:27, x:47, y:446, width:52},
  {id:"backtick", label:"`", keyCode:192, x:103, y:446, width:28},
  {id:"backslash", label:"\\", keyCode:220, x:132, y:446, width:28},
  {id:"open", label:"[", keyCode:219, x:160, y:446, width:28},
  {id:"close", label:"]", keyCode:221, x:189, y:446, width:28},
  {id:"dash", label:"-", keyCode:173, x:218, y:446, width:28},
  {id:"equal", label:"=", keyCode:61, x:247, y:446, width:28},
  {id:"back", label:"BACK", keyCode:8, x:275, y:446, width:52},
  // Row 1: Number keys 1-0 (y=480)
  {id:"n1", label:"1", keyCode:49, x:47, y:480, width:28},
  {id:"n2", label:"2", keyCode:50, x:75, y:480, width:28},
  {id:"n3", label:"3", keyCode:51, x:103, y:480, width:28},
  {id:"n4", label:"4", keyCode:52, x:132, y:480, width:28},
  {id:"n5", label:"5", keyCode:53, x:160, y:480, width:28},
  {id:"n6", label:"6", keyCode:54, x:189, y:480, width:28},
  {id:"n7", label:"7", keyCode:55, x:218, y:480, width:28},
  {id:"n8", label:"8", keyCode:56, x:247, y:480, width:28},
  {id:"n9", label:"9", keyCode:57, x:275, y:480, width:28},
  {id:"n0", label:"0", keyCode:48, x:303, y:480, width:28},
  // Row 2: QWERTY (y=511)
  {id:"q", label:"q", keyCode:81, x:47, y:511, width:28},
  {id:"w", label:"w", keyCode:87, x:75, y:511, width:28},
  {id:"e", label:"e", keyCode:69, x:103, y:511, width:28},
  {id:"r", label:"r", keyCode:82, x:132, y:511, width:28},
  {id:"t", label:"t", keyCode:84, x:160, y:511, width:28},
  {id:"y", label:"y", keyCode:89, x:189, y:511, width:28},
  {id:"u", label:"u", keyCode:85, x:218, y:511, width:28},
  {id:"i", label:"i", keyCode:73, x:247, y:511, width:28},
  {id:"o", label:"o", keyCode:79, x:275, y:511, width:28},
  {id:"p", label:"p", keyCode:80, x:303, y:511, width:28},
  // Row 3: ASDF (y=542)
  {id:"a", label:"a", keyCode:65, x:47, y:542, width:28},
  {id:"s", label:"s", keyCode:83, x:75, y:542, width:28},
  {id:"d", label:"d", keyCode:68, x:103, y:542, width:28},
  {id:"f", label:"f", keyCode:70, x:132, y:542, width:28},
  {id:"g", label:"g", keyCode:71, x:160, y:542, width:28},
  {id:"h", label:"h", keyCode:72, x:189, y:542, width:28},
  {id:"j", label:"j", keyCode:74, x:218, y:542, width:28},
  {id:"k", label:"k", keyCode:75, x:247, y:542, width:28},
  {id:"l", label:"l", keyCode:76, x:275, y:542, width:28},
  {id:"quote", label:"'", keyCode:222, x:303, y:542, width:28},
  // Row 4: ZXCV (y=573)
  {id:"z", label:"z", keyCode:90, x:47, y:573, width:28},
  {id:"x", label:"x", keyCode:88, x:75, y:573, width:28},
  {id:"c", label:"c", keyCode:67, x:103, y:573, width:28},
  {id:"v", label:"v", keyCode:86, x:132, y:573, width:28},
  {id:"b", label:"b", keyCode:66, x:160, y:573, width:28},
  {id:"n", label:"n", keyCode:78, x:189, y:573, width:28},
  {id:"m", label:"m", keyCode:77, x:218, y:573, width:28},
  {id:"colon", label:";", keyCode:59, x:247, y:573, width:28},
  {id:"enter", label:"ENTER", keyCode:13, x:275, y:573, width:52},

  // Row 5: Bottom row with modifiers (y=604)
  {id:"caps", label:"CAPS", keyCode:20, x:47, y:604, width:52},
  {id:"space", label:"SPACE", keyCode:32, x:103, y:604, width:81},
  {id:"ctrl", label:"CTRL", keyCode:17, x:189, y:604, width:28},
  {id:"alt", label:"ALT", keyCode:18, x:218, y:604, width:28},
  {id:"comma", label:",", keyCode:188, x:247, y:604, width:28},
  {id:"dot", label:".", keyCode:190, x:275, y:604, width:28},
  {id:"slash", label:"/", keyCode:191, x:303, y:604, width:28}
];

const ANSI = {
  colors: { 30: 'black', 31: 'red', 32: 'green', 33: 'yellow', 34: 'blue', 35: 'magenta', 36: 'cyan', 37: 'white', 90: 'black', 91: 'red', 92: 'green', 93: 'yellow', 94: 'blue', 95: 'magenta', 96: 'cyan', 97: 'white' },
  bgColors: { 40: 'black', 41: 'red', 42: 'green', 43: 'yellow', 44: 'blue', 45: 'magenta', 46: 'cyan', 47: 'white', 100: 'black', 101: 'red', 102: 'green', 103: 'yellow', 104: 'blue', 105: 'magenta', 106: 'cyan', 107: 'white' },
  
  render: function(text) {
    let html = ''; let currentColor = 'white'; let currentBgColor = 'black'; let bold = false; let inverse = false; let cursorX = 0; let cursorY = 0;
    const ansiRegex = /\x1b\[([\d;]*)([A-Za-z])/g; let lastIndex = 0; let match;
    while ((match = ansiRegex.exec(text)) !== null) {
      html += this.escapeHtml(text.substring(lastIndex, match.index));
      const params = match[1] ? match[1].split(';').map(Number) : [0];
      const command = match[2];
      if (command === 'm') {
        params.forEach(param => {
          if (param === 0) {
            currentColor = 'white';
            currentBgColor = 'black';
            bold = false;
            inverse = false;
          } else if (param === 1) {
            bold = true;
          } else if (param === 7) {
            inverse = true;
          } else if (param === 27) {
            inverse = false;
          } else if (param >= 30 && param <= 37) {
            currentColor = this.colors[param];
          } else if (param >= 40 && param <= 47) {
            currentBgColor = this.bgColors[param];
          }
        });
      } else if (command === 'H' || command === 'f') {
        cursorY = params[0] || 0;
        cursorX = params[1] || 0;
      } else if (command === 'A') {
        cursorY = Math.max(0, cursorY - (params[0] || 1));
      } else if (command === 'B') {
        cursorY += (params[0] || 1);
      } else if (command === 'C') {
        cursorX += (params[0] || 1);
      } else if (command === 'D') {
        cursorX = Math.max(0, cursorX - (params[0] || 1));
      } else if (command === 'J') {
        if (params[0] === 2) {
          html = ''; // Clear screen @@
        }
      } else if (command === 'K') {
      }
      lastIndex = match.index + match[0].length;
    }
    html += this.escapeHtml(text.substring(lastIndex));
    let classes = [];
    if (bold) classes.push('ansi-bold');
    if (inverse) classes.push('ansi-inverse');
    classes.push(`ansi-${currentColor}`);
    classes.push(`ansi-bg-${currentBgColor}`);
    if (classes.length > 0) { html = `<span class="${classes.join(' ')}">${html}</span>`; }
    return html;
  },

  escapeHtml: function(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
  },

  codes: {
    reset: '\x1b[0m',
    bold: '\x1b[1m',
    inverse: '\x1b[7m',
    black: '\x1b[30m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m',
    bgBlack: '\x1b[40m',
    bgRed: '\x1b[41m',
    bgGreen: '\x1b[42m',
    bgYellow: '\x1b[43m',
    bgBlue: '\x1b[44m',
    bgMagenta: '\x1b[45m',
    bgCyan: '\x1b[46m',
    bgWhite: '\x1b[47m',
    cursorHome: '\x1b[H',
    cursorPos: (row, col) => `\x1b[${row};${col}H`,
    cursorUp: (n = 1) => `\x1b[${n}A`,
    cursorDown: (n = 1) => `\x1b[${n}B`,
    cursorForward: (n = 1) => `\x1b[${n}C`,
    cursorBack: (n = 1) => `\x1b[${n}D`,
    clearScreen: '\x1b[2J',
    clearLine: '\x1b[K',
    pageBreak: '\f'  // Form Feed (ASCII 12, 0x0C) - explicit page break for pagination
  }
};

img=document.createElement('img');
img.id="qpc"; img.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAMklEQVRYhe3OMQEAMAjEwKei2wHxRQbLxUCu3u2fxc7mHAAAAAAAAAAAAAAAAAAAIEkGzIgCpxq6s7YAAAAASUVORK5CYII="; 
img.style.width="300px"; img.style.height="600px"; img.style.zIndex="0"; 
img.style.position="absolute";
document.body.appendChild(img);

initKeyboard(); function initKeyboard() {
 // Create keyboard buttons dynamically from keyboard data array
 keyboardData.forEach(function(key) {
  var btn = document.createElement('div');
  btn.id = key.id;
  btn.innerHTML = key.label;
  
  // Assign appropriate CSS class based on width
  if (key.width === 28) {
   btn.className = 'k1';
  } else if (key.width === 40) {
   // Check if it's the ENTER key specifically
   if (key.id === 'enter') {
    btn.className = 'k-enter';  // ENTER key
   } else {
    btn.className = 'k-ctrl';  // CAPS key and other 40px keys
   }
  } else if (key.width === 52) {
   btn.className = 'k2';
  } else if (key.width === 81) {
   btn.className = 'k-space';  // SPACE key
  } else if (key.width === 109) {
   btn.className = 'k4';
  }
  
  // Set explicit width for custom-sized keys
  if (key.width === 40 || key.width === 81) {
   btn.style.width = key.width + 'px';
  }
  
  // Reduce font size for CTRL and ALT keys to fit text better
  if (key.id === 'ctrl' || key.id === 'alt') {
   btn.style.fontSize = '9px';
  }
  
  // Position the button
  btn.style.left = key.x + 'px';
  btn.style.top = key.y + 'px';
  
  // Add click handler
  btn.onclick = function() { button(key.keyCode); };
  
  // Append to keyboard container
  document.getElementById('keyboard-container').appendChild(btn);
 });
 
 // Position the QPC and other elements
 document.getElementById("qpc").style.top = "32px"; 
 document.getElementById("qpc").style.left = "32px";
}

// Create a mapping from keyCode to element ID for quick lookup
var keyCodeToId = {};
keyboardData.forEach(function(key) {
  keyCodeToId[key.keyCode] = key.id;
});

// Store timeout IDs for each key to handle rapid key presses
var keyTimeouts = {};

// Function to highlight a virtual key
function highlightKey(keyCode) {
  var elementId = keyCodeToId[keyCode];
  if (!elementId) return; // Key not in virtual keyboard
  
  var element = document.getElementById(elementId);
  if (!element) return; // Element not found
  
  // Clear any existing timeout for this key to prevent race conditions
  if (keyTimeouts[elementId]) {
    clearTimeout(keyTimeouts[elementId]);
  }
  
  // Apply hover effect (using the same color as :hover in CSS)
  element.style.backgroundColor = '#444';
  
  // Set a timeout to restore original color
  keyTimeouts[elementId] = setTimeout(function() {
    unhighlightKey(elementId);
    delete keyTimeouts[elementId]; // Clean up timeout reference
  }, 200); // 200ms flash effect
}

// Function to unhighlight a virtual key
function unhighlightKey(elementId) {
  var element = document.getElementById(elementId);
  if (!element) return;
  
  // Restore original background by clearing inline style
  // This allows CSS stylesheet rules to take effect again
  element.style.backgroundColor = '';
}

tiles(); function tiles() {
 Z=0;
 for (Y=0; Y<=mapy; Y++) {
  for (X=0; X<=mapx; X++) {
   T=document.createElement("img");
   T.id="T"+Z; T.src="t/Ga.png"; 
   T.height=32; T.width=32;
   T.className="tile";
   T.onmousedown=new Function("ClickTile("+(Z)+",this.parentNode)");     
   document.body.appendChild(T);
   Z++;
  }
 }
}



resize(); function resize() {
 // Position text element based on mode
 if (mode=="gfx") {
  up=32+(404-(document.getElementById('txt').offsetHeight));
  left=32+22+300;
  document.getElementById("txt").style.left=left+"px";
  document.getElementById("txt").style.top=up+"px";
 } else {
  left=32+22;
  up=32+(402-(document.getElementById('txt').offsetHeight));
  document.getElementById("txt").style.left="54px";
  document.getElementById("txt").style.top=up+"px";
 }
 const textElement=document.getElementById("txt");
 textElement.scrollTop=textElement.scrollHeight;
 Z=0; for (Y=0; Y<=mapy; Y++) {
  for (X=0; X<=mapx; X++) {
   e=document.getElementById("T"+Z).style.top=50+(Y*32)+"px";  
   e=document.getElementById("T"+Z).style.left=54+(X*32)+"px"; 
   Z++;
  }
 }
}

document.addEventListener('keydown', function (event) { press(event); });
document.addEventListener('keyup', function (event) { pressup(event); });
document.addEventListener('paste', function (event) {
 if (keyon) {
  event.preventDefault();
  var pastedText;
  if (event.clipboardData && event.clipboardData.getData) {
   pastedText = event.clipboardData.getData('text/plain');
  } else if (window.clipboardData && window.clipboardData.getData) {
   pastedText = window.clipboardData.getData('Text');
  }
  if (pastedText) {
   line += pastedText;
   cursorPos = line.length; // Update cursor position to end
   updateDisplay();
   // Scroll to bottom to show cursor
   const textElement = document.getElementById("txt");
   textElement.scrollTop = textElement.scrollHeight;
  }
 }
});
function press(event) { 
 key=""; k=event.keyCode; shift=event.shiftKey;
 if (event.keyCode === 18 || event.altKey) { event.preventDefault(); }
 if (event.keyCode === 27) { event.preventDefault(); }
 if (event.keyCode === 17 && !ctrl) {
  ctrl=1; ctrlPhysical=true;
  document.getElementById("ctrl").style.backgroundColor = "#0a0";
  document.getElementById("ctrl").style.color = "#000";
  return;
 }
 if (event.keyCode === 18 && !alt) {
  alt = 1; altPhysical = true; document.getElementById("alt").style.backgroundColor = "#0a0";
  document.getElementById("alt").style.color = "#000";
 }
 // Handle Ctrl+C for copy
 if (event.ctrlKey && event.key === 'c') {
  event.preventDefault();
  if (selectionStart !== -1 && selectionEnd !== -1) {
   const start = Math.min(selectionStart, selectionEnd);
   const end = Math.max(selectionStart, selectionEnd);
   const selectedText = line.substring(start, end);
   navigator.clipboard.writeText(selectedText).then(() => {
    print("\x1b[32mCopied to clipboard!\x1b[0m\n");
   }).catch(err => {
    print("\x1b[31mCopy failed\x1b[0m\n");
   });
  } else if (line.length > 0) {
   // Copy entire line if no selection
   navigator.clipboard.writeText(line).then(() => {
    print("\x1b[32mCopied entire input to clipboard!\x1b[0m\n");
   }).catch(err => {
    print("\x1b[31mCopy failed\x1b[0m\n");
   });
  }
  return;
 }
 
 if (event.ctrlKey) { return; }
 highlightKey(k);
 button(k);
}

function pressup(event) {
 // Prevent browser from handling ALT key - must be done before any conditionals
 if (event.keyCode === 18 || event.altKey) {
  event.preventDefault(); // Prevent browser menu from opening
 }
 
 // Handle physical CTRL key release (unhighlight)
 if (event.keyCode === 17 && ctrlPhysical) {
  ctrl = 0;
  ctrlPhysical = false;
  document.getElementById("ctrl").style.backgroundColor = "#222";
  document.getElementById("ctrl").style.color = "#fff";
  return;
 }
 
 // Handle physical ALT key release (unhighlight)
 if (event.keyCode === 18 && altPhysical) {
  alt = 0;
  altPhysical = false;
  document.getElementById("alt").style.backgroundColor = "#222";
  document.getElementById("alt").style.color = "#fff";
  return;
 }
 
 // Route keyup to active script if run is set
 if (run && typeof keyup !== 'undefined') {
  var k = String.fromCharCode(event.keyCode);
  keyup(k);
 }
}

function button(b, event) {
  // If pagination paused, resume
  if (typeof paginationPaused !== 'undefined' && paginationPaused) {
    if (typeof resumePagination === 'function') resumePagination();
    return;
  }

  // Update physical shift state if event given
  if (event && typeof event.shiftKey !== 'undefined') shift = !!event.shiftKey;

  // Hide cursor visually while we update state (use cursor() helper)
  var hadCursor = !!cursorOn;
  if (hadCursor) cursor(0);

  var k = "", l = "";

  // Map common control/navigation keys
  switch (b) {
    case 16: // SHIFT - handle specially (do not insert control char)
      if (typeof event !== 'undefined' && typeof event.shiftKey !== 'undefined') {
        shift = !!event.shiftKey;
      } else {
        // virtual SHIFT toggle
        shift = !shift;
      }
      // update any on-screen Shift key visual (if exists)
      var sEl = document.getElementById("shift") || document.getElementById("kshift");
      if (sEl) {
        if (shift) { sEl.style.backgroundColor = "#fff"; sEl.style.color = "#000"; }
        else { sEl.style.backgroundColor = "#222"; sEl.style.color = "#fff"; }
      }
      if (hadCursor) cursor(1);
      return;
    case 17: k = "ctrl"; break;
    case 18: k = "alt"; break;
    case 20: k = "caps"; break;
    case 27: k = "esc"; break;
    case 13: k = "enter"; break;
    case 8:  k = "back"; break;
    case 46: k = "delete"; break;
    case 37: k = "left"; break;
    case 38: k = "up"; break;
    case 39: k = "right"; break;
    case 40: k = "down"; break;
    case 36: k = "home"; break;
    case 35: k = "end"; break;
    // fallthrough to printable handling for others
  }

  // Letters A-Z
  if (!k && b >= 65 && b <= 90) {
    var base = String.fromCharCode(b);
    var capsOn = !!caps;
    var shiftOn = !!shift;
    var makeUpper = (shiftOn && !capsOn) || (!shiftOn && capsOn);
    l = makeUpper ? base.toUpperCase() : base.toLowerCase();
    k = l;
  }

  // Non-letter printable mapping
  var keyMap = {
    48: ['0', ')'], 49: ['1', '!'], 50: ['2', '@'], 51: ['3', '#'],
    52: ['4', '$'], 53: ['5', '%'], 54: ['6', '^'], 55: ['7', '&'],
    56: ['8', '*'], 57: ['9', '('],
    186: [';', ':'], 187: ['=', '+'], 188: [',', '<'], 189: ['-', '_'],
    190: ['.', '>'], 191: ['/', '?'], 192: ['`', '~'],
    219: ['[', '{'], 220: ['\\', '|'], 221: [']', '}'], 222: ["'", '"'],
    32: [' ', ' ']
  };

  if (!k && keyMap[b]) {
    l = shift ? keyMap[b][1] : keyMap[b][0];
    k = l;
  }

  // Guard: don't turn control keycodes (<32) into characters
  if (!k && b < 32) {
    // nothing to insert (ignored control)
    if (hadCursor) cursor(1);
    return;
  }

  // Fallback: best-effort fromCharCode for remaining codes
  if (!k) {
    try {
      l = String.fromCharCode(b);
      // If it's a letter-like fallback, respect shift/caps XOR
      if (/[A-Za-z]/.test(l)) {
        var capsOn2 = !!caps;
        var shiftOn2 = !!shift;
        var makeUpper2 = (shiftOn2 && !capsOn2) || (!shiftOn2 && capsOn2);
        l = makeUpper2 ? l.toUpperCase() : l.toLowerCase();
      } else if (shift) {
        l = l.toUpperCase();
      }
      k = l;
    } catch (e) {
      k = ""; l = "";
    }
  }

  // Keep compatibility with existing code relying on globals k and l
  window.k = k;
  window.l = l;

  // Modifier keys: toggle visuals and don't insert
  if (k === "ctrl") {
    ctrl = !ctrl;
    var el = document.getElementById("ctrl");
    if (el) { el.style.backgroundColor = ctrl ? "#fff" : "#222"; el.style.color = ctrl ? "#000" : "#fff"; }
    if (hadCursor) cursor(1);
    return;
  }
  if (k === "alt") {
    alt = !alt;
    var el2 = document.getElementById("alt");
    if (el2) { el2.style.backgroundColor = alt ? "#fff" : "#222"; el2.style.color = alt ? "#000" : "#fff"; }
    if (hadCursor) cursor(1);
    return;
  }
  if (k === "caps") {
    caps = !caps;
    var capsEl = document.getElementById("kcaps") || document.getElementById("caps");
    if (capsEl) {
      if (caps) { capsEl.style.backgroundColor = "#fff"; capsEl.style.color = "#000"; }
      else { capsEl.style.backgroundColor = "#222"; capsEl.style.color = "#fff"; }
    }
    if (hadCursor) cursor(1);
    return;
  }

  // Insert / route the key according to keyon/run state
  if (keyon) {
    if (run && typeof keydown !== 'undefined') {
      try { keydown(k || l); } catch (e) { /* ignore script errors */ }
    } else {
      // Handle navigation/editing and printable insertion
      if (k === "back") {
        if (typeof cursorPos === 'undefined') cursorPos = line ? line.length : 0;
        if (cursorPos > 0) {
          line = line.substring(0, cursorPos - 1) + line.substring(cursorPos);
          cursorPos--;
        }
      } else if (k === "left") {
        if (typeof cursorPos === 'undefined') cursorPos = line ? line.length : 0;
        if (cursorPos > 0) cursorPos--;
      } else if (k === "right") {
        if (typeof cursorPos === 'undefined') cursorPos = line ? line.length : 0;
        if (cursorPos < (line ? line.length : 0)) cursorPos++;
      } else if (k === "home") {
        cursorPos = 0;
      } else if (k === "end") {
        cursorPos = line ? line.length : 0;
      } else if (k === "up" || k === "down") {
        // basic command history support if present
        if (typeof commandHistory !== 'undefined' && keyon) {
          if (k === "up") {
            if (commandHistory && commandHistory.length > 0) {
              if (typeof historyIndex === 'undefined' || historyIndex === -1) {
                tempCommand = line;
                historyIndex = commandHistory.length;
              }
              if (historyIndex > 0) {
                historyIndex--;
                line = commandHistory[historyIndex];
                cursorPos = line.length;
              }
            }
          } else {
            if (typeof historyIndex !== 'undefined' && historyIndex !== -1) {
              if (historyIndex < commandHistory.length - 1) {
                historyIndex++;
                line = commandHistory[historyIndex];
                cursorPos = line.length;
              } else {
                historyIndex = -1;
                line = tempCommand || "";
                cursorPos = line.length;
                tempCommand = "";
              }
            }
          }
        }
      } else if (k === "enter") {
        // submit line
        if (line !== undefined) {
          if (typeof commandHistory !== 'undefined' && line.trim().length > 0) {
            if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== line) {
              commandHistory.push(line);
              if (typeof maxHistorySize !== 'undefined' && commandHistory.length > maxHistorySize) {
                commandHistory.shift();
              }
            }
          }
          if (typeof historyIndex !== 'undefined') historyIndex = -1;
          tempCommand = "";

          if (run) {
            txt = (typeof txt !== 'undefined' ? txt : "") + line + "<br>";
            try { input(line); } catch (e) { /* ignore */ }
            line = "";
            cursorPos = 0;
          } else {
            txt = (typeof txt !== 'undefined' ? txt : "") + line + "<br>";
            if (line.slice(-3) === ".js") {
              keyon = 0;
              var prg = document.createElement('script');
              prg.src = line;
              prg.onload = function() { keyon = 1; };
              prg.onerror = function() { print("Error loading program\n"); keyon = 1; };
              document.head.appendChild(prg);
              line = "";
              cursorPos = 0;
            } else if (line.substr(0,3) === "cls") {
              if (typeof initScreen === 'function') initScreen(); else txt = "";
              line = "";
              cursorPos = 0;
            } else {
              try { executeCode(line); } catch (e) { /* ignore */ }
              line = "";
              cursorPos = 0;
            }
          }
        }
      } else if (l) {
        // Insert printable char(s)
        if (typeof cursorPos === 'undefined') cursorPos = line ? line.length : 0;
        var finalChar = l;
        var hasCtrl = !!ctrl;
        var hasAlt = !!alt;
        if (hasCtrl || hasAlt) {
          var modifiers = [];
          if (hasCtrl) modifiers.push("ctrl");
          if (hasAlt) modifiers.push("alt");
          finalChar = modifiers.join(" ") + " " + l;
          // consume virtual modifiers
          if (hasCtrl) {
            ctrl = 0; var ce = document.getElementById("ctrl"); if (ce) { ce.style.backgroundColor = "#222"; ce.style.color = "#fff"; }
          }
          if (hasAlt) {
            alt = 0; var ae = document.getElementById("alt"); if (ae) { ae.style.backgroundColor = "#222"; ae.style.color = "#fff"; }
          }
        }
        line = (line || "").substring(0, cursorPos) + finalChar + (line || "").substring(cursorPos);
        cursorPos += finalChar.length;
        if (typeof historyIndex !== 'undefined' && historyIndex !== -1) { historyIndex = -1; tempCommand = ""; }
      }

      // refresh input display
      try {
        if (typeof updateDisplay === 'function') updateDisplay();
        else print("");
      } catch (e) {
        try { print(""); } catch (_) {}
      }
    }
  } else {
    // keyon === 0: route to running script if any
    if (run && typeof keydown !== 'undefined') {
      try { keydown(k || l); } catch (e) { /* ignore */ }
    }
  }

  // restore cursor visual
  if (hadCursor) cursor(1);
}

function cursor(a) {
  // Ensure buffers exist (best-effort)
  if (!screenBuffer || !styleBuffer) {
    try { initScreen(); } catch (e) { /* ignore */ }
  }

  // clamp coordinates
  const cx = Math.max(0, Math.min((typeof screenWidth === 'number' ? screenWidth : 80) - 1, cursorX || 0));
  const cy = Math.max(0, Math.min((typeof screenHeight === 'number' ? screenHeight : 25) - 1, cursorY || 0));

  // Ensure prevCursor structure exists
  if (!prevCursor) prevCursor = { set: false, x: 0, y: 0, inverse: false, ch: ' ', style: null };

  // Helper to ensure a row exists in buffers
  function ensureRow(y) {
    if (!screenBuffer[y]) screenBuffer[y] = new Array(screenWidth).fill(' ');
    if (!styleBuffer[y]) {
      styleBuffer[y] = new Array(screenWidth);
      for (let x = 0; x < screenWidth; x++) {
        styleBuffer[y][x] = {
          color: currentStyle && currentStyle.color ? currentStyle.color : 37,
          bgcolor: currentStyle && currentStyle.bgcolor ? currentStyle.bgcolor : 40,
          bold: currentStyle && currentStyle.bold ? currentStyle.bold : false,
          inverse: currentStyle && currentStyle.inverse ? currentStyle.inverse : false
        };
      }
    }
  }

  if (a === 1) {
    // Show cursor
    // If a previous cursor was set at a different cell, restore it first
    if (prevCursor.set && !(prevCursor.x === cx && prevCursor.y === cy)) {
      const px = prevCursor.x, py = prevCursor.y;
      // restore saved char & style into buffers and DOM
      ensureRow(py);
      screenBuffer[py][px] = prevCursor.ch;
      styleBuffer[py][px] = prevCursor.style ? Object.assign({}, prevCursor.style) : {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: currentStyle.bold,
        inverse: prevCursor.inverse
      };
      // remove DOM marker if present
      const prevEl = document.getElementById(`c${py}_${px}`);
      if (prevEl) prevEl.classList.remove('qandy-cursor');
      pokeCell(px, py);
      prevCursor.set = false;
    }

    // Save the existing char & style at the new cursor cell
    ensureRow(cy);
    const existingChar = (screenBuffer[cy][cx] === undefined || screenBuffer[cy][cx] === null) ? ' ' : screenBuffer[cy][cx];
    const existingStyle = styleBuffer[cy][cx] ? Object.assign({}, styleBuffer[cy][cx]) : {
      color: currentStyle.color,
      bgcolor: currentStyle.bgcolor,
      bold: currentStyle.bold,
      inverse: currentStyle.inverse
    };

    prevCursor = {
      set: true,
      x: cx,
      y: cy,
      inverse: !!existingStyle.inverse,
      ch: existingChar,
      style: existingStyle
    };

    // Mark the buffer to show the cursor (use inverse so logic elsewhere stays consistent)
    styleBuffer[cy][cx] = Object.assign({}, existingStyle);
    styleBuffer[cy][cx].inverse = true;

    // Update DOM for this cell; prefer to add qandy-cursor class (strong visual), fallback to pokeCell
    const el = document.getElementById(`c${cy}_${cx}`);
    if (el) {
      el.classList.add('qandy-cursor');
      pokeCell(cx, cy); // still update classes/content in case other properties changed
    } else {
      // If element is not present, update via buffer/pokeCell
      pokeCell(cx, cy);
    }

    cursorOn = 1;

  } else {
    // Hide cursor: restore previous cell if we set one
    if (prevCursor && prevCursor.set) {
      const px = prevCursor.x, py = prevCursor.y;
      ensureRow(py);

      // remove DOM marker if present
      const el = document.getElementById(`c${py}_${px}`);
      if (el) el.classList.remove('qandy-cursor');

      // restore char and style into buffers
      screenBuffer[py][px] = prevCursor.ch;
      styleBuffer[py][px] = prevCursor.style ? Object.assign({}, prevCursor.style) : {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: currentStyle.bold,
        inverse: prevCursor.inverse
      };

      // update that cell in DOM
      pokeCell(px, py);

      prevCursor.set = false;
    }

    cursorOn = 0;
  }
}

function executeCode(code) {
  try {
    var trimmed = String(code).trim();
    var simpleNameRE = /^[$A-Za-z_][$A-Za-z0-9_]*(?:\s*\.\s*[$A-Za-z_][$A-Za-z0-9_]*)*$/;
    if (simpleNameRE.test(trimmed)) {
      try {
        var value = eval(trimmed);
      } catch (e) {
        print("Error: " + e.message + "\n\n");
        return false;
      }
      if (typeof value === "function") {
        print("ERROR: use: "+trimmed+"()\n\n");
        return true;
      }
      if (value !== undefined) { print(String(value) + "\n\n"); }
      return true;
    }
    var result = eval(code);
    if (result !== undefined) { print(String(result) + "\n\n"); }
    return true;
  } catch (error) {
    print("Error: " + error.message + "\n\n");
    return false;
  }
}

//function executeCode(code) {
// try {
//  const result=eval(code);
//  if (result !== undefined) {
//   print(String(result)+"<br>");
//  }
//  return true;
// } catch (error) {
//  print(`Error: ${error.message}`+"<br>");
//  return false;
// }
//}

function parseANSIString(str) {
  const tokens = [];
  // Match ANSI escape sequences in hex (\x1b), octal (\033 = \x1b), and unicode (\u001b) formats
  const ansiRegex = /(\x1b|\x1b|\u001b)\[([\d;]*)([A-Za-z])/g;
  let lastIndex = 0;
  let match;
  
  while ((match = ansiRegex.exec(str)) !== null) {
    // Add text before the ANSI code
    if (match.index > lastIndex) {
      const text = str.substring(lastIndex, match.index);
      for (let i = 0; i < text.length; i++) {
        tokens.push({ type: 'char', value: text[i] });
      }
    }
    
    // Add the ANSI code
    const params = match[2] ? match[2].split(';').filter(s => s !== '').map(Number) : [0];
    const command = match[3];
    
    if (command === 'm') {
      // SGR (Select Graphic Rendition) - color/style codes
      tokens.push({ type: 'code', codes: params });
    } else if (command === 'H' || command === 'f') {
      // CUP (Cursor Position) - move cursor to row;col
      // Format: \x1b[row;colH or \x1b[row;colf
      const row = params[0] ? params[0] - 1 : 0; // Convert to 0-based
      const col = params[1] ? params[1] - 1 : 0; // Convert to 0-based
      tokens.push({ type: 'cursor', row: row, col: col });
    } else if (command === 'K') {
      // EL (Erase in Line) - clear from cursor to end of line
      // param 0 or missing = clear from cursor to end
      // param 1 = clear from start to cursor
      // param 2 = clear entire line
      const mode = params[0] || 0;
      tokens.push({ type: 'clearline', mode: mode });
    }
    // Other ANSI commands are ignored for now
    
    lastIndex = match.index + match[0].length;
  }
  
  // Add remaining text
  if (lastIndex < str.length) {
    const text = str.substring(lastIndex);
    for (let i = 0; i < text.length; i++) {
      tokens.push({ type: 'char', value: text[i] });
    }
  }
  
  return tokens;
}

function applyANSICode(codes) {
  codes.forEach(code => {
    if (code === 0) {
      // Reset all
      currentStyle.color = 37;
      currentStyle.bgcolor = 40;
      currentStyle.bold = false;
      currentStyle.inverse = false;
    } else if (code === 1) {
      // Bold
      currentStyle.bold = true;
    } else if (code === 7) {
      // Inverse
      currentStyle.inverse = true;
    } else if (code === 27) {
      // No inverse
      currentStyle.inverse = false;
    } else if (code >= 30 && code <= 37) {
      // Foreground color
      currentStyle.color = code;
    } else if (code >= 40 && code <= 47) {
      // Background color
      currentStyle.bgcolor = code;
    }
  });
}

function scrollScreenDown() {
  screenBuffer.shift();
  styleBuffer.shift();
  
  const newLine = [];
  const newStyleLine = [];
  for (let j = 0; j < screenWidth; j++) {
    newLine[j] = ' ';
    newStyleLine[j] = {
      color: currentStyle.color,
      bgcolor: currentStyle.bgcolor,
      bold: currentStyle.bold,
      inverse: currentStyle.inverse
    };
  }
  screenBuffer.push(newLine);
  styleBuffer.push(newStyleLine);
}

// Helper functions

function showFiles() {
  print("\n");
  print("ascii.js\n");
  print("sound.js\n");
  print("piano.js\n");
  print("demo.js\n");
  print("q.js\n");
  print("world.js\n");
  print("\n");
  
  // List files from localStorage
  var userFiles = [];
  for (var i = 0; i < localStorage.length; i++) {
    var key = localStorage.key(i);
    if (key.startsWith("qandy_file_")) {
      userFiles.push(key.substring(11)); // Remove "qandy_file_" prefix
    }
  }
  
  if (userFiles.length > 0) {
    print("\x1b[1;32mUSER FILES:\x1b[0m\n");
    for (var j = 0; j < userFiles.length; j++) {
      print(userFiles[j] + "\n");
    }
    print("\n");
  }
}

function triggerPaginationPause() {
  // Prevent re-entering pause state
  if (paginationPaused) return;

  // Ensure draw() exists
  if (typeof draw !== 'function') {
    // fallback to previous approach if draw() not available
    console.warn("draw() not found — falling back to buffer-write pause.");
    // (Optionally call the robust buffer-writing variant here)
  }

  // Ensure buffers initialized
  if (!screenBuffer || screenBuffer.length === 0) initScreen();
  if (!styleBuffer || styleBuffer.length === 0) initScreen();

  // Save visible state we will restore
  const savedCursorX = typeof cursorX !== 'undefined' ? cursorX : 0;
  const savedCursorY = typeof cursorY !== 'undefined' ? cursorY : 0;
  const savedStyle = {
    color: currentStyle.color,
    bgcolor: currentStyle.bgcolor,
    bold: currentStyle.bold,
    inverse: currentStyle.inverse
  };

  // Mark pagination state and disable normal input
  paginationPaused = true;
  keyon = 0;

  // Reset any printed-line counters so next page starts fresh
  if (typeof printedLinesSinceLastPause !== 'undefined') printedLinesSinceLastPause = 0;

  // Build ANSI-coded pause message:
  // - Move cursor to bottom row (screenHeight), column 1
  // - Erase the entire line (\x1b[2K) or use \x1b[K to clear from cursor to end
  // - Set bright white and bold for visibility, print message, then reset attributes
  const row = Math.max(1, (typeof screenHeight === 'number' ? screenHeight : 25)); // ANSI rows are 1-based
  const pauseMsgPlain = "Press Any Key to Continue:";
  const ansiPause =
    "\x1b[" + row + ";1H" +    // CUP to bottom line, col 1
    "\x1b[2K" +               // Erase entire line
    "\x1b[1;37m" +            // Bold + white foreground
    pauseMsgPlain +
    "\x1b[0m";                // Reset attributes

  // Use draw() to render the ANSI-coded pause message WITHOUT scrolling
  try {
    draw(ansiPause);
  } catch (e) {
    // If draw() fails, fallback to writing into buffers directly (best-effort)
    console.warn("draw() failed in triggerPaginationPause():", e);
    // fallback: write into screenBuffer directly on last line
    const r = Math.min(screenHeight - 1, savedCursorY + 1);
    // clear line
    for (let c = 0; c < screenWidth; c++) {
      screenBuffer[row - 1][c] = ' ';
      styleBuffer[row - 1][c] = {
        color: 37, bgcolor: currentStyle.bgcolor, bold: true, inverse: false
      };
    }
    // write message, clipped to screenWidth
    for (let i = 0; i < pauseMsgPlain.length && i < screenWidth; i++) {
      screenBuffer[row - 1][i] = pauseMsgPlain.charAt(i);
      styleBuffer[row - 1][i] = { color: 37, bgcolor: currentStyle.bgcolor, bold: true, inverse: false };
    }
  }

  // Force a display update so the message is visible now
  try {
    updateDisplay();
  } catch (e) {
    // best-effort DOM refresh fallback
    try { document.getElementById("txt").innerHTML = document.getElementById("txt").innerHTML; } catch (_) {}
  }

  // Restore cursor position and style variables so printing resumes cleanly later.
  cursorX = savedCursorX;
  cursorY = savedCursorY;
  currentStyle.color = savedStyle.color;
  currentStyle.bgcolor = savedStyle.bgcolor;
  currentStyle.bold = savedStyle.bold;
  currentStyle.inverse = savedStyle.inverse;
}

// logical index = position within `line` (0-based)
function logicalToScreen(index) {
  const charsPerLine = screenWidth;
  // baseRow = screen row where logical index 0 maps to
  // derive from current cursor location and cursorPos:
  const baseRow = cursorY - Math.floor(cursorPos / charsPerLine);
  const rowOffset = Math.floor(index / charsPerLine);
  const col = index % charsPerLine;
  const row = baseRow + rowOffset;
  return { row: row, col: col };
}

// Recompute cursorX/cursorY from cursorPos using logicalToScreen
function syncCursorCoordsFromPos() {
  const charsPerLine = screenWidth;
  const baseRow = cursorY - Math.floor(cursorPos / charsPerLine);
  const row = baseRow + Math.floor(cursorPos / charsPerLine);
  const col = cursorPos % charsPerLine;
  cursorX = Math.max(0, Math.min(screenWidth - 1, col));
  cursorY = Math.max(0, Math.min(screenHeight - 1, row));
  // visually re-place cursor using existing cursor() routine
  if (cursorOn) {
    cursor(0); // hide previous visual
  }
  cursor(1);   // show at new coords
}

function writeInputSegmentToScreenRow(targetRow, startIdx, length) {
  if (targetRow < 0 || targetRow >= screenHeight) return;
  if (!screenBuffer[targetRow]) {
    screenBuffer[targetRow] = new Array(screenWidth).fill('\u00A0');
  }
  if (!styleBuffer[targetRow]) {
    styleBuffer[targetRow] = new Array(screenWidth);
    for (let x = 0; x < screenWidth; x++) {
      styleBuffer[targetRow][x] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: false,
        inverse: false
      };
    }
  }
  for (let i = 0; i < length; i++) {
    const strIdx = startIdx + i;
    const ch = (strIdx < line.length) ? line.charAt(strIdx) : '\u00A0'; // NBSP when beyond text
    const col = i;
    if (screenBuffer[targetRow][col] !== ch) {
      screenBuffer[targetRow][col] = ch;
      // default style for input text (tweak as you wish)
      styleBuffer[targetRow][col] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: false,
        inverse: false
      };
      pokeCell(col, targetRow);
    }
  }
}

// Update visual selection between selStart and selEnd (logical indices)
function updateSelectionVisuals(selStart, selEnd) {
  if (selStart === -1 || selEnd === -1) return;
  if (selStart > selEnd) { const t = selStart; selStart = selEnd; selEnd = t; }
  const charsPerLine = screenWidth;
  for (let i = selStart; i < selEnd; i++) {
    const { row, col } = logicalToScreen(i);
    if (row < 0 || row >= screenHeight || col < 0 || col >= screenWidth) continue;
    if (!styleBuffer[row]) continue;
    if (!styleBuffer[row][col]) {
      styleBuffer[row][col] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: false,
        inverse: true
      };
      pokeCell(col, row);
    } else if (!styleBuffer[row][col].inverse) {
      styleBuffer[row][col].inverse = true;
      pokeCell(col, row);
    }
  }
  // Clear inverse for cells outside selection in visible area (optional clean pass)
  // (you can optimize this to only clear previously-selected region)
  const totalVisible = Math.min(Math.ceil(Math.max(1, line.length) / charsPerLine), screenHeight);
  const baseRow = cursorY - Math.floor(cursorPos / charsPerLine);
  for (let r = baseRow; r < baseRow + totalVisible; r++) {
    if (!styleBuffer[r]) continue;
    for (let c = 0; c < screenWidth; c++) {
      const logicalIndex = (r - baseRow) * charsPerLine + c;
      if (logicalIndex < selStart || logicalIndex >= selEnd) {
        if (styleBuffer[r][c] && styleBuffer[r][c].inverse) {
          styleBuffer[r][c].inverse = false;
          pokeCell(c, r);
        }
      }
    }
  }
}

function print(inputString) {
  // Ensure screen is ready
  if (!screenBuffer || !styleBuffer || !screenWidth || !screenHeight) {
    try { initScreen(); } catch (e) { /* best-effort */ }
  }

  // Ensure a style row exists and each cell has its own object
  function ensureStyleRow(y) {
    if (!styleBuffer[y]) {
      styleBuffer[y] = [];
      for (let x = 0; x < screenWidth; x++) {
        styleBuffer[y][x] = {
          color: currentStyle.color,
          bgcolor: currentStyle.bgcolor,
          bold: currentStyle.bold,
          inverse: currentStyle.inverse
        };
      }
    }
  }

  // Ensure a screen row exists
  function ensureScreenRow(y) {
    if (!screenBuffer[y]) {
      screenBuffer[y] = new Array(screenWidth);
      for (let x = 0; x < screenWidth; x++) screenBuffer[y][x] = ' ';
      ensureStyleRow(y);
    }
  }

  // Write a single character at the current cursor and advance the cursor.
  function writeChar(ch) {
    // If cursor off bottom, scroll
    if (cursorY >= screenHeight) {
      try { scrollScreenDown(); } catch (e) {
        // fallback: clamp
        cursorY = screenHeight - 1;
      }
      cursorY = Math.min(cursorY, screenHeight - 1);
    }

    ensureScreenRow(cursorY);

    // Handle wrap before placing character
    if (cursorX >= screenWidth) {
      cursorX = 0;
      cursorY++;
      // If this moved us off bottom, scroll
      if (cursorY >= screenHeight) {
        try { scrollScreenDown(); } catch (e) { cursorY = screenHeight - 1; }
        cursorY = screenHeight - 1;
      }
      ensureScreenRow(cursorY);
    }

    // Place character and style copy
    if (screenBuffer[cursorY] && typeof screenBuffer[cursorY][cursorX] !== 'undefined') {
      screenBuffer[cursorY][cursorX] = ch;
      // copy current style into that cell (make a new object)
      styleBuffer[cursorY][cursorX] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: currentStyle.bold,
        inverse: currentStyle.inverse
      };
      try { pokeCell(cursorX, cursorY); } catch (e) { /* best-effort */ }
    }

    cursorX++;
  }

  // Basic CSI parser (handles sequences that end in a letter)
  let i = 0;
  while (i < inputString.length) {
    const code = inputString.charCodeAt(i);
    const ch = inputString.charAt(i);

    // CSI sequence: ESC [
    if (code === 27 && inputString.charAt(i + 1) === '[') {
      let j = i + 2;
      // gather parameters until a final byte (A-Za-z)
      let params = '';
      while (j < inputString.length && !/[A-Za-z]/.test(inputString.charAt(j))) {
        params += inputString.charAt(j);
        j++;
      }
      const cmd = inputString.charAt(j) || '';
      const paramsArr = params.length ? params.split(';').map(s => (s === '' ? NaN : Number(s))) : [];

      switch (cmd) {
        case 'H':
        case 'f': {
          // Cursor position (1-based)
          const row = (paramsArr[0] && !isNaN(paramsArr[0])) ? paramsArr[0] : 1;
          const col = (paramsArr[1] && !isNaN(paramsArr[1])) ? paramsArr[1] : 1;
          cursorY = Math.min(Math.max(0, row - 1), screenHeight - 1);
          cursorX = Math.min(Math.max(0, col - 1), screenWidth - 1);
          break;
        }
        case 'A': { // CUU - up
          const n = (paramsArr[0] && !isNaN(paramsArr[0])) ? paramsArr[0] : 1;
          cursorY = Math.max(0, cursorY - n);
          break;
        }
        case 'B': { // CUD - down
          const n = (paramsArr[0] && !isNaN(paramsArr[0])) ? paramsArr[0] : 1;
          cursorY = Math.min(screenHeight - 1, cursorY + n);
          break;
        }
        case 'C': { // CUF - forward
          const n = (paramsArr[0] && !isNaN(paramsArr[0])) ? paramsArr[0] : 1;
          cursorX = Math.min(screenWidth - 1, cursorX + n);
          break;
        }
        case 'D': { // CUB - back
          const n = (paramsArr[0] && !isNaN(paramsArr[0])) ? paramsArr[0] : 1;
          cursorX = Math.max(0, cursorX - n);
          break;
        }
        case 'K': { // Erase in line
          const mode = (paramsArr[0] && !isNaN(paramsArr[0])) ? paramsArr[0] : 0;
          ensureScreenRow(cursorY);
          if (mode === 0) { // clear from cursor to end of line
            for (let x = cursorX; x < screenWidth; x++) {
              screenBuffer[cursorY][x] = ' ';
              styleBuffer[cursorY][x] = {
                color: currentStyle.color,
                bgcolor: currentStyle.bgcolor,
                bold: currentStyle.bold,
                inverse: currentStyle.inverse
              };
              try { pokeCell(x, cursorY); } catch (e) {}
            }
          } else if (mode === 1) { // clear from start to cursor
            for (let x = 0; x <= cursorX; x++) {
              screenBuffer[cursorY][x] = ' ';
              styleBuffer[cursorY][x] = {
                color: currentStyle.color,
                bgcolor: currentStyle.bgcolor,
                bold: currentStyle.bold,
                inverse: currentStyle.inverse
              };
              try { pokeCell(x, cursorY); } catch (e) {}
            }
          } else if (mode === 2) { // clear whole line
            for (let x = 0; x < screenWidth; x++) {
              screenBuffer[cursorY][x] = ' ';
              styleBuffer[cursorY][x] = {
                color: currentStyle.color,
                bgcolor: currentStyle.bgcolor,
                bold: currentStyle.bold,
                inverse: currentStyle.inverse
              };
              try { pokeCell(x, cursorY); } catch (e) {}
            }
            cursorX = 0;
          }
          break;
        }
        case 'm': { // SGR - set graphic rendition (we apply a minimal subset)
          if (paramsArr.length === 0) {
            // reset
            currentStyle.color = 37;
            currentStyle.bgcolor = 40;
            currentStyle.bold = false;
            currentStyle.inverse = false;
          } else {
            for (let p of paramsArr) {
              if (isNaN(p)) continue;
              if (p === 0) {
                currentStyle.color = 37;
                currentStyle.bgcolor = 40;
                currentStyle.bold = false;
                currentStyle.inverse = false;
              } else if (p === 1) {
                currentStyle.bold = true;
              } else if (p >= 30 && p <= 37) {
                currentStyle.color = p;
              } else if (p >= 40 && p <= 47) {
                currentStyle.bgcolor = p;
              } else if (p === 7) {
                currentStyle.inverse = true;
              } else if (p === 27) {
                currentStyle.inverse = false;
              }
            }
          }
          break;
        }
        // Add any other CSI commands you need here
        default:
          // Unknown CSI - ignore
          break;
      }

      // advance i beyond the CSI
      i = j;
      i++; // move past final letter
      continue;
    }

    // Control characters & normal printing
    if (ch === '\n') {
      cursorX = 0;
      cursorY++;
      if (cursorY >= screenHeight) {
        try { scrollScreenDown(); } catch (e) { cursorY = screenHeight - 1; }
        cursorY = Math.min(cursorY, screenHeight - 1);
      }
    } else if (ch === '\r') {
      cursorX = 0;
    } else if (ch === '\b') {
      if (cursorX > 0) {
        cursorX--;
        ensureScreenRow(cursorY);
        screenBuffer[cursorY][cursorX] = ' ';
        styleBuffer[cursorY][cursorX] = {
          color: currentStyle.color,
          bgcolor: currentStyle.bgcolor,
          bold: currentStyle.bold,
          inverse: currentStyle.inverse
        };
        try { pokeCell(cursorX, cursorY); } catch (e) {}
      }
    } else {
      // Printable character
      writeChar(ch);
    }

    i++;
  }

  // Final safety: clamp cursor positions into visible range
  cursorX = Math.min(Math.max(0, cursorX), Math.max(0, screenWidth - 1));
  cursorY = Math.min(Math.max(0, cursorY), Math.max(0, screenHeight - 1));

  // Request a screen refresh. Use updateDisplay() if available, otherwise best-effort DOM update.
  try {
    if (typeof updateDisplay === 'function') updateDisplay();
    else if (typeof draw === 'function') draw();
    else { document.getElementById("txt").innerHTML = document.getElementById("txt").innerHTML; }
  } catch (e) {
    try { document.getElementById("txt").innerHTML = document.getElementById("txt").innerHTML; } catch (_) {}
  }
}

function draw(inputString) {
  // Draw text at current cursor location with ANSI codes
  // Does NOT scroll, trigger pagination, or update txt variable
  // Simply stops drawing when reaching screen boundaries

  // Make sure buffers are initialized
  if (!screenBuffer || screenBuffer.length === 0) {
    initScreen();
  }

  // Parse ANSI codes in input string
  const tokens = parseANSIString(inputString);

  // Process each token
  for (const token of tokens) {
    if (token.type === 'code') {
      // Update current style
      applyANSICode(token.codes);

    } else if (token.type === 'cursor') {
      // Cursor positioning (CUP) - move cursor to specified row/col (1-based from ANSI; parseANSIString should convert)
      cursorY = Math.min(Math.max(0, token.row), screenHeight - 1);
      cursorX = Math.min(Math.max(0, token.col), screenWidth - 1);

    } else if (token.type === 'clearline') {
      // Clear line from cursor position
      if (token.mode === 0) {
        // Clear from cursor to end of line
        for (let x = cursorX; x < screenWidth; x++) {
          if (screenBuffer[cursorY]) {
            screenBuffer[cursorY][x] = ' ';
            styleBuffer[cursorY][x] = {
              color: currentStyle.color,
              bgcolor: currentStyle.bgcolor,
              bold: currentStyle.bold,
              inverse: currentStyle.inverse
            };
          }
        }
      } else if (token.mode === 1) {
        // Clear from start of line to cursor
        for (let x = 0; x <= cursorX; x++) {
          if (screenBuffer[cursorY]) {
            screenBuffer[cursorY][x] = ' ';
            styleBuffer[cursorY][x] = {
              color: currentStyle.color,
              bgcolor: currentStyle.bgcolor,
              bold: currentStyle.bold,
              inverse: currentStyle.inverse
            };
          }
        }
      } else if (token.mode === 2) {
        // Clear entire line
        for (let x = 0; x < screenWidth; x++) {
          if (screenBuffer[cursorY]) {
            screenBuffer[cursorY][x] = ' ';
            styleBuffer[cursorY][x] = {
              color: currentStyle.color,
              bgcolor: currentStyle.bgcolor,
              bold: currentStyle.bold,
              inverse: currentStyle.inverse
            };
          }
        }
      }

    } else if (token.type === 'char') {
      // Write character to screenBuffer using currentStyle.
      const ch = token.value;

      // Handle newline explicitly (draw() should not scroll; just stop at bottom)
      if (ch === '\n') {
        cursorX = 0;
        cursorY++;
        if (cursorY >= screenHeight) {
          // stop drawing past bottom (preserve draw() contract of no scrolling)
          cursorY = screenHeight - 1;
          break;
        }
        continue;
      }

      // Only write if cursor is inside the visible area
      if (cursorY >= 0 && cursorY < screenHeight && cursorX >= 0 && cursorX < screenWidth) {
        screenBuffer[cursorY][cursorX] = ch;
        styleBuffer[cursorY][cursorX] = {
          color: currentStyle.color,
          bgcolor: currentStyle.bgcolor,
          bold: currentStyle.bold,
          inverse: currentStyle.inverse
        };
        cursorX++;
        if (cursorX >= screenWidth) {
          // hard wrap to next line (still no scrolling)
          cursorX = 0;
          cursorY++;
          if (cursorY >= screenHeight) {
            cursorY = screenHeight - 1;
            break;
          }
        }
      } else {
        // If cursor is outside horizontal bounds, stop writing
        // If vertical beyond bottom, stop entirely
        if (cursorY < 0 || cursorY >= screenHeight) break;
        if (cursorX < 0 || cursorX >= screenWidth) {
          // move to next line if beyond right edge
          cursorX = 0;
          cursorY++;
          if (cursorY >= screenHeight) {
            cursorY = screenHeight - 1;
            break;
          }
        }
      }
    }
  }

  // Refresh the display so ANSI styles become visible
  const _savedCursorY = cursorY;
  try {
    // Ensure updateDisplay renders all lines that may have been drawn to.
    // Set cursorY to screenHeight to render the entire buffer.
    cursorY = screenHeight;
    updateDisplay();
  } finally {
    // Restore exact cursor position so visible cursor doesn't move
    cursorY = _savedCursorY;
  }
}

function resumePagination() {
  // Clear the pause message by removing last few lines
  if (screenBuffer.length > 0) {
    // Remove the "Press Any Key" message line
    const lastLineIdx = screenBuffer.length - 1;
    for (let x = 0; x < screenWidth; x++) {
      screenBuffer[lastLineIdx][x] = ' ';
      styleBuffer[lastLineIdx][x] = {
        color: 37,
        bgcolor: 40,
        bold: false,
        inverse: false
      };
    }
  }
  
  // Reset pagination state
  paginationPaused = false;
  keyon = 1;  // Re-enable keyboard input
  
  // Clear the screen and reset cursor
  initScreen();
  
  // Process queued print calls
  const bufferedText = paginationBuffer.slice();  // Copy array
  paginationBuffer = [];  // Clear buffer
  
  // Print all buffered content
  for (let i = 0; i < bufferedText.length; i++) {
    print(bufferedText[i]);
  }
}

function updateDisplay() {
  if (!screenBuffer || screenBuffer.length === 0) { initScreen(); }
  if (!styleBuffer) { styleBuffer = []; }
  const txtElement = document.getElementById("txt");
  let htmlContent = '';
  // Render the full visible screen (clamped to available buffer).
  const rowsToRender = Math.min(screenHeight, screenBuffer.length);
  // small helper to escape characters for HTML
  function escapeChar(c) {
    if (c === ' ') return '&nbsp;';
    if (c === '&') return '&amp;';
    if (c === '<') return '&lt;';
    if (c === '>') return '&gt;';
    // keep control chars out of output
    if (c === '\t') return '&nbsp;&nbsp;&nbsp;&nbsp;';
    if (c === '\r' || c === '\n') return '';
    // default: return the character as-is (assumes ASCII printable)
    return c;
  }

  for (let y = 0; y < rowsToRender; y++) {
  // ensure row arrays exist (same as before)
  if (!screenBuffer[y]) { screenBuffer[y] = new Array(screenWidth).fill(' '); }
  if (!styleBuffer[y]) {
    styleBuffer[y] = new Array(screenWidth);
    for (let x = 0; x < screenWidth; x++) {
      styleBuffer[y][x] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: currentStyle.bold,
        inverse: currentStyle.inverse
      };
    }
  }

  let lineHtml = '<span class="qandy-line">';

  for (let x = 0; x < screenWidth; x++) {
    const ch = (screenBuffer[y][x] === undefined || screenBuffer[y][x] === null) ? ' ' : screenBuffer[y][x];
    const style = styleBuffer[y][x] || {
      color: currentStyle.color,
      bgcolor: currentStyle.bgcolor,
      bold: currentStyle.bold,
      inverse: currentStyle.inverse
    };

    // Build the class list for the character (map your ANSI to classes)
    const classes = [];
    if (style.inverse) {
      classes.push('ansi-inverse');
    } else {
      classes.push(`ansi-fg-${style.color}`);   // adjust names to match your CSS
      classes.push(`ansi-bg-${style.bgcolor}`);
    }
    if (style.bold) classes.push('ansi-bold');

    // Escape char for HTML; keep spaces as &nbsp;
    const escapedChar = (ch === ' ') ? '&nbsp;' :
                        (ch === '&') ? '&amp;' :
                        (ch === '<') ? '&lt;' :
                        (ch === '>') ? '&gt;' :
                        ch;

    // Give each cell an id so it can be updated independently later.
    lineHtml += `<span id="c${y}_${x}" class="${classes.join(' ')}">${escapedChar}</span>`;
  }

  lineHtml += '</span><br>';
  htmlContent += lineHtml;
}

  // Fill remaining visible rows with blank lines if buffer is shorter than screenHeight
  for (let y = rowsToRender; y < screenHeight; y++) {
    htmlContent += `<div class="row">&nbsp;</div>`;
  }

  // Write to DOM in one shot
  txtElement.innerHTML = htmlContent;

  try {
    // Remove previous cursor markers (if any)
    const prev = document.querySelectorAll('.qandy-cursor');
    for (let p = 0; p < prev.length; p++) prev[p].classList.remove('qandy-cursor');

    // Add cursor marker to current cursor position (cursorX, cursorY are logical coords)
    if (typeof cursorX === 'number' && typeof cursorY === 'number') {
      const curEl = document.getElementById(`c${cursorY}_${cursorX}`);
      if (curEl) {
        curEl.classList.add('qandy-cursor');
      }
    }
  } catch (e) {
    // Non-fatal: best-effort only
    console.warn('Failed to apply qandy cursor marker', e);
  }

}


  function ensureBuffersAndRow(y) {
    if (!window.screenWidth) window.screenWidth = 32;
    if (!window.screenHeight) window.screenHeight = 25;
    if (!window.screenBuffer) window.screenBuffer = [];
    if (!window.styleBuffer) window.styleBuffer = [];
    if (!window.screenBuffer[y]) {
      window.screenBuffer[y] = new Array(window.screenWidth);
      for (var i = 0; i < window.screenWidth; i++) window.screenBuffer[y][i] = ' ';
    }
    if (!window.styleBuffer[y]) {
      window.styleBuffer[y] = new Array(window.screenWidth);
      for (var i = 0; i < window.screenWidth; i++) {
        window.styleBuffer[y][i] = {
          color: (window.currentStyle && window.currentStyle.color) || 37,
          bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
          bold: false,
          inverse: false
        };
      }
    }
  }

  function safeGet(arr, y, x) {
    if (!arr) return undefined;
    if (typeof y !== 'number' || typeof x !== 'number') return undefined;
    if (!arr[y]) return undefined;
    return arr[y][x];
  }

  function updateDomCell(x, y) {
    try {
      var elId = 'c' + y + '_' + x; // qandy's cell id convention (row_col)
      var el = document.getElementById(elId);
      var ch = safeGet(window.screenBuffer, y, x);
      var style = safeGet(window.styleBuffer, y, x);

      // Convert to safe innerHTML; use &nbsp; for spaces/NBSP so it remains visible
      var html;
      if (typeof ch === 'string') {
        if (ch === '\u00A0' || ch === ' ') html = '&nbsp;';
        else html = ch.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      } else {
        html = '&nbsp;';
      }

      if (el) {
        el.innerHTML = html;
        // apply minimal style hints so the cell looks correct if inverse/bold changed
        if (style && style.inverse) {
          el.style.backgroundColor = '#fff';
          el.style.color = '#000';
        } else {
          el.style.backgroundColor = '';
          el.style.color = '';
        }
        el.style.fontWeight = (style && style.bold) ? 'bold' : '';
        return true;
      } else {
        return false;
      }
    } catch (e) {
      console.error('updateDomCell error:', e);
      return false;
    }
  }

  // Main pokeCell implementation
  window.pokeCell = function(x, y, ch) {
    if (typeof x !== 'number' || typeof y !== 'number') {
      throw new Error('pokeCell requires numeric x,y coordinates: pokeCell(x,y[,ch])');
    }

    // ensure buffers exist
    ensureBuffersAndRow(y);

    // Getter: return stored char
    if (typeof ch === 'undefined') {
      return safeGet(window.screenBuffer, y, x);
    }

    // Setter: normalize ch to single-character string
    if (typeof ch !== 'string' || ch.length === 0) {
      ch = String(ch || ' ')[0] || ' ';
    }

    // Write into screen buffer (row-major: screenBuffer[y][x])
    window.screenBuffer[y][x] = ch;

    // Ensure there is a style object for this cell
    if (!window.styleBuffer[y][x]) {
      window.styleBuffer[y][x] = {
        color: (window.currentStyle && window.currentStyle.color) || 37,
        bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
        bold: false,
        inverse: false
      };
    }

    // If prevCursor references this cell (cursor logic saved this cell previously),
    // update prevCursor.ch/style so the cursor hide/show logic won't later restore an old value.
    try {
      if (window.prevCursor && window.prevCursor.set) {
        if (window.prevCursor.x === x && window.prevCursor.y === y) {
          window.prevCursor.ch = ch;
          // clone style so later restore uses current style
          var s = window.styleBuffer[y][x];
          window.prevCursor.style = s ? Object.assign({}, s) : window.prevCursor.style;
        }
      }
    } catch (e) {
      // non-fatal
      console.warn('pokeCell: failed to update prevCursor:', e);
    }

    // Update cell in DOM if it exists; otherwise attempt full redraw via updateDisplay()
    var domUpdated = updateDomCell(x, y);
    if (!domUpdated && typeof updateDisplay === 'function') {
      try { updateDisplay(); domUpdated = true; } catch (e) { /* ignore */ }
    }

    return domUpdated;
  };


// helper: ensure buffers and row exist
function ensureBuffersAndRow(y) {
  if (!window.screenWidth) window.screenWidth = 32;
  if (!window.screenHeight) window.screenHeight = 25;
  if (!window.screenBuffer) window.screenBuffer = [];
  if (!window.styleBuffer) window.styleBuffer = [];
  if (!window.screenBuffer[y]) {
    window.screenBuffer[y] = new Array(window.screenWidth);
    for (var i = 0; i < window.screenWidth; i++) window.screenBuffer[y][i] = ' ';
  }
  if (!window.styleBuffer[y]) {
    window.styleBuffer[y] = new Array(window.screenWidth);
    for (var i = 0; i < window.screenWidth; i++) {
      window.styleBuffer[y][i] = {
        color: (window.currentStyle && window.currentStyle.color) || 37,
        bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
        bold: !!(window.currentStyle && window.currentStyle.bold),
        inverse: !!(window.currentStyle && window.currentStyle.inverse)
      };
    }
  }
}

function safeGet(arr, y, x) {
  if (!arr) return undefined;
  if (typeof y !== 'number' || typeof x !== 'number') return undefined;
  if (!arr[y]) return undefined;
  return arr[y][x];
}

// Remove existing ansi-fg-* and ansi-bg-* classes from el
function removeAnsiColorClasses(el) {
  if (!el || !el.classList) return;
  var toRemove = [];
  el.classList.forEach(function (c) {
    if (/^ansi-fg-\d+$/.test(c) || /^ansi-bg-\d+$/.test(c)) toRemove.push(c);
  });
  toRemove.forEach(function (c) { el.classList.remove(c); });
}

// Update DOM cell classes/inline style from styleObj
function applyStyleToDom(el, styleObj) {
  if (!el) return;
  // remove old ANSI color classes
  removeAnsiColorClasses(el);
  // add new ones if provided
  if (styleObj && typeof styleObj.color !== 'undefined') {
    el.classList.add('ansi-fg-' + String(styleObj.color));
  }
  if (styleObj && typeof styleObj.bgcolor !== 'undefined') {
    el.classList.add('ansi-bg-' + String(styleObj.bgcolor));
  }
  // bold -> inline weight (repo CSS also has ansi-bold, but use inline to be immediate)
  if (styleObj && styleObj.bold) {
    el.style.fontWeight = 'bold';
    el.classList.add('ansi-bold');
  } else {
    el.style.fontWeight = '';
    el.classList.remove('ansi-bold');
  }
  // inverse: add a class to hint repo code; also swap colors if you want
  if (styleObj && styleObj.inverse) {
    el.classList.add('ansi-inverse');
    // leave actual fg/bg class names; repo drawing code interprets inverse sometimes.
  } else {
    el.classList.remove('ansi-inverse');
  }
}

// Update just the DOM cell content and style in-place if element exists
function updateDomCellInPlace(x, y) {
  try {
    var elId = 'c' + y + '_' + x; // repo convention: c{row}_{col}
    var el = document.getElementById(elId);
    var ch = safeGet(window.screenBuffer, y, x);
    var styleObj = safeGet(window.styleBuffer, y, x);
     if (!el) return false;
     // write char (use &nbsp; for space)
    if (typeof ch === 'string') {
      if (ch === '\u00A0' || ch === ' ') el.innerHTML = '&nbsp;';
      else el.textContent = ch;
    } else {
      el.innerHTML = '&nbsp;';
    }
     applyStyleToDom(el, styleObj);
    return true;
  } catch (e) {
    console.error('updateDomCellInPlace error:', e);
    return false;
  }
}

// New: setCellStyle(x,y, styleObj) updates styleBuffer and DOM (no char change)
window.setCellStyle = function (x, y, styleObj) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new Error('setCellStyle requires numeric x,y: setCellStyle(x,y, { color:.., bgcolor:.., bold:.., inverse:.. })');
  }
  ensureBuffersAndRow(y);
  var row = window.styleBuffer[y];
  if (!row[x]) {
    row[x] = {
      color: (window.currentStyle && window.currentStyle.color) || 37,
      bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
      bold: false,
      inverse: false
    };
  }
  // apply provided fields (only update provided keys)
  if (typeof styleObj.color !== 'undefined') row[x].color = styleObj.color;
  if (typeof styleObj.bgcolor !== 'undefined') row[x].bgcolor = styleObj.bgcolor;
  if (typeof styleObj.bold !== 'undefined') row[x].bold = !!styleObj.bold;
  if (typeof styleObj.inverse !== 'undefined') row[x].inverse = !!styleObj.inverse;
   // If prevCursor points here, update it so cursor restore won't clobber style
  try {
    if (window.prevCursor && window.prevCursor.set && window.prevCursor.x === x && window.prevCursor.y === y) {
      window.prevCursor.style = Object.assign({}, row[x]);
    }
  } catch (e) { /* ignore */ }
   // update DOM or fallback
  var domUpdated = updateDomCellInPlace(x, y);
  if (!domUpdated && typeof updateDisplay === 'function') {
    try { updateDisplay(); domUpdated = true; } catch (e) { /* ignore */ }
  }
  return domUpdated;
};

// Backwards-compatible pokeCell: fourth arg optional styleObj
var _orig_pokeCell = window.pokeCell; // in case a previous wrapper exists
window.pokeCell = function (x, y, ch, styleObj) {
  // If a previous pokeCell exists in global and was not our previous wrapper, delegate; but we reimplement anyway.
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new Error('pokeCell requires numeric x,y coordinates: pokeCell(x,y[,ch[,styleObj]])');
  }
  ensureBuffersAndRow(y);
   if (typeof ch === 'undefined') {
    return safeGet(window.screenBuffer, y, x);
  }
   // normalize char
  if (typeof ch !== 'string' || ch.length === 0) ch = String(ch || ' ')[0] || ' ';
   // write char
  window.screenBuffer[y][x] = ch;
   // ensure style exists
  if (!window.styleBuffer[y][x]) {
    window.styleBuffer[y][x] = {
      color: (window.currentStyle && window.currentStyle.color) || 37,
      bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
      bold: !!(window.currentStyle && window.currentStyle.bold),
      inverse: !!(window.currentStyle && window.currentStyle.inverse)
    };
  }
   // apply styleObj if provided (partial update)
  if (styleObj && typeof styleObj === 'object') {
    if (typeof styleObj.color !== 'undefined') window.styleBuffer[y][x].color = styleObj.color;
    if (typeof styleObj.bgcolor !== 'undefined') window.styleBuffer[y][x].bgcolor = styleObj.bgcolor;
    if (typeof styleObj.bold !== 'undefined') window.styleBuffer[y][x].bold = !!styleObj.bold;
    if (typeof styleObj.inverse !== 'undefined') window.styleBuffer[y][x].inverse = !!styleObj.inverse;
  }
   // update prevCursor if it pointed here (so cursor logic won't restore old char/style)
  try {
    if (window.prevCursor && window.prevCursor.set && window.prevCursor.x === x && window.prevCursor.y === y) {
      window.prevCursor.ch = ch;
      window.prevCursor.style = Object.assign({}, window.styleBuffer[y][x]);
    }
  } catch (e) { /* ignore */ }
   // update DOM cell in-place if possible, otherwise fallback to updateDisplay()
  var ok = updateDomCellInPlace(x, y);
  if (!ok && typeof updateDisplay === 'function') {
    try { updateDisplay(); ok = true; } catch (e) { /* ignore */ }
  }
   return ok;
};

 
window.setCellStyle = window.setCellStyle; // already set above
window.poke = function (x, y, ch, styleObj) { return window.pokeCell(x, y, ch, styleObj); };
window.peek = function (x, y) { return safeGet(window.screenBuffer, y, x); };

function ensureRow(y) {
  if (!window.screenBuffer) window.screenBuffer = [];
  if (!window.styleBuffer) window.styleBuffer = [];
  if (!window.screenBuffer[y]) {
    window.screenBuffer[y] = new Array(window.screenWidth || 0);
    for (var i = 0; i < (window.screenWidth || 0); i++) window.screenBuffer[y][i] = ' ';
  }
  if (!window.styleBuffer[y]) {
    window.styleBuffer[y] = new Array(window.screenWidth || 0);
    for (var i = 0; i < (window.screenWidth || 0); i++) {
      window.styleBuffer[y][i] = {
        color: (window.currentStyle && window.currentStyle.color) || 37,
        bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
        bold: false,
        inverse: false
      };
    }
  }
}

function renderCellToDOM(x, y) {
  try {
    var elId = 'c' + y + '_' + x;
    var el = document.getElementById(elId);
    var ch = safeGet(window.screenBuffer, y, x);
    var style = safeGet(window.styleBuffer, y, x);
     // Normalize character for visible HTML
    var safeText;
    if (typeof ch === 'string') {
      if (ch === '\u00A0' || ch === ' ') safeText = '&nbsp;';
      else safeText = escapeHtml(ch);
    } else {
      safeText = '&nbsp;';
    }
     if (el) {
      // apply text
      el.innerHTML = safeText;
       // apply simple style hints
      if (style && style.inverse) {
        el.style.backgroundColor = '#fff';
        el.style.color = '#000';
      } else {
        el.style.backgroundColor = '';
        el.style.color = '';
      }
      el.style.fontWeight = style && style.bold ? 'bold' : '';
      return true;
    } else {
      // fallback: if an updateDisplay function exists, use it to re-render everything
      if (typeof updateDisplay === 'function') {
        try { updateDisplay(); return true; } catch (e) { /* fallthrough */ }
      }
      // else do nothing but return false to indicate DOM not updated in place
      return false;
    }
  } catch (e) {
    console.error('renderCellToDOM error:', e);
    return false;
  }
}

function escapeHtml(s) {
  return String(s).replace(/&/g, '&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function safeGet(arr, y, x) {
  if (!arr) return undefined;
  if (typeof y !== 'number' || typeof x !== 'number') return undefined;
  if (!arr[y]) return undefined;
  return arr[y][x];
}

// Main pokeCell: if ch is provided -> set; if not provided -> return current char
window.pokeCell = function (x, y, ch) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new Error('pokeCell requires numeric x,y coordinates: pokeCell(x,y[,ch])');
  }
   // ensure buffers for that row exist
  if (!window.screenBuffer || !window.styleBuffer || typeof window.screenWidth !== 'number') {
    // best-effort: initialize minimal screen if missing
    if (!window.screenWidth) window.screenWidth = 64;
    if (!window.screenHeight) window.screenHeight = 30;
    if (!window.screenBuffer) window.screenBuffer = [];
    if (!window.styleBuffer) window.styleBuffer = [];
  }
  ensureRow(y);
   if (typeof ch === 'undefined') {
    // getter: return the stored character (may be undefined)
    return safeGet(window.screenBuffer, y, x);
  } else {
    // setter: accept only single-character strings (or NBSP)
    if (typeof ch !== 'string' || ch.length === 0) {
      // allow explicit NBSP code
      if (ch === '\u00A0') {
        // ok
      } else {
        // coerce to string and take first codepoint
        ch = String(ch)[0] || ' ';
      }
    }
    // store into buffer (row-major screenBuffer[y][x])
    window.screenBuffer[y][x] = ch;
     // ensure style exists for that cell
    if (!window.styleBuffer[y][x]) {
      window.styleBuffer[y][x] = {
        color: (window.currentStyle && window.currentStyle.color) || 37,
        bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
        bold: false,
        inverse: false
      };
    }
     // update DOM cell if possible
    var ok = renderCellToDOM(x, y);
     // if DOM cell wasn't found or render failure, try full redraw updateDisplay if available
    if (!ok && typeof updateDisplay === 'function') {
      try { updateDisplay(); ok = true; } catch (e) { /* ignore */ }
    }
     return ok;
  }
};

// Provide PEEK/POKE proxies for linear addressing: addr = y*screenWidth + x
function addrToXY(addr) {
  if (typeof window.screenWidth !== 'number' || window.screenWidth <= 0) {
    throw new Error('screenWidth not defined; cannot convert addr -> (x,y)');
  }
  var y = Math.floor(addr / window.screenWidth);
  var x = addr - (y * window.screenWidth);
  return { x: x, y: y };
}

// PEEK proxy (read-only)
window.PEEK = new Proxy({}, {
  get: function (target, prop) {
    var a = Number(prop);
    if (isNaN(a)) return undefined;
    var p = addrToXY(a);
    return safeGet(window.screenBuffer, p.y, p.x);
  },
  has: function() { return true; }
});

// POKE proxy (write)
window.POKE = new Proxy({}, {
  set: function (target, prop, value) {
    var a = Number(prop);
    if (isNaN(a)) {
      // ignore non-numeric props
      target[prop] = value;
      return true;
    }
    var p = addrToXY(a);
    try {
      // call our pokeCell setter
      window.pokeCell(p.x, p.y, value);
    } catch (e) {
      console.error('POKE set error for addr', a, e);
    }
    return true;
  },
  get: function(target, prop) {
    var a = Number(prop);
    if (isNaN(a)) return undefined;
    var p = addrToXY(a);
    return safeGet(window.screenBuffer, p.y, p.x);
  }
});
 
// Usage examples (console):
//   peekCell(10,5)        // returns object with character, codepoint, style, DOM info
//   peekAddr(350)         // converts linear addr -> (x,y) then returns same object
//   peekLog(10,5)         // prints a one-line summary + full object

function peekCell(x,y) {
  // avoid clobbering if already installed
  if (window.peekCellInstalled) return;
  window.peekCellInstalled = true;

  function safeGet(arr, y, x) {
    if (!arr) return undefined;
    if (typeof y !== 'number' || typeof x !== 'number') return undefined;
    if (!arr[y]) return undefined;
    return arr[y][x];
  }

  function normChar(ch) {
    if (typeof ch !== 'string') return { raw: ch, display: String(ch) };
    if (ch === '\u00A0') return { raw: ch, display: '<NBSP>' };
    if (ch === '\n') return { raw: ch, display: '<LF>' };
    if (ch === '\r') return { raw: ch, display: '<CR>' };
    if (ch.length === 0) return { raw: ch, display: '<EMPTY>' };
    var cp = ch.codePointAt(0);
    if (cp < 32 || (cp >= 0x7F && cp <= 0x9F)) {
      return { raw: ch, display: '<CTRL U+' + cp.toString(16).toUpperCase().padStart(4, '0') + '>' };
    }
  }
}

function cursorMoveTo(nx, ny) {
  const old = { x: cursorX, y: cursorY };
  cursorX = Math.max(0, Math.min(screenWidth - 1, nx));
  cursorY = Math.max(0, Math.min(screenHeight - 1, ny));
  if (cursorOn) {
    // restore old cell
    if (prevCursor.set && styleBuffer[old.y] && styleBuffer[old.y][old.x]) {
      styleBuffer[old.y][old.x].inverse = prevCursor.inverse;
      pokeCell(old.x, old.y);
    }
    // mark new one
    if (!styleBuffer[cursorY]) {
      styleBuffer[cursorY] = [];
      for (let x = 0; x < screenWidth; x++) {
        styleBuffer[cursorY][x] = {
          color: currentStyle.color,
          bgcolor: currentStyle.bgcolor,
          bold: currentStyle.bold,
          inverse: currentStyle.inverse
        };
      }
    }
    prevCursor = { set: true, x: cursorX, y: cursorY, inverse: !!styleBuffer[cursorY][cursorX].inverse };
    styleBuffer[cursorY][cursorX].inverse = true;
    pokeCell(old.x, old.y);
    pokeCell(cursorX, cursorY);
  } else {
    // cursor isn't shown — just update logical coords
  }
}

function cls() { 
  screenBuffer = [];  // Reset global screenBuffer (removed 'var' to avoid shadowing)
  initScreen(); 
  // Reset pagination state
  paginationPaused = false;
  paginationBuffer = [];
}

function gfx(scr) { a=0; for (b=0; b<=mapy; b++) { for (c=0; c<=mapx; c++) { e=document.getElementById("T"+a).src="t/"+scr.charAt(a*2)+scr.charAt((a*2)+1)+".png"; a++; }}}
function hpop() { document.getElementById("pop").style.visibility="hidden"; }
function pop(htm) {
 e=document.getElementById("pop").innerHTML="<p>"+htm;
 TopYPos=32+22; TopXPos=32+22;
 
 PopAlign="center";
 
 switch (PopAlign) {
  case "char":
   PopY=TopYPos+(PY*32)+8; PopX=TopXPos+(PX*32)+32; 
   if (PopY<TopYPos) { PopY=TopYPos; } if (PopY<TopYPos+10) { PopY=TopYPos+10; }
   if (PopX<TopXPos) { PopX=TopXPos; } if (PopX<TopXPos+10) { PopX=TopXPos+10; }
   if (PopX+document.getElementById("pop").scrollWidth>TopXPos+256) { PopX=(TopXPos+256)-document.getElementById("PopUp").scrollWidth; }
   if (PopY+document.getElementById("pop").scrollHeight>TopYPos+384) { PopY=(TopYPos+384)-document.getElementById("PopUp").scrollHeight; }
   break;
   // width: 256px; height: 384px;
  case "center":
   PopX=TopXPos+((256-document.getElementById("pop").scrollWidth)/2);
   PopY=TopYPos+((384-document.getElementById("pop").scrollHeight)/2);
   break;
  case "click":
   PopY=Math.floor(PopClick/(MapSizeX+1));
   PopX=PopClick-(PopY*(MapSizeX+1));
   PopY=(PopY*32)+22; PopX=(PopX*32)+22;
   if (PopX+document.getElementById("PopUp").scrollWidth>TopXPos+424) { PopX=(TopXPos+424)-document.getElementById("PopUp").scrollWidth; }
   if (PopY+document.getElementById("PopUp").scrollHeight>TopYPos+300) { PopY=(TopYPos+300)-document.getElementById("PopUp").scrollHeight; }
   break;
 }  
 document.getElementById("pop").style.top=PopY; 
 document.getElementById("pop").style.left=PopX;
 document.getElementById("pop").style.visibility="visible";
 //poptimer=setTimeout('document.getElementById("pop").style.visibility="visible";',200);
}

function char(C,O,Z) {
 Y=Math.floor(Z/(mapx+1)); X=Z-(Y*(mapx+1)); Y--;
 idface="cf"+C; idbody="cb"+C; idwpn="cw"+C; idarm="ca"+C; idhat="ch"+C;
 face=""; body=""; wpn=""; arm=""; hat="";

 if (O.indexOf("A")>-1) { face="A"+O.charAt(O.indexOf("A")+1); }
 if (O.indexOf("B")>-1) { face="B"+O.charAt(O.indexOf("B")+1); }
 if (O.indexOf("E")>-1) { face="E"+O.charAt(O.indexOf("E")+1); }
 if (O.indexOf("F")>-1) { face="F"+O.charAt(O.indexOf("F")+1); }

 if (O.indexOf("C")>-1) { body="C"+O.charAt(O.indexOf("C")+1); }
 if (O.indexOf("D")>-1) { body="D"+O.charAt(O.indexOf("D")+1); }
 if (O.indexOf("G")>-1) { body="G"+O.charAt(O.indexOf("G")+1); }
 if (O.indexOf("H")>-1) { body="H"+O.charAt(O.indexOf("H")+1); }

 if (document.getElementById("cb"+C)) {
  e=document.getElementById("cb"+C).src="c/"+body+".png";
  e=document.getElementById("cb"+C).style.top=32+22+(Y*32)+"px";
  e=document.getElementById("cb"+C).style.left=(32+22+(X*32))+"px";
 } else {
  chr=document.createElement("img");
  chr.id="cb"+C; chr.src="c/"+body+".png";
  chr.className="char";  
  chr.style.position="absolute"; chr.style.height=64; chr.style.width=32;
  chr.style.top=32+22+(Y*32)+"px"; chr.style.left=(32+22+(X*32))+"px";
  chr.onclick=function() { chr.onmousedown=new Function("ClickChar("+(PZ)+",this.parentNode)"); }
  chr.style.zIndex="150";  
  document.body.appendChild(chr);
 }
 if (document.getElementById("cf"+C)) {
  e=document.getElementById("cf"+C).src="c/"+face+".png";
  e=document.getElementById("cf"+C).style.top=32+22+(Y*32)+"px";
  e=document.getElementById("cf"+C).style.left=(32+22+(X*32))+"px";
 } else {
  chr=document.createElement("img");
  chr.id="cf"+C; chr.src="c/"+face+".png";
  chr.className="char";  
  chr.style.position="absolute"; chr.style.height=64; chr.style.width=32;
  chr.style.top=32+22+(Y*32)+"px"; chr.style.left=(32+22+(X*32))+"px";
  chr.onclick=function() { chr.onmousedown=new Function("ClickChar("+(PZ)+",this.parentNode)"); }
  chr.style.zIndex="151";
  document.body.appendChild(chr);
 }

 if (O.indexOf("I")>-1) { hat="I"+O.charAt(O.indexOf("I")+1); }
 if (O.indexOf("J")>-1) { hat="J"+O.charAt(O.indexOf("J")+1); }
 if (hat) {
  if (document.getElementById("ch"+C)) {
   e=document.getElementById("ch"+C).src="c/"+hat+".png";
   e=document.getElementById("ch"+C).style.top=32+22+(Y*32)+"px";
   e=document.getElementById("ch"+C).style.left=(32+22+(X*32))+"px";
  } else {
   chr=document.createElement("img");
   chr.id="ch"+C; chr.src="c/"+hat+".png";
   chr.className="char";  
   chr.style.position="absolute"; chr.style.height=64; chr.style.width=32;
   chr.style.top=32+22+(Y*32)+"px"; chr.style.left=(32+22+(X*32))+"px";
   chr.onclick=function() { chr.onmousedown=new Function("ClickChar("+(PZ)+",this.parentNode)"); }
   chr.style.zIndex="152";
   document.body.appendChild(chr);
  } 
 } else {
  if (document.getElementById("ch"+PName)) { document.getElementById("ch"+PName).remove(); } 
 }
}

function ItemID(I) {
 switch (I) {
  case "Aa": return "Travel Boots"; break;
  case "Ab": return "Hiking Boots"; break;
  case "Ac": return "Swamp Boots"; break;
  case "Ad": return "Mountain Boots"; break;
  case "Ae": return "Lava Boots"; break;
  case "Bd": return "Bucket"; break;
  case "Be": return "Lantern"; break;
  case "Cg": return "Log"; break;
  case "Ek": return "Bucket of Tar"; break;
  case "El": return "Bucket of Water"; break;
  case "Fa": return "Tomato"; break;
  case "Fb": return "Tomatoes"; break;
  case "Fc": return "Tomatoes"; break;
  case "Fd": return "Tomatoes"; break;
  case "Jc": return "Candy"; break;
  case "Ka": return "Plant"; break;
  case "Kf": return "Bread"; break;
  case "La": return "DevTeam Hat"; break;
  case "Lb": return "Player Hat"; break;
  case "Lc": return "Player Hat"; break;
  case "Ld": return "Red Bandana"; break;
  case "Lg": return "Blue Bandana"; break;
  case "Ma": return "Cylon Helmet"; break;
  case "Mb": return "Cylon Helmet"; break;
  case "Md": return "Mask"; break;
  case "Ob": return "Shield"; break; 
  case "Pj": return "Sword"; break;
  case "Re": return "Medicine"; break;
   
  case "Va": return "Spider"; break;
  case "Vb": return "Mosquito"; break;
  case "Vc": return "Scorpion"; break;
  case "Vd": return "Fire Ant"; break;
  case "Yb": return "Cart"; break;
  case "Yc": return "Furnace"; break;
  case "Ye": return "Seeds"; break;
  case "Yi": return "Goblin Village"; break;  
  case "Ze": return "Teleport"; break
  case "Zf": return "Sign"; break
  case "Zg": return "Pier"; break  
  case "Zi": return "Fire Pit"; break;  
  case "Zj": return "Fire"; break;
  case "Zh": return "Well"; break;
  case "Zm": return "City"; break
 } 
}

function ClickTile(Z) {
 Y=Math.floor(Z/mapx); X=Z-(Y*mapx); 
 if (run) { MenuTile(Z); }
}

function ClickChar(Z) {
 if (run) { MenuChar(Z); }
}

// system ready

initScreen();
function initScreen() {
  screenBuffer = [];
  styleBuffer = [];
  cursorX = 0;
  cursorY = 0;
  
  for (let i = 0; i < screenHeight; i++) {
    screenBuffer[i] = [];
    styleBuffer[i] = [];
    for (let j = 0; j < screenWidth; j++) {
      screenBuffer[i][j] = ' ';
      styleBuffer[i][j] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: currentStyle.bold,
        inverse: currentStyle.inverse
      };
    }
  }
}


window.ANSI=ANSI;
print("\nQandy Pocket\nComputer v1.j\n");
cursor(1); 

SFiles=1;
mySearch=location.search.substr(1).split("&")
for (i=0;i<mySearch.length;i++) {
 nameVal=mySearch[i].split("=");
 for (j in nameVal) { nameVal[j]=unescape(nameVal[j]); } 
 if (nameVal[0]=="run") {
  script=document.createElement('script');
  script.src=nameVal[1];
  document.head.appendChild(script);
  SFiles=0;
 }
}
if (SFiles) { showFiles(); }

</script></body></html>