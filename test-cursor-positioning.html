<!DOCTYPE html>
<html>
<head>
  <title>Cursor Positioning Test - Qandy</title>
  <style>
    body {
      background-color: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      padding: 20px;
    }
    #output {
      white-space: pre-wrap;
      border: 1px solid #0f0;
      padding: 10px;
      margin-top: 10px;
      min-height: 400px;
    }
    .info {
      color: #ff0;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h1>ANSI Cursor Positioning Test</h1>
  
  <div class="info">
    <p>This test verifies that cursor positioning codes work correctly.</p>
    <p>After loading piano.js, the note display should update in place without scrolling.</p>
  </div>
  
  <div id="output"></div>
  
  <script>
    // Minimal qandy environment for testing
    var output = document.getElementById('output');
    var run = "";
    var keyon = 1;
    
    // Screen buffer simulation
    var screenWidth = 64;
    var screenHeight = 30;
    var screenBuffer = [];
    var cursorX = 0;
    var cursorY = 0;
    
    // Initialize screen buffer
    for (let i = 0; i < screenHeight; i++) {
      screenBuffer[i] = [];
      for (let j = 0; j < screenWidth; j++) {
        screenBuffer[i][j] = ' ';
      }
    }
    
    function renderScreen() {
      let html = '';
      for (let i = 0; i < screenHeight; i++) {
        html += screenBuffer[i].join('') + '\n';
      }
      output.textContent = html;
    }
    
    function print(text) {
      // Simple ANSI parser for testing
      const ansiRegex = /(\x1b|\x1b|\u001b)\[([\d;]*)([A-Za-z])/g;
      let lastIndex = 0;
      let match;
      
      while ((match = ansiRegex.exec(text)) !== null) {
        // Print text before ANSI code
        const beforeText = text.substring(lastIndex, match.index);
        for (let i = 0; i < beforeText.length; i++) {
          if (beforeText[i] === '\n') {
            cursorX = 0;
            cursorY++;
          } else {
            if (cursorY < screenHeight && cursorX < screenWidth) {
              screenBuffer[cursorY][cursorX] = beforeText[i];
              cursorX++;
            }
          }
        }
        
        const params = match[2] ? match[2].split(';').filter(s => s !== '').map(Number) : [0];
        const command = match[3];
        
        if (command === 'H' || command === 'f') {
          // Cursor positioning (1-based, convert to 0-based)
          cursorY = Math.min(Math.max(0, (params[0] || 1) - 1), screenHeight - 1);
          cursorX = Math.min(Math.max(0, (params[1] || 1) - 1), screenWidth - 1);
        } else if (command === 'K') {
          // Clear line
          const mode = params[0] || 0;
          if (mode === 0) {
            // Clear from cursor to end
            for (let x = cursorX; x < screenWidth; x++) {
              screenBuffer[cursorY][x] = ' ';
            }
          }
        }
        
        lastIndex = match.index + match[0].length;
      }
      
      // Print remaining text
      const remainingText = text.substring(lastIndex);
      for (let i = 0; i < remainingText.length; i++) {
        if (remainingText[i] === '\n') {
          cursorX = 0;
          cursorY++;
        } else {
          if (cursorY < screenHeight && cursorX < screenWidth) {
            screenBuffer[cursorY][cursorX] = remainingText[i];
            cursorX++;
          }
        }
      }
      
      renderScreen();
    }
    
    function cls() {
      for (let i = 0; i < screenHeight; i++) {
        for (let j = 0; j < screenWidth; j++) {
          screenBuffer[i][j] = ' ';
        }
      }
      cursorX = 0;
      cursorY = 0;
      renderScreen();
    }
    
    // Test cursor positioning
    print("Testing cursor positioning...\n");
    print("This text is on line 1\n");
    print("This text is on line 2\n");
    print("\n");
    
    // Move cursor to line 10
    print("\x1b[10;1HThis should be on line 10");
    
    // Move cursor to line 15
    print("\x1b[15;1HThis should be on line 15");
    
    // Test overwriting
    setTimeout(function() {
      print("\x1b[15;1H\x1b[KThis line was cleared and rewritten");
      
      // Load sound.js after test
      setTimeout(function() {
        var script1 = document.createElement('script');
        script1.src = 'sound.js';
        document.head.appendChild(script1);
        
        script1.onload = function() {
          print("\x1b[20;1H✓ sound.js loaded");
          
          var script2 = document.createElement('script');
          script2.src = 'piano.js';
          script2.onload = function() {
            print("\x1b[21;1H✓ piano.js loaded - press keys to test!");
          };
          document.head.appendChild(script2);
        };
      }, 1000);
    }, 1000);
    
    // Handle keyboard input
    document.addEventListener('keydown', function(event) {
      var key = event.key.toLowerCase();
      if (run && typeof keydown !== 'undefined') {
        if ('asdfghjkwetyu'.indexOf(key) !== -1) {
          event.preventDefault();
          keydown(key);
        }
      }
    });
  </script>
</body>
</html>
