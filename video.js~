//
//
// Qandy Video Graphics Adaptor
// 

let lastx=0; let lasty=0;

window.pokeCursor = function(t) {
  if (typeof t === 'undefined' || t === null) return false;
  // Cancel any existing paced output and start fresh
  if (window._pokeCursor_state && window._pokeCursor_state.timer) {
    clearTimeout(window._pokeCursor_state.timer);
  } 
  window._pokeCursor_state = null;

  var str = String(t);

  // parse numeric params into array of numbers (empty => [])
  function parseParams(paramStr) {
    if (!paramStr || paramStr.length === 0) return [];
    return paramStr.split(';').map(function(p){ var v = parseInt(p,10); return isNaN(v) ? 0 : v; });
  }

  // handle CSI sequences: paramsStr (string), cmd (final byte)
  function handleCSI(paramsStr, cmd) {
    var params = parseParams(paramsStr);
    switch (cmd) {
      case 'm': // SGR - set graphics rendition (colors/attributes)
        if (!params.length) params = [0];
        for (var pi = 0; pi < params.length; pi++) {
          var p = params[pi] | 0;
          switch (p) {
            case 0: // reset
              CURFG = 37; CURBG = 40; CURATTR = 0; break;
            case 1: // bold
              CURATTR = (CURATTR | (window.ATTR_BOLD || 0x0002)); break;
            case 2: // dim
              CURATTR = (CURATTR | (window.ATTR_DIM || 0x0004)); break;
            case 3: // italic
              CURATTR = (CURATTR | (window.ATTR_ITALIC || 0x0008)); break;
            case 4: // underline
              CURATTR = (CURATTR | (window.ATTR_UNDERLINE || 0x0010)); break;
            case 22: // normal intensity (clear bold & dim)
              CURATTR &= ~(window.ATTR_BOLD || 0x0002);
              CURATTR &= ~(window.ATTR_DIM  || 0x0004); break;
            case 23: // clear italic
              CURATTR &= ~(window.ATTR_ITALIC || 0x0008); break;
            case 24: // clear underline
              CURATTR &= ~(window.ATTR_UNDERLINE || 0x0010); break;
            case 7: // inverse
              CURATTR = (CURATTR | (window.ATTR_INVERSE || 0x0001)); break;
            case 27: // clear inverse
              CURATTR &= ~(window.ATTR_INVERSE || 0x0001); break;
            default:
              if (p >= 30 && p <= 37) { CURFG = p; break; }
              if (p >= 90 && p <= 97) { CURFG = p; break; }
              if (p >= 40 && p <= 47) { CURBG = p; break; }
              if (p >= 100 && p <= 107) { CURBG = p; break; }
              // Note: extended colors (38;5;.., 38;2;.. ) not implemented here
              break;
          }
        }
        break;

      case 'H': // Cursor position (row;col) — 1-based
      case 'f':
        var row = (params.length >= 1 && params[0] > 0) ? (params[0] - 1) : 0;
        var col = (params.length >= 2 && params[1] > 0) ? (params[1] - 1) : 0;
        if (typeof row === 'number') CURY = Math.max(0, Math.min(H - 1, row));
        if (typeof col === 'number') CURX = Math.max(0, Math.min(W - 1, col));
        break;
      case 'A': // Cursor up
        var nA = (params.length >= 1 && params[0] > 0) ? params[0] : 1;
        CURY = Math.max(0, CURY - nA);
        break;
      case 'B': // Cursor down
        var nB = (params.length >= 1 && params[0] > 0) ? params[0] : 1;
        CURY = Math.min(H - 1, CURY + nB);
        break;
      case 'C': // Cursor forward
        var nC = (params.length >= 1 && params[0] > 0) ? params[0] : 1;
        CURX = Math.min(W - 1, CURX + nC);
        break;
      case 'D': // Cursor backward
        var nD = (params.length >= 1 && params[0] > 0) ? params[0] : 1;
        CURX = Math.max(0, CURX - nD);
        break;
      case 'J': // Erase in Display
        if (params.length === 0 || params[0] === 0) {
          // not implemented (cursor to end)
        } else if (params[0] === 1) {
          // not implemented (start to cursor)
        } else if (params[0] === 2) {
          // clear entire screen
          try {
            if (typeof cls === 'function') cls();
            else {
              for (var ry = 0; ry < H; ry++) {
                for (var rx = 0; rx < W; rx++) {
                  VIDEO[ry][rx] = ' ';
                  FCOLOR[ry][rx]= CURFG;
                  BCOLOR[ry][rx]= CURBG;
                  ATTR[ry][rx] = 0;
                }
              }
              if (typeof pokeRefresh === 'function') pokeRefresh();
            }
          } catch (e) { /* ignore */ }
        }
        break;
      default:
        // unsupported CSI — ignore
        break;
    }
  }

  // compute per-character delay in ms based on CURBAUD (10 bits/char)
  var delayMs = 0;
  if (typeof CURBAUD === 'number' && CURBAUD > 0) {
    delayMs = Math.max(0, Math.round(10000 / CURBAUD)); // ms between characters
  }

  // If delay is 0, run synchronously (old behavior)
  if (!delayMs) {
    
  }

  // paced/asynchronous processing
  var state = {
    str: str,
    idx: 0,
    timer: null,
    stopped: false
  };
  window._pokeCursor_state = state;

  function scheduleNext() {
    if (!state || state.stopped) return;
    state.timer = setTimeout(processStep, delayMs);
  }

  function processStep() {
    if (!state || state.stopped) return;

    // end condition
    if (state.idx >= state.str.length) {
      window._pokeCursor_state = null;
      return;
    }

    var ch = state.str.charAt(state.idx);

    // handle CSI atomically (no intra-sequence delay)
    if (CURANSI && ch === '\x1b') {
      var rest = state.str.slice(state.idx);
      var m = /^\x1b\[([0-9;]*)?([@A-Za-z])/.exec(rest);
      if (m) {
        handleCSI(m[1] || '', m[2]);
        state.idx += m[0].length;
        // schedule next after same delay
        scheduleNext();
        return;
      } else {
        // unknown escape — skip it
        state.idx++;
        scheduleNext();
        return;
      }
    }

    // printable char processing (counts toward baud)
    pokeCursorOff();

    if (ch === '\n') {
      CURX = 0;
      CURY = CURY + 1;
      if (CURY >= H) { pokeScroll(4); CURY = H - 1; CURX = Math.min(CURX, W - 1); }
      LINEX = CURX; LINEY = CURY;
      state.idx++;
      scheduleNext();
      pokeCursorOn();
      return;
    }

    if (CURX >= W) {
      CURX = 0; CURY = CURY + 1;
      if (CURY >= H) {
        pokeScroll(4); CURY = H - 1; CURX = Math.min(CURX, W - 1);
        pokeCursorOn();
        window._pokeCursor_state = null;
        pokeCursorOn();
        return;
      }
    }

    pokeCell(CURX, CURY, ch, 33, 44, CURATTR);
    if (SOUND) { beep(900, 25, .01); }

    CURX = CURX + 1;
    if (CURX >= W) {
      CURX = 0; CURY = CURY + 1;
      if (CURY >= H) {
        pokeScroll(4);
        CURY = H - 1; CURX = Math.min(CURX, W - 1);
        LINEX = CURX; LINEY = CURY;
        pokeCursorOn();
        window._pokeCursor_state = null;
        return;
      }
    }

    pokeCursorOn();
    LINEX = CURX; LINEY = CURY;

    state.idx++;
    scheduleNext();
  }

  // start paced output
  scheduleNext();
  return true;
};

window._pokeCursor_state = window._pokeCursor_state || null;

var FALLBACK_FG = {
  black:30, red:31, green:32, yellow:33, blue:34, magenta:35, cyan:36, white:37,
  bright_black:90, bright_red:91, bright_green:92, bright_yellow:93, bright_blue:94, bright_magenta:95, bright_cyan:96, bright_white:97
};
	var FALLBACK_BG = {
  black:40, red:41, green:42, yellow:43, blue:44, magenta:45, cyan:46, white:47,
  bright_black:100, bright_red:101, bright_green:102, bright_yellow:103, bright_blue:104, bright_magenta:105, bright_cyan:106, bright_white:107
};
function _lookupFg(name) {
  if (!name) return undefined;
  var key = String(name).toLowerCase();
  if (window && window.ANSI_NAME_TO_FG && typeof window.ANSI_NAME_TO_FG[key] !== 'undefined') return window.ANSI_NAME_TO_FG[key];
  if (FALLBACK_FG[key]) return FALLBACK_FG[key];
  return undefined;
}
function _lookupBg(name) {
  if (!name) return undefined;
  var key = String(name).toLowerCase();
  if (window && window.ANSI_NAME_TO_BG && typeof window.ANSI_NAME_TO_BG[key] !== 'undefined') return window.ANSI_NAME_TO_BG[key];
  if (FALLBACK_BG[key]) return FALLBACK_BG[key];
  return undefined;
}
var ATTR_MAP = {
  reset: 0, default:0, 0:0,
  bold: 1, dim: 2, italic: 3, underline: 4, inverse: 7
};

// okay to delete these lines??
//window.ansi = window.ansi || {};
//window.ansi.fg = function(name) { var c = _lookupFg(name); return (typeof c !== 'undefined') ? '\x1b['+c+'m' : ''; };
//window.ansi.bg = function(name) { var c = _lookupBg(name); return (typeof c !== 'undefined') ? '\x1b['+c+'m' : ''; };
//window.ansi.attr = function(name) { var a = ATTR_MAP[name] || ( /^\d+$/.test(String(name)) ? parseInt(name,10): undefined ); return (typeof a !== 'undefined') ? '\x1b['+a+'m' : ''; };

window.pokeText = function(x, y, t, n) {
  if (typeof x !== 'number' || typeof y !== 'number') return false;
  if (typeof t === 'undefined' || t === null) return false;
  n = (typeof n === 'undefined' || n === null) ? 1 : parseInt(n, 10);
  if (isNaN(n) || n < 1) n = 1;
  var str = String(t);
  var cx = x, cy = y;
  for (var repeat = 0; repeat < n; repeat++) {
    for (var i = 0; i < str.length; i++) {
      var c = str[i];
      if (c === '\n') {
        cx = 0;
        cy++;
        if (typeof H === 'number' && cy >= H) { // reached bottom of screen
          try { if (typeof pokeRefresh === 'function') pokeRefresh(); } catch(e) {}
          return false;
        }
        continue;
      }
      if (typeof W === 'number' && cx >= W) {
        cx = 0;
        cy++;
        if (typeof H === 'number' && cy >= H) {
          try { if (typeof pokeRefresh === 'function') pokeRefresh(); } catch(e) {}
          return false;
        }
      }
      pokeCell(cx, cy, c);
      cx++;
    }
  }
  if (SYNC) { pokeRefresh(); } 
  return true;
};

window.pokeCell = function(x,y,a,f,b,h) {
  if (typeof a === 'undefined') { a=" "; } 
  if (!validateCoords(x, y)) return false;
  VIDEO[y][x] = (a === null) ? ' ' : (typeof a === 'string' ? (a.length ? a.charAt(0) : ' ') : String(a).charAt(0));

  var fgCode;
  if (typeof f === 'number') {
    fgCode = f | 0;
  } else if (typeof f === 'string' && f.length) {
    var name = f.toLowerCase();
    fgCode = (window.ANSI_NAME_TO_FG && typeof window.ANSI_NAME_TO_FG[name] !== 'undefined')
      ? (window.ANSI_NAME_TO_FG[name] | 0)
      : CURFG;
  } else {
    // fallback: try existing FCOLOR bank for this cell, otherwise default
    fgCode = CURFG;
  }

  var bgCode;
  if (typeof b === 'number') {
    bgCode = b | 0;
  } else if (typeof b === 'string' && b.length) {
    var name = b.toLowerCase();
    bgCode = (window.ANSI_NAME_TO_BG && typeof window.ANSI_NAME_TO_BG[name] !== 'undefined')
      ? (window.ANSI_NAME_TO_BG[name] | 0)
      : CURBG;
  } else {
    // fallback: try existing FCOLOR bank for this cell, otherwise default
    bgCode = CURBG;
  }
  
  FCOLOR[y][x]=fgCode;
  BCOLOR[y][x]=bgCode; 

  if (typeof h !== 'undefined' && h !== null) {
    try { ATTR[y][x] = (h | 0); } catch (e) { ATTR[y][x] = h; }
  }

  if (SYNC) { pokeRefresh(x, y); }
  return true;
};

window.pokeColor = function(x, y, f, b, n) {
  if (!validateCoords(x, y)) return false;  
  if (typeof f === 'undefined') { f=CURFG; }
  if (typeof b === 'undefined') { b=CURBG; }
  n = (typeof n === 'number' && n > 0) ? Math.floor(n) : 1;
  if (typeof n === 'number' && n > 0) {
    var endX = Math.min(x + n, W);
    for (var i = x; i < endX; i++) {
      FCOLOR[y][i]=CURFG;
      BCOLOR[y][i]=CURBG;
      if (SYNC) { pokeRefresh(i, y); }
    }
    return endX - x;
  }
  return false;
};

// there should be a poke function that already does this??
window.eraseInput = function(text) {
}

window.peek = function(x, y) { 
  return validateCoords(x, y) ? VIDEO[y][x] : undefined;
};

window.pokeInput = function() {
  if (typeof lastin === 'undefined') { lastin="";  }
  if (lastin != "") {
    var str = String(lastin); var curx = LINEX; var cury = LINEY;
    for (var i = 0; i < str.length; i++) {
      var char = str[i];
      if (char === '\n') { 
        curx = 0; cury++; if (cury >= H) { return false; } continue;
        if (curx >= W) {
    	    curx = 0; cury++; if (cury >= H) { return false; }
        }
      }
      pokeCell(curx, cury, " "); curx++;
    }
  }
  var curx = LINEX; var cury = LINEY;
  for (var i = 0; i < LINE.length; i++) {
    var char = LINE[i];
    if (char === '\n') { 
     curx = 0; cury++; 
     if (cury >= H) { return false; }
     continue;
    }
    if (curx >= W) { 
     curx = 0; cury++; 
     if (cury >= H) { return false; }
    }
    pokeCell(curx, cury, char); curx++;
    if (SYNC) { pokeRefresh(curx, cury); }
  }
  var str = (typeof LINE === 'string') ? LINE : String(LINE || "");
  var targetP = (typeof CURP === 'number') ? CURP : str.length;
  if (targetP < 0) targetP = 0;
  if (targetP > str.length) targetP = str.length;
  var newX, newY;
  var absCol = (typeof LINEX === 'number' ? LINEX : 0) + targetP;
  newY = (typeof LINEY === 'number' ? LINEY : 0) + Math.floor(absCol / W);
  newX = absCol % W;
  if (newY < 0) newY = 0;
  if (newY >= H) newY = H - 1;
  if (newX < 0) newX = 0;
  if (newX >= W) newX = W - 1;
  CURX = newX;
  CURY = newY;
  
  lastin = str;
  return true;
};

window.pokeChar = function(x, y, a, n) {
  if (typeof a === 'undefined') { return false; }
  if (!validateCoords(x, y)) return false;
  var ch = (typeof a === 'string') ? a : String(a)[0] || ' ';
  n = (typeof n === 'number' && !isNaN(n) && n > 0) ? (n|0) : 1;
  var remaining = n;
  var cx = x|0;
  var cy = y|0;
  var written = 0;
  while (remaining > 0 && cy < H) {
    var space = W - cx;
    if (space <= 0) { cx = 0; cy++; continue; }
    var take = Math.min(remaining, space);
    var row = VIDEO[cy] || (VIDEO[cy] = new Array(W).fill(' '));
    for (var i = 0; i < take; i++) { row[cx + i] = ch; }
    pokeRefresh(cx, cy, take);
    written += take;
    remaining -= take;
    cx = 0;
    cy++;
  }
  return (n === 1) ? true : written;
};

window.peekChar = function(x, y) { 
  return validateCoords(x, y) ? VIDEO[y][x] : undefined;
};


const ANSI = {
  colors: { 30: 'black', 31: 'red', 32: 'green', 33: 'yellow', 34: 'blue', 35: 'magenta', 36: 'cyan', 37: 'white', 90: 'black', 91: 'red', 92: 'green', 93: 'yellow', 94: 'blue', 95: 'magenta', 96: 'cyan', 97: 'white' },
  bgColors: { 40: 'black', 41: 'red', 42: 'green', 43: 'yellow', 44: 'blue', 45: 'magenta', 46: 'cyan', 47: 'white', 100: 'black', 101: 'red', 102: 'green', 103: 'yellow', 104: 'blue', 105: 'magenta', 106: 'cyan', 107: 'white' },
  render: function(text) {
    let html = ''; let currentColor = 'white'; let currentBgColor = 'black'; let bold = false; let inverse = false; let cX = 0; let cY = 0;
    const ansiRegex = /\x1b\[([\d;]*)([A-Za-z])/g; let lastIndex = 0; let match;
    while ((match = ansiRegex.exec(text)) !== null) {
      html += this.escapeHtml(text.substring(lastIndex, match.index));
      const params = match[1] ? match[1].split(';').map(Number) : [0];
      const command = match[2];
      if (command === 'm') {
        params.forEach(param => {
          if (param === 0) {
            currentColor = 'white';
            currentBgColor = 'black';
            bold = false;
            inverse = false;
          } else if (param === 1) {
            bold = true;
          } else if (param === 7) {
            inverse = true;
          } else if (param === 27) {
            inverse = false;
          } else if (param >= 30 && param <= 37) {
            currentColor = this.colors[param];
          } else if (param >= 40 && param <= 47) {
            currentBgColor = this.bgColors[param];
          }
        });
      } else if (command === 'H' || command === 'f') {
        cY = params[0] || 0;
        cX = params[1] || 0;
      } else if (command === 'A') {
        cY = Math.max(0, cY - (params[0] || 1));
      } else if (command === 'B') {
        cY += (params[0] || 1);
      } else if (command === 'C') {
        cX += (params[0] || 1);
      } else if (command === 'D') {
        cX = Math.max(0, cX - (params[0] || 1));
      } else if (command === 'J') {
        if (params[0] === 2) {
          html = ''; // Clear screen 
        }
      } else if (command === 'K') {
      }
      lastIndex = match.index + match[0].length;
    }
    html += this.escapeHtml(text.substring(lastIndex));
    let classes = [];
    if (bold) classes.push('ansi-bold');
    if (inverse) classes.push('ansi-inverse');
    classes.push(`ansi-${currentColor}`);
    classes.push(`ansi-bg-${currentBgColor}`);
    if (classes.length > 0) { html = `<span class="${classes.join(' ')}">${html}</span>`; }
    return html;
  },

  escapeHtml: function(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
  },

  codes: {
    reset: '\x1b[0m',
    bold: '\x1b[1m',
    inverse: '\x1b[7m',
    black: '\x1b[30m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m',
    bgBlack: '\x1b[40m',
    bgRed: '\x1b[41m',
    bgGreen: '\x1b[42m',
    bgYellow: '\x1b[43m',
    bgBlue: '\x1b[44m',
    bgMagenta: '\x1b[45m',
    bgCyan: '\x1b[46m',
    bgWhite: '\x1b[47m',
    cursorHome: '\x1b[H',
    cursorPos: (row, col) => `\x1b[${row};${col}H`,
    cursorUp: (n = 1) => `\x1b[${n}A`,
    cursorDown: (n = 1) => `\x1b[${n}B`,
    cursorForward: (n = 1) => `\x1b[${n}C`,
    cursorBack: (n = 1) => `\x1b[${n}D`,
    clearScreen: '\x1b[2J',
    clearLine: '\x1b[K',
    pageBreak: '\f'  // Form Feed (ASCII 12, 0x0C) - explicit page break for pagination
  }
};

window.ANSI=ANSI;

window.COLOR = {
  // Foreground colors (30-37)
  BLACK: 30,
  RED: 31,
  GREEN: 32,
  YELLOW: 33,
  BLUE: 34,
  MAGENTA: 35,
  CYAN: 36,
  WHITE: 37,
  
  // Bright foreground colors (90-97)
  BRIGHT_BLACK: 90,
  BRIGHT_RED: 91,
  BRIGHT_GREEN: 92,
  BRIGHT_YELLOW: 93,
  BRIGHT_BLUE: 94,
  BRIGHT_MAGENTA: 95,
  BRIGHT_CYAN: 96,
  BRIGHT_WHITE: 97,
  
  // Background colors (40-47)
  BG_BLACK: 40,
  BG_RED: 41,
  BG_GREEN: 42,
  BG_YELLOW: 43,
  BG_BLUE: 44,
  BG_MAGENTA: 45,
  BG_CYAN: 46,
  BG_WHITE: 47,
  
  // Bright background colors (100-107)
  BG_BRIGHT_BLACK: 100,
  BG_BRIGHT_RED: 101,
  BG_BRIGHT_GREEN: 102,
  BG_BRIGHT_YELLOW: 103,
  BG_BRIGHT_BLUE: 104,
  BG_BRIGHT_MAGENTA: 105,
  BG_BRIGHT_CYAN: 106,
  BG_BRIGHT_WHITE: 107
};

// convert DOM to ATTR
function styleToAttr(style) {
  var a = 0;
  if (!style) return a;
  if (style.inverse)   a |= (window.ATTR_INVERSE || 0x0001);
  if (style.bold)      a |= (window.ATTR_BOLD    || 0x0002);
  if (style.dim)       a |= (window.ATTR_DIM     || 0x0004);
  if (style.italic)    a |= (window.ATTR_ITALIC  || 0x0008);
  if (style.underline) a |= (window.ATTR_UNDERLINE || 0x0010);
  if (style.blink)     a |= (window.ATTR_BLINK   || 0x0020);
  return a;
}

function _ensureAttrRow(y) { if (!window.ATTR) ATTR = []; if (!ATTR[y]) ATTR[y] = new Array(W).fill(0); }
function _ensureColorRow(y) { if (!window.COLOR) COLOR = COLOR || []; if (!COLOR[y]) COLOR[y] = new Array(W); }

var defaultColor = (window.currentStyle && typeof window.currentStyle.color !== 'undefined') ? window.currentStyle.color : 37;
var defaultBg    = (window.currentStyle && typeof window.currentStyle.bgcolor !== 'undefined') ? window.currentStyle.bgcolor : 40;

// init the DOM
for (var y = 0; y <= H; y++) { ATTR[y] = new Array(W); }
var txtEl = document.getElementById('txt');
txtEl.innerHTML = '';
var frag = document.createDocumentFragment();
for (var y = 0; y <= H; y++) {
  var rowChars = new Array(W);
  var rowStyles = new Array(W);
  var rowRefs   = new Array(W);
  var rowDiv = document.createElement('div');
  var frow = new Uint8Array(W); // foreground ANSI codes (30..97)
  var brow = new Uint8Array(W); // background ANSI codes (40..107)
  var rowDiv = document.createElement('div');
  rowDiv.className = 'qandy-row';
  for (var x = 0; x < window.W; x++) {
    rowChars[x] = ' ';
    rowStyles[x] = { color: defaultColor, bgcolor: defaultBg, bold: false, inverse: false };

    // populate numeric banks from the style object (initial sync)
    frow[x] = rowStyles[x].color | 0;
    brow[x] = rowStyles[x].bgcolor | 0;

    var cell = document.createElement('span');
    cell.id = 'c' + y + '_' + x;
    // set class names for default colors so CSS can style them immediately
    cell.className = 'qandy-cell ansi-fg-' + rowStyles[x].color + ' ansi-bg-' + rowStyles[x].bgcolor;
    cell.textContent = '\u00A0';
    // small snapshot to avoid costly classList scans in hot path
    cell._qandyStyle = { color: rowStyles[x].color, bgcolor: rowStyles[x].bgcolor, bold: false, inverse: false };
    rowDiv.appendChild(cell);
    rowRefs[x] = cell;
  }
  frag.appendChild(rowDiv);
  // i think these settings are a bug, the values might get
  // rewritten if a screen clear is issued so it's not being
  // detected. These should be set to numeric data, not css styles
  window.VIDEO[y] = rowChars;
  window.COLOR[y]  = rowStyles; // ## old color (compat)
  window.FCOLOR[y] = frow;      // new numeric foreground bank (Uint8Array)
  window.BCOLOR[y] = brow;      // new numeric background bank (Uint8Array)
  window.DOM[y]    = rowRefs;  frag.appendChild(rowDiv);
}
txtEl.appendChild(frag);

function buildClass(s) {
  var cls = 'qandy-cell ansi-fg-' + s.color + ' ansi-bg-' + s.bgcolor;
  if (s.bold) cls += ' ansi-bold';
  if (s.inverse) cls += ' ansi-inverse';
  return cls;
}

window.hasATTR = function(x, y, attrBit) { return !!(ATTR[y][x] & attrBit); };
window.peekATTR = function(x, y) { return ATTR[y][x]; };

// set/get foreground for a cell or horizontal span
window.pokeFG = function(x, y, fg, count) {
  // Getter: if fg is undefined, return current fg value or undefined if out-of-bounds
  if (typeof fg === 'undefined') {
    if (typeof validateCoords === 'function') {
      if (!validateCoords(x, y)) return undefined;
    } else {
      if (typeof x !== 'number' || typeof y !== 'number' || x < 0 || y < 0 || y >= H || x >= W) return undefined;
    }
    if (window.FCOLOR && FCOLOR[y] && typeof FCOLOR[y][x] !== 'undefined') return FCOLOR[y][x] | 0;
    if (window.COLOR && COLOR[y] && COLOR[y][x] && typeof COLOR[y][x].color !== 'undefined') return COLOR[y][x].color | 0;
    return (typeof window.defaultColor !== 'undefined') ? window.defaultColor : 37;
  }

  // Validate coords
  if (typeof validateCoords === 'function') {
    if (!validateCoords(x, y)) return false;
  } else {
    if (typeof x !== 'number' || typeof y !== 'number') return false;
    if (x < 0 || y < 0 || y >= H || x >= W) return false;
  }

  // normalize count default=1 and clamp to remaining cells on screen
  count = (typeof count === 'number' && count > 0) ? Math.floor(count) : 1;
  var maxRemaining = Math.max(0, W * H - (y * W + x));
  if (count > maxRemaining) count = maxRemaining;
  if (count <= 0) return false;

  // ensure banks exist
  if (!window.FCOLOR) FCOLOR = [];
  if (!FCOLOR[y]) FCOLOR[y] = new Uint8Array(W);

  // resolve numeric code from name or number
  var fgCode;
  if (typeof fg === 'number') {
    fgCode = fg | 0;
  } else if (typeof fg === 'string' && fg.length) {
    var name = fg.toLowerCase();
    fgCode = (window.ANSI_NAME_TO_FG && typeof window.ANSI_NAME_TO_FG[name] !== 'undefined')
      ? (window.ANSI_NAME_TO_FG[name] | 0)
      : ((typeof window.defaultColor !== 'undefined') ? window.defaultColor : 37);
  } else {
    fgCode = (typeof window.defaultColor !== 'undefined') ? window.defaultColor : 37;
  }

  // write span
  for (var i = 0; i < count; i++) {
    var cx = x + i;
    FCOLOR[y][cx] = fgCode;
    if (window.COLOR && COLOR[y] && COLOR[y][cx]) COLOR[y][cx].color = fgCode;
  }

  // refresh
  if (typeof pokeRefreshRow === 'function') {
    try { pokeRefreshRow(x, y, count); } catch (e) { for (var r = 0; r < count; r++) try { pokeRefresh(x + r, y); } catch(e){} }
  } else {
    for (var j = 0; j < count; j++) try { pokeRefresh(x + j, y); } catch(e){}
  }

  return count;
};

// set/get background for a cell or horizontal span
window.pokeBG = function(x, y, bg, count) {
  // Getter: if bg is undefined, return current bg value or undefined if out-of-bounds
  if (typeof bg === 'undefined') {
    if (typeof validateCoords === 'function') {
      if (!validateCoords(x, y)) return undefined;
    } else {
      if (typeof x !== 'number' || typeof y !== 'number' || x < 0 || y < 0 || y >= H || x >= W) return undefined;
    }
    if (window.BCOLOR && BCOLOR[y] && typeof BCOLOR[y][x] !== 'undefined') return BCOLOR[y][x] | 0;
    if (window.COLOR && COLOR[y] && COLOR[y][x] && typeof COLOR[y][x].bgcolor !== 'undefined') return COLOR[y][x].bgcolor | 0;
    return (typeof window.defaultBg !== 'undefined') ? window.defaultBg : 40;
  }

  // Validate coords
  if (typeof validateCoords === 'function') {
    if (!validateCoords(x, y)) return false;
  } else {
    if (typeof x !== 'number' || typeof y !== 'number') return false;
    if (x < 0 || y < 0 || y >= H || x >= W) return false;
  }

  // normalize count default=1 and clamp to remaining cells on screen
  count = (typeof count === 'number' && count > 0) ? Math.floor(count) : 1;
  var maxRemaining = Math.max(0, W * H - (y * W + x));
  if (count > maxRemaining) count = maxRemaining;
  if (count <= 0) return false;

  // ensure banks exist
  if (!window.BCOLOR) BCOLOR = [];
  if (!BCOLOR[y]) BCOLOR[y] = new Uint8Array(W);

  // resolve numeric code from name or number
  var bgCode;
  if (typeof bg === 'number') {
    bgCode = bg | 0;
  } else if (typeof bg === 'string' && bg.length) {
    var name = bg.toLowerCase();
    bgCode = (window.ANSI_NAME_TO_BG && typeof window.ANSI_NAME_TO_BG[name] !== 'undefined')
      ? (window.ANSI_NAME_TO_BG[name] | 0)
      : ((typeof window.defaultBg !== 'undefined') ? window.defaultBg : 40);
  } else {
    bgCode = (typeof window.defaultBg !== 'undefined') ? window.defaultBg : 40;
  }

  // write span
  for (var i = 0; i < count; i++) {
    var cx = x + i;
    BCOLOR[y][cx] = bgCode;
    if (window.COLOR && COLOR[y] && COLOR[y][cx]) COLOR[y][cx].bgcolor = bgCode;
  }

  // refresh
  if (typeof pokeRefreshRow === 'function') {
    try { pokeRefreshRow(x, y, count); } catch (e) { for (var r = 0; r < count; r++) try { pokeRefresh(x + r, y); } catch(e){} }
  } else {
    for (var j = 0; j < count; j++) try { pokeRefresh(x + j, y); } catch(e){}
  }

  return count;
};

window.pokeAttr = function(x, y, spec) {
  if (typeof x !== 'number' || typeof y !== 'number') return false;
  // optional validator function if present in repo
  if (typeof validateCoords === 'function' && !validateCoords(x, y)) return false;
  if (typeof spec === 'number') {
    ATTR[y][x] = spec | 0;
    if (typeof pokeRefresh === 'function') pokeRefresh(x, y);
    return true;
  }
  var maskFromObject = 0;
  if (typeof styleToAttr === 'function' && spec && typeof spec === 'object') {
    try {
      maskFromObject = styleToAttr(spec) | 0;
    } catch (e) {
      maskFromObject = 0;
    }
  }
  // current numeric attr value
  var cur = (typeof ATTR[y][x] !== 'undefined') ? ATTR[y][x] | 0 : 0;
  var clr = (typeof COLOR[y][x] !== 'undefined' && COLOR[y][x]) ? Object.assign({}, COLOR[y][x]) : { color: (window.defaultColor||37), bgcolor: (window.defaultBg||40), bold:false, inverse:false, blink:false, dim:false, italic:false, underline:false, hidden:false, strike:false };
  if (spec && typeof spec === 'object') {
    // If styleToAttr gave a full mask and you intend to overwrite, you can uncomment:
    // cur = (maskFromObject !== 0) ? maskFromObject : cur;
    if (spec.hasOwnProperty('inverse')) { cur = spec.inverse ? (cur | ATTR_INVERSE) : (cur & ~ATTR_INVERSE); clr.inverse = !!spec.inverse; }
    if (spec.hasOwnProperty('bold')) { cur = spec.bold ? (cur | ATTR_BOLD) : (cur & ~ATTR_BOLD); clr.bold = !!spec.bold; }
    if (spec.hasOwnProperty('dim')) { cur = spec.dim ? (cur | ATTR_DIM) : (cur & ~ATTR_DIM); clr.dim = !!spec.dim; }
    if (spec.hasOwnProperty('italic')) { cur = spec.italic ? (cur | ATTR_ITALIC) : (cur & ~ATTR_ITALIC); clr.italic = !!spec.italic; }
    if (spec.hasOwnProperty('underline')) { cur = spec.underline ? (cur | ATTR_UNDERLINE) : (cur & ~ATTR_UNDERLINE); clr.underline = !!spec.underline; }
    if (spec.hasOwnProperty('blink')) { cur = spec.blink ? (cur | ATTR_BLINK) : (cur & ~ATTR_BLINK); clr.blink = !!spec.blink; }
    if (spec.hasOwnProperty('hidden')) { cur = spec.hidden ? (cur | ATTR_HIDDEN) : (cur & ~ATTR_HIDDEN); clr.hidden = !!spec.hidden; }
    if (spec.hasOwnProperty('strike')) { cur = spec.strike ? (cur | ATTR_STRIKE) : (cur & ~ATTR_STRIKE); clr.strike = !!spec.strike; }
    if (spec.hasOwnProperty('overline')) { cur = spec.overline ? (cur | ATTR_OVERLINE) : (cur & ~ATTR_OVERLINE);
      // no color property for overline in COLOR, it's purely visual
    }
    // update color fields only when specified
    if (spec.hasOwnProperty('color'))   clr.color = spec.color;
    if (spec.hasOwnProperty('bgcolor')) clr.bgcolor = spec.bgcolor;
    // also keep COLOR.bold/inverse/blink in sync with ATTR booleans
    clr.bold = !!clr.bold;
    clr.inverse = !!clr.inverse;
    clr.blink = !!clr.blink;
    // apply merged values
    ATTR[y][x] = cur;
    COLOR[y][x] = clr;
    if (typeof pokeRefresh === 'function') pokeRefresh(x, y);
    return true;
  }
  return false;
};

window.pokeAttrBit = function(x, y, bit, state) {
  var ok = pokeAttrBit(x, y, bit, !!state);
  if (!ok) return false;
  if (typeof pokeRefresh === 'function') pokeRefresh(x,y);
  return true;
};

window.pokeAttrBit = function(x, y, bit, state) {
  if (typeof x !== 'number' || typeof y !== 'number') return false;
  if (typeof validateCoords === 'function' && !validateCoords(x, y)) return false;

  // Set or clear the bit
  if (state) ATTR[y][x] |= bit;
  else       ATTR[y][x] &= ~bit;

  if (SYNC) { pokeRefresh(x, y); }
  return true;
};

window.pokeInverse = function(x, y, state, n) {
  if (typeof x !== 'number' || typeof y !== 'number') return false;
  if (typeof n === 'number' && n > 1) {
    var endX = x + n;
    for (var xi = x; xi < endX; xi++) {
    	pokeAttrBit(xi, y, window.ATTR_INVERSE, !!state);
    }
    return n;
  }
  pokeAttrBit(x, y, window.ATTR_INVERSE, !!state);
  pokeRefresh(x,y);
  return true;
};

window.pokeRefresh = function(x, y, n) {
  if (typeof x === 'undefined' && typeof y === 'undefined') { x=0; y=0; n=W*H; }
  if (typeof validateCoords === 'function') {
    if (!validateCoords(x, y)) return false;
  } else {
    if (typeof x !== 'number' || typeof y !== 'number') return false;
    if (x < 0 || x >= W || y < 0 || y >= H) return false;
  }
  n = (typeof n === 'number' && n > 0) ? Math.floor(n) : 1;
  var m = Math.max(0, W * H - (y * W + x));
  if (n > m) n = m;
  if (n < 1) return false;  
  var remaining = n; var cx = x | 0; var cy = y | 0;
  while (remaining > 0 && cy < H) {
    var avail = Math.min(remaining, W - cx);
    // Per-cell refresh
    for (var rx = cx; rx < cx + avail; rx++) {
      var el = DOM[cy] && DOM[cy][rx];
      if (!el) continue;
      var ch = (VIDEO[cy] && typeof VIDEO[cy][rx] !== 'undefined') ? VIDEO[cy][rx] : ' ';
      var newText = (ch === ' ' || ch === '\u00A0') ? '\u00A0' : ch;
      if (el.textContent !== newText) el.textContent = newText;

      fg = FCOLOR[cy][rx] | 0; 
      bg = BCOLOR[cy][rx] | 0;

      var s2 = getCellStyle(rx, cy);
      var classStr2 = 'qandy-cell ansi-fg-' + s2.color + ' ansi-bg-' + s2.bgcolor;
      if (s2.bold) classStr2 += ' ansi-bold';
      if (s2.inverse) classStr2 += ' ansi-inverse';
      if (s2.italic) classStr2 += ' ansi-italic';
      if (s2.underline) classStr2 += ' ansi-underline';
      if (s2.dim) classStr2 += ' ansi-dim';
      if (s2.blink) classStr2 += ' ansi-blink';
      if (el._lastClass !== classStr2) {
        el.className = classStr2;
        el._lastClass = classStr2;
      }
    }
    remaining -= avail;
    cx = 0; 
    cy++;
  }
  return true;
};

window.pokeSelect = function(state) {
  if (typeof SSTART !== 'number' || typeof SEND !== 'number') return false;
  if (SSTART < 0 || SEND < 0) return false;
  var s = Math.min(SSTART, SEND);
  var e = Math.max(SSTART, SEND);
  var count = e - s;
  if (count <= 0) return false;
  var absCol = (typeof LINEX === 'number' ? LINEX : 0) + s;
  var startY = (typeof LINEY === 'number' ? LINEY : 0) + Math.floor(absCol / W);
  var startX = absCol % W;
  // pokeInverse expects (x, y, state, count)
  return pokeInverse(startX, startY, !!state, count);
}
  
window.peekAttr = function(x,y) { return (ATTR && ATTR[y]) ? ATTR[y][x] : undefined; };

window.peekInverse = function(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') return undefined;
  if (!validateCoords(x, y)) return undefined;
  if (window.ATTR && ATTR[y] && typeof ATTR[y][x] !== 'undefined') {
    return !!(ATTR[y][x] & (window.ATTR_INVERSE || 0x0001));
  }
  return undefined;
};

// getCellStyle(x,y) - prefer numeric banks (FCOLOR/BCOLOR), fallback to COLOR objects and ATTR bits
window.getCellStyle = function(x, y) {
  var defaultFG = (typeof window.defaultColor !== 'undefined') ? window.defaultColor : 37;
  var defaultBG = (typeof window.defaultBg !== 'undefined') ? window.defaultBg : 40;

  // validate coords: return safe defaults if out-of-range
  if (typeof x !== 'number' || typeof y !== 'number' || x < 0 || y < 0 || y >= H || x >= W) {
    return { color: defaultFG, bgcolor: defaultBG, bold:false, inverse:false, italic:false, underline:false, dim:false, blink:false };
  }

  // read numeric banks first (preferred)
  var fg = defaultFG;
  var bg = defaultBG;

  if (window.FCOLOR && FCOLOR[y] && typeof FCOLOR[y][x] !== 'undefined') {
    fg = FCOLOR[y][x] | 0;
  } else if (window.COLOR && COLOR[y] && COLOR[y][x] && typeof COLOR[y][x].color !== 'undefined') {
    fg = COLOR[y][x].color | 0;
  }

  if (window.BCOLOR && BCOLOR[y] && typeof BCOLOR[y][x] !== 'undefined') {
    bg = BCOLOR[y][x] | 0;
  } else if (window.COLOR && COLOR[y] && COLOR[y][x] && typeof COLOR[y][x].bgcolor !== 'undefined') {
    bg = COLOR[y][x].bgcolor | 0;
  }

  // read ATTR bitmask (if present)
  var attr = 0;
  if (window.ATTR && ATTR[y] && typeof ATTR[y][x] !== 'undefined') {
    attr = ATTR[y][x] | 0;
  }

  var s = {
    color: fg,
    bgcolor: bg,
    bold:     !!(attr & (window.ATTR_BOLD      || 0x0002)),
    dim:      !!(attr & (window.ATTR_DIM       || 0x0004)),
    italic:   !!(attr & (window.ATTR_ITALIC    || 0x0008)),
    underline:!!(attr & (window.ATTR_UNDERLINE || 0x0010)),
    blink:    !!(attr & (window.ATTR_BLINK     || 0x0020)),
    inverse:  !!(attr & (window.ATTR_INVERSE   || 0x0001)),
    hidden:   !!(attr & (window.ATTR_HIDDEN    || 0x0080))
  };

  // Visual inverse: swap fg/bg for rendering only (do not modify banks)
  if (s.inverse) {
    var t = s.color; s.color = s.bgcolor; s.bgcolor = t;
  }

  return s;
};

function validateCoords(x, y) { return (typeof x === 'number' && typeof y === 'number' && x >= 0 && y >= 0 && x < W && y < H); }
function safeGet(arr, y, x) { return (arr && arr[y]) ? arr[y][x] : undefined; }

var prevX = -1;
var prevY = -1;
var prevCode = CURSOR;

var prevAttr=0;

var _ansiCssMap = {30:'#000',31:'#c00',32:'#0c0',33:'#cc0',34:'#00c',35:'#c0c',36:'#0cc',37:'#ccc',
                   90:'#555',91:'#f55',92:'#5f5',93:'#ff5',94:'#55f',95:'#f5f',96:'#5ff',97:'#fff',
                   40:'#000',41:'#c00',42:'#0c0',43:'#cc0',44:'#00c',45:'#c0c',46:'#0cc',47:'#ccc'};

window.pokeCursorOn = function() {
  if (typeof CURSOR === 'undefined' || typeof CURX === 'undefined' || typeof CURY === 'undefined') return;
  if (CURSOR === 0) return; // cursor off
  var sx = Math.max(0, Math.min(W-1, CURX|0));
  var sy = Math.max(0, Math.min(H-1, CURY|0));
  var prevAttr = (typeof peekATTR === 'function') ? peekATTR(sx, sy) : (ATTR && ATTR[sy] ? ATTR[sy][sx] : 0);  
  if (CURSOR === 1 || CURSOR === 3) { // line cursor: underline
    if (typeof window.ATTR_UNDERLINE !== 'undefined') pokeAttrBit(sx, sy, window.ATTR_UNDERLINE, true);
    if (CURSOR === 3 && typeof window.ATTR_BLINK !== 'undefined') pokeAttrBit(sx, sy, window.ATTR_BLINK, true);
  }
  if (CURSOR === 4 || CURSOR === 5) { // block cursor: inverse
    if (typeof window.ATTR_INVERSE !== 'undefined') pokeAttrBit(sx, sy, window.ATTR_INVERSE, true);
    if (CURSOR === 5 && typeof window.ATTR_BLINK !== 'undefined') pokeAttrBit(sx, sy, window.ATTR_BLINK, true);
  }
}

window.pokeCursorOff = function() {
  if (typeof prevAttr === 'undefined' || prevAttr === null) return false;
  ATTR[CURY][CURX] = prevAttr;
  pokeRefresh(CURX,CURY);
  prevAttr="";
  return true;
}

function cursorVarsToAttr(vars) {
  // prefer window-defined ATTR_* constants if present, otherwise use defaults
  const ATTR_INVERSE   = (window.ATTR_INVERSE   !== undefined) ? window.ATTR_INVERSE   : 0x0001;
  const ATTR_BOLD      = (window.ATTR_BOLD      !== undefined) ? window.ATTR_BOLD      : 0x0002;
  const ATTR_ITALIC    = (window.ATTR_ITALIC    !== undefined) ? window.ATTR_ITALIC    : 0x0008;
  const ATTR_UNDERLINE = (window.ATTR_UNDERLINE !== undefined) ? window.ATTR_UNDERLINE : 0x0010; // "line"
  const ATTR_BLINK     = (window.ATTR_BLINK     !== undefined) ? window.ATTR_BLINK     : 0x0020;
  const ATTR_DIM       = (window.ATTR_DIM       !== undefined) ? window.ATTR_DIM       : 0x0040;

  // vars may be an object with the fields, otherwise fall back to globals
  const v = (vars && typeof vars === 'object') ? vars : {};

  const inverse = (typeof v.cursorInverse !== 'undefined') ? v.cursorInverse : (typeof cursorInverse !== 'undefined' ? cursorInverse : 0);
  const bold    = (typeof v.cursorBold    !== 'undefined') ? v.cursorBold    : (typeof cursorBold    !== 'undefined' ? cursorBold    : 0);
  const dim     = (typeof v.cursorDim     !== 'undefined') ? v.cursorDim     : (typeof cursorDim     !== 'undefined' ? cursorDim     : 0);
  const italic  = (typeof v.cursorItalic  !== 'undefined') ? v.cursorItalic  : (typeof cursorItalic  !== 'undefined' ? cursorItalic  : 0);
  const line    = (typeof v.cursorLine    !== 'undefined') ? v.cursorLine    : (typeof cursorLine    !== 'undefined' ? cursorLine    : 0);
  const blink   = (typeof v.cursorBlink   !== 'undefined') ? v.cursorBlink   : (typeof cursorBlink   !== 'undefined' ? cursorBlink   : 0);

  let mask = 0;
  if (inverse) mask |= ATTR_INVERSE;
  if (bold)    mask |= ATTR_BOLD;
  if (dim)     mask |= ATTR_DIM;
  if (italic)  mask |= ATTR_ITALIC;
  if (line)    mask |= ATTR_UNDERLINE;
  if (blink)   mask |= ATTR_BLINK;

  return mask;
}

window.pokeScroll = function(n) {
  pokeCursorOn(); if (typeof n === 'undefined') n = 0;
  n = Number(n) || 0;
  if (n === 0) return true;
  var distance = Math.max(-H, Math.min(H, n));
  var defAttr = 0;

  if (distance > 0) {
    // Scroll up: rows move toward smaller y (top), pulling from y+distance
    for (var y = 0; y < H; y++) {
      var src = y + distance;
      if (src < H) {
        for (var x = 0; x < W; x++) {
          // copy character
          VIDEO[y][x] = VIDEO[src][x];
          COLOR[y][x] = COLOR[src][x];
           ATTR[y][x] =  ATTR[src][x];
          if (SYNC) pokeRefresh(x, y);
        }
      } else {
        // fill remainder lines at bottom with spaces + default style
        for (var x2 = 0; x2 < W; x2++) {
          VIDEO[y][x2] = " ";
          //COLOR[y][x2] = @@@
          ATTR[y][x2] = CURATTR;
          if (SYNC) pokeRefresh(x2, y);
        }
      }
    }
  } else {
    // distance < 0 => scroll down by -distance
    var d = -distance;
    for (var y2 = H - 1; y2 >= 0; y2--) {
      var src2 = y2 - d;
      if (src2 >= 0) {
        for (var x3 = 0; x3 < W; x3++) {
          VIDEO[y2][x3] = VIDEO[src2][x3];

          var srcColor2 = (COLOR[src2] && COLOR[src2][x3]) ? COLOR[src2][x3] : null;
          var tgtColor2 = ensureColorObj(y2, x3);
          if (srcColor2) {
            tgtColor2.color = srcColor2.color;
            tgtColor2.bgcolor = srcColor2.bgcolor;
            tgtColor2.bold = !!srcColor2.bold;
            tgtColor2.inverse = !!srcColor2.inverse;
          } else {
            tgtColor2.color = (currentStyle && currentStyle.color) || 37;
            tgtColor2.bgcolor = (currentStyle && currentStyle.bgcolor) || 40;
            tgtColor2.bold = !!(currentStyle && currentStyle.bold);
            tgtColor2.inverse = !!(currentStyle && currentStyle.inverse);
          }

          ATTR[y2][x3] = (ATTR[src2] && typeof ATTR[src2][x3] !== 'undefined') ? ATTR[src2][x3] : defAttr;
          if (SYNC) pokeRefresh(x3, y2);
        }
      } else {
        // fill remainder lines at top with spaces + default style
        for (var x4 = 0; x4 < W; x4++) {
          VIDEO[y2][x4] = " ";
          var tgtCol3 = ensureColorObj(y2, x4);
          tgtCol3.color = (currentStyle && currentStyle.color) || 37;
          tgtCol3.bgcolor = (currentStyle && currentStyle.bgcolor) || 40;
          tgtCol3.bold = !!(currentStyle && currentStyle.bold);
          tgtCol3.inverse = !!(currentStyle && currentStyle.inverse);
          ATTR[y2][x4] = defAttr;
          if (SYNC) pokeRefresh(x4, y2);
        }
      }
    }
  }

  // Move cursor and input-line anchors by the same offset (subtract distance).
  // distance positive means screen moved up; cursor row should reduce by distance.
  function clampRow(r) {
    if (typeof r !== 'number' || isNaN(r)) return 0;
    if (r < 0) return 0;
    if (r >= H) return H - 1;
    return r;
  }

  CURY  = clampRow((typeof CURY === 'number' ? CURY : 0) - distance);
  LINEY = clampRow((typeof LINEY === 'number' ? LINEY : 0) - distance);
  CURX  = Math.max(0, Math.min(W - 1, (typeof CURX === 'number' ? CURX : 0)));
  LINEX = Math.max(0, Math.min(W - 1, (typeof LINEX === 'number' ? LINEX : 0)));
  pokeCursorOn(); 

  return true;
  
};


window.pokeScroll = function() {
  pokeCursorOff();
  pokeText(0,0," ",800);
  CURX=0; CURY=0; LINEX=0; LINEY=0;
  pokeCursorOn();  

}

// Signal that video.js is ready
if (typeof window.qandySignalReady === 'function') {
  window.qandySignalReady('Video');
}
