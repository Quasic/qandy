<!DOCTYPE html>
<html><head>
<script>
if (typeof window.print === 'function' && window.print.toString().indexOf('[native code]') !== -1) { window._native_print = window.print; window.print = function() {}; }
</script>
<link rel="stylesheet" type="text/css" href="qandy.css">
</head><body><p><br>
<div id=txt class="txt"></div>
<div id="pop" class="pop" onMouseOver='PopUpVis="visible";' onMouseOut='PopUpVis=PForce; PUV=setTimeout("document.getElementById(\"pop\").style.visibility=PopUpVis;",100);'></div>
<div id="keyboard-container"></div>

<script>
var devteam=1;  // developer mode

var run="";
var txt="";
var mode="txt"; // gfx or txt display
var allowScriptESC=false; // if true, script handles ESC instead of universal termination

// RAM - Working memory for file editing
var RAM="";           // Current file content in memory
var RAMFILE="";       // Current filename loaded in RAM
var RAMTYPE="";       // Current file type (js, txt, etc)

var keyon=1;
var caps=0;  // caps lock state: 0=lowercase, 1=uppercase, 2=extended graphics
var shift=0; // shift key pressed  
var ctrl=0;  // ctrl key pressed
var alt=0;   // alt key pressed
var ctrlPhysical=false;  // track if ctrl was activated by physical keyboard
var altPhysical=false;   // track if alt was activated by physical keyboard
var keyboard=1; // turn keyboard input on/off

var line=""; // input text line
// Track where input line started on screen (set when input begins / after ENTER)
var inputStartX = 0;
var inputStartY = 0;
var cursorPos=0; // cursor position in input line for editing
var inputScrollPos=0; // starting position of visible input window

// Command history support (like Linux terminal)
var commandHistory = [];  // Array to store command history
var historyIndex = -1;    // Current position in history (-1 = not browsing, typing new command)
var maxHistorySize = 50;  // Maximum number of commands to remember
var tempCommand = "";     // Temporary storage for command being typed when browsing history

// Text selection state
var selectionStart = -1;  // Start position of selection (-1 = no selection)
var selectionEnd = -1;    // End position of selection
var selectionBgColor = '#ffffff';   // Selection background color
var selectionFgColor = '#000000';   // Selection text color

var screenBuffer = [];
var cursorX = 0;
var cursorY = 0;
var cursorOn=0;
// var prevCursor = { set: false, x: 0, y: 0, inverse: false };

// Pagination support for overflow text
var paginationEnabled = true;  // Enable/disable pagination feature
var paginationPaused = false;  // Is print() currently paused?
var paginationBuffer = [];     // Queued text waiting to be printed
var paginationLinesBeforePause = 25;  // Lines to show before pausing
var inInputMode = false;       // True when processing user input (prevents pagination)

var styleBuffer = [];
var currentStyle = {
  color: 37,      // white foreground
  bgcolor: 40,    // black background
  bold: false,
  inverse: false
};

var PopX=0;
var PopY=0;
var PopHide="hidden";
var PopAlign="center";
var PForce="hidden";
var mapx=7;
var mapy=11;
var map="";

async function powerOn() {
  const startup = ['video.js', 'keyboard.js', 'dos.js'];
  for (const src of startup) {
    await new Promise(resolve => {
      const s = document.createElement('script');
      s.src = src;
      s.onload  = () => { console.log('Loaded', src); resolve(); };
      s.onerror = (e) => { console.error('Failed', src, e); resolve(); }; // continue despite failure
      document.head.appendChild(s);
    });
  }
  bootAfterScripts();
}

function bootAfterScripts() {
  initScreen();
}

// Start after DOM ready:
if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', powerOn);
else powerOn();

function button(b, event) {
  // Resume pagination if paused
  if (typeof paginationPaused !== 'undefined' && paginationPaused) {
    if (typeof resumePagination === 'function') resumePagination();
    return;
  }

  if (event && typeof event.shiftKey !== 'undefined') shift = !!event.shiftKey;
  cursor(0);
  var k = "", l = "";
  switch (b) {
    case 16: // SHIFT
      if (event && typeof event.shiftKey !== 'undefined') shift = !!event.shiftKey;
      else shift = !shift;
      if ((alt || altPhysical) && typeof updateKeyLabels === 'function') updateKeyLabels();
      cursor(1);
      return;
    case 17: k = "ctrl"; break;
    case 18: k = "alt"; break;
    case 20: k = "caps"; break;
    case 27: k = "esc"; break;
    case 13: k = "enter"; break;
    case 8:  k = "back"; break;
    case 46: k = "delete"; break;
    case 37: k = "left"; break;
    case 38: k = "up"; break;
    case 39: k = "right"; break;
    case 40: k = "down"; break;
    case 36: k = "home"; break;
    case 35: k = "end"; break;
    default:
      // fallthrough to printable handling
  }

  // Letters A-Z (respect shift xor caps)
  if (!k && b >= 65 && b <= 90) {
    var base = String.fromCharCode(b);
    var capsOn = !!caps;
    var shiftOn = !!shift;
    var makeUpper = (shiftOn && !capsOn) || (!shiftOn && capsOn);
    l = makeUpper ? base.toUpperCase() : base.toLowerCase();
    k = l;
  }

  // Common non-letter printable key mapping
  var keyMap = {
    48: ['0', ')'], 49: ['1','!'], 50: ['2','@'], 51: ['3','#'],
    52: ['4','$'], 53: ['5','%'], 54: ['6','^'], 55: ['7','&'],
    56: ['8','*'], 57: ['9','('],
    186: [';',':'], 187: ['=','+'], 188: [',','<'], 189: ['-','_'],
    190: ['.','>'], 191: ['/','?'], 192: ['`','~'],
    219: ['[','{'], 220: ['\\','|'], 221: [']','}'], 222: ["'",'"'],
    32: [' ',' ']
  };

  if (!k && keyMap[b]) { l = shift ? keyMap[b][1] : keyMap[b][0]; k = l; }

  // Ignore raw control codes (<32) that aren't already mapped
  if (!k && b < 32) { cursor(1); return; }

  // Modifier key toggles (virtual keyboard)
  if (k === "ctrl") {
    ctrl = !ctrl;
    var el = document.getElementById("ctrl");
    if (el) { el.style.backgroundColor = ctrl ? "#fff" : "#222"; el.style.color = ctrl ? "#000" : "#fff"; }
    cursor(1);
    return;
  }
  if (k === "alt") {
    alt = !alt;
    var el2 = document.getElementById("alt");
    if (el2) { el2.style.backgroundColor = alt ? "#fff" : "#222"; el2.style.color = alt ? "#000" : "#fff"; }
    updateKeyLabels();
    cursor(1);
    return;
  }
  if (k === "caps") {
    caps = !caps;
    var capsEl = document.getElementById("kcaps") || document.getElementById("caps");
    if (capsEl) {
      if (caps) { capsEl.style.backgroundColor = "#fff"; capsEl.style.color = "#000"; }
      else { capsEl.style.backgroundColor = "#222"; capsEl.style.color = "#fff"; }
    }
    updateKeyLabels();
    cursor(1);
    return;
  }

  if (keyboard) {
    // If program is running and has keydown, send it there first
    if (run && typeof keydown !== 'undefined') {
      try { keydown(k || l); } catch (e) {
        print("ERROR: keydown();\n\n");
      }
    } else {

      if (k === "back") {
        // BACKSPACE: delete char before cursor (or delete selection)
        cursor(0);
        if (selectionStart !== -1 && selectionEnd !== -1) {
          deleteSelection();
          renderInputLine();
        } else if (cursorPos > 0) {
          line = line.substring(0, cursorPos - 1) + line.substring(cursorPos);
          cursorPos--;
          setCursorToInputPos(cursorPos);
          renderInputLine();
        }
        selectionStart = -1; selectionEnd = -1;
        cursor(1);

      } else if (k === "delete") {
        // DELETE: forward-delete; SHIFT+DELETE: cut (copy+delete)
        cursor(0);
        if (shift) {
          var cutStart, cutEnd;
          if (selectionStart !== -1 && selectionEnd !== -1) {
            cutStart = Math.min(selectionStart, selectionEnd);
            cutEnd = Math.max(selectionStart, selectionEnd);
          } else {
            cutStart = cursorPos;
            cutEnd = line.length;
          }
          if (cutStart < cutEnd) {
            navigator.clipboard.writeText(line.substring(cutStart, cutEnd)).catch(function(e){ console.warn('clipboard write failed', e); });
            line = line.substring(0, cutStart) + line.substring(cutEnd);
            cursorPos = cutStart;
            setCursorToInputPos(cutStart);
          }
        } else {
          if (selectionStart !== -1 && selectionEnd !== -1) {
            deleteSelection();  // <-- deleteSelection() doesn't re-render!
          } else if (cursorPos < line.length) {
            line = line.substring(0, cursorPos) + line.substring(cursorPos + 1);
          }
        }
        selectionStart = -1; selectionEnd = -1;
        renderInputLine();
        cursor(1);

      } else if (k === "left") {
        if (cursorPos > 0) {
          if (shift) {
            if (selectionStart === -1) selectionStart = cursorPos;
            cursorPos--;
            selectionEnd = cursorPos;
            if (cursorX > 0) {
              cursorX--;
            } else {
              if (cursorY > 0) {
                cursorY--; cursorX = screenWidth - 1;
              } else {
                cursorX = 0; cursorPos = 0; selectionEnd = 0;
              }
            }
            pokeInverse(cursorX, cursorY, true);
          } else {
            selectionStart = -1; selectionEnd = -1;
            cursorPos--;
            if (cursorX==0) {
              cursorY--; cursorX=screenWidth-1;
            } else {
              cursorX--;
            }
          }
        }
        cursor(1);      
      } else if (k === "right") {
        // Move cursor right; extend selection if SHIFT held
        if (cursorPos < line.length) {
          if (shift) {
            if (selectionStart === -1) selectionStart = cursorPos;
            cursorPos++;
            if (cursorPos < 0) cursorPos = 0;
            if (cursorPos > line.length) cursorPos = line.length;
            selectionEnd = cursorPos;
            // Update cursor screen coordinates from logical position
            var sc = inputPosToScreen(cursorPos);
            cursorX = sc.x;
            cursorY = sc.y;
            // reflect selection visually
            renderInputLine();
            updateSelectionVisuals(selectionStart, selectionEnd);
          } else {
            selectionStart = -1; selectionEnd = -1;
            cursorPos++;
            setCursorToInputPos(cursorPos);
            //renderInputLine();
          }
        }
        cursor(1);
      } else if (k === "home") {
        if (shift && cursorPos > 0) {
          // SHIFT+HOME: extend selection to start of line
          if (selectionStart === -1) selectionStart = cursorPos;
          cursorPos = 0;
          selectionEnd = 0;
          var sc = inputPosToScreen(0);
          cursorX = sc.x; cursorY = sc.y;
          renderInputLine();
          updateSelectionVisuals(selectionStart, selectionEnd);
        } else {
          // Regular HOME: move cursor to start, clear selection
          selectionStart = -1; selectionEnd = -1;
          cursorPos = 0;
          var absCol = inputStartX + cursorPos;
          cursorY = inputStartY + Math.floor(absCol / screenWidth);
          cursorX = absCol % screenWidth; //@@
          // clamp to screen bounds just in case
          if (cursorY < 0) cursorY = 0;
          if (cursorY >= screenHeight) cursorY = screenHeight - 1;
          if (cursorX < 0) cursorX = 0;
          if (cursorX >= screenWidth) cursorX = screenWidth - 1;
        }
        cursor(1);
      } else if (k === "end") {
        // Move cursor to end of input line
        selectionStart = -1; selectionEnd = -1;
        setCursorToInputPos(line ? line.length : 0);
        renderInputLine();
        cursor(1);

      } else if (k === "up") {
        // History: go to older command
        if (commandHistory && commandHistory.length > 0) {
          if (historyIndex === -1) {
            tempCommand = line;           // save current typing
            historyIndex = commandHistory.length;
          }
          if (historyIndex > 0) {
            historyIndex--;
            line = commandHistory[historyIndex];
            setCursorToInputPos(line.length);
            renderInputLine();
          }
        }
        cursor(1);

      } else if (k === "down") {
        // History: go to newer command
        if (historyIndex !== -1) {
          if (historyIndex < commandHistory.length - 1) {
            historyIndex++;
            line = commandHistory[historyIndex];
          } else {
            historyIndex = -1;
            line = tempCommand || "";
            tempCommand = "";
          }
          setCursorToInputPos(line.length);
          renderInputLine();
        }
        cursor(1);

      } else if (k === "enter") {
        // Submit the current line
        selectionStart = -1; selectionEnd = -1;

        if (line !== undefined) {
          // Save to history
          if (typeof commandHistory !== 'undefined' && line.trim().length > 0) {
            if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== line) {
              commandHistory.push(line);
              if (typeof maxHistorySize !== 'undefined' && commandHistory.length > maxHistorySize) {
                commandHistory.shift();
              }
            }
          }
          historyIndex = -1;
          tempCommand = "";

          if (run) {
            print("\n");
            try { input(line); } catch (e) { /* ignore */ }
            line = "";
            cursorPos = 0;
            inputStartX = cursorX; inputStartY = cursorY;
            if (typeof updateDisplay === 'function') updateDisplay();
            cursor(1);   // <-- RE-ENABLE CURSOR after processing input
          } else {
            print("\n");
            if (line.slice(-3) === ".js") {
              keyboard = 0;
              var prg = document.createElement('script');
              prg.src = line;
              prg.onload = function() { keyson(); };
              prg.onerror = function() { print("Error loading program\n"); keyson(); };
              document.head.appendChild(prg);
              line = "";
              cursorPos = 0;
              inputStartX = cursorX; inputStartY = cursorY;
            } else if (line.substr(0,3) === "cls") {
              if (typeof initScreen === 'function') initScreen(); else cls();
              line = "";
              cursorX = 0; cursorY = 0; cursorPos = 0;
              inputStartX = 0; inputStartY = 0;
            } else {
              try { executeCode(line); } catch (e) { /* ignore */ }
              line = "";
              cursorPos = 0;
              inputStartX = cursorX; inputStartY = cursorY;
              cursor(1);
            }
            if (typeof updateDisplay === 'function') updateDisplay();
          }
        }

      } else if (l) {
        // Insert printable character(s)
        var finalChar = l;
        var hasCtrl = !!ctrl;
        var hasAlt = !!alt;
        var hasAltFlag = !!((typeof alt !== 'undefined' && alt) || (typeof altPhysical !== 'undefined' && altPhysical) || (event && !!event.altKey))
        var hasCtrlFlag = !!((typeof ctrl !== 'undefined' && ctrl) || (typeof ctrlPhysical !== 'undefined' && ctrlPhysical) || (event && !!event.ctrlKey));
        var hasAltShift = hasAltFlag && !!shift;

        //if (hasAltFlag) {
        //  var baseLower = (typeof l === 'string' && l.length > 0) ? l.toLowerCase() : '';
        //  if (hasAltShift && altShiftGraphics.hasOwnProperty(baseLower)) {
        //    finalChar = altShiftGraphics[baseLower];
        //  } else if (altGraphics.hasOwnProperty(baseLower)) {
        //    finalChar = altGraphics[baseLower];
        //  } else {
        //    // fallback: if no alt mapping, allow normal shifted behavior (shift or caps)
        //    if (shift && shiftedKeys.hasOwnProperty(baseLower)) finalChar = shiftedKeys[baseLower];
        //    else if (caps && shiftedKeys.hasOwnProperty(baseLower)) finalChar = shiftedKeys[baseLower];
        //    else finalChar = l;
        //  }
        //}
        
        if (hasCtrl) {
          ctrl = 0;
          var cel = document.getElementById("ctrl");
          if (cel) { cel.style.backgroundColor = "#222"; cel.style.color = "#fff"; }

          var lc = finalChar.toLowerCase();

          // Ctrl+C: copy selection or whole line
          if (lc === 'c') {
            var copyText = "";
            if (selectionStart !== -1 && selectionEnd !== -1) {
              var cs = Math.min(selectionStart, selectionEnd);
              var ce = Math.max(selectionStart, selectionEnd);
              copyText = line.substring(cs, ce);
            } else {
              copyText = line;
            }
            if (copyText.length > 0) {
              navigator.clipboard.writeText(copyText).catch(function(){});
            }
            cursor(1);
            return;
          }

          // Ctrl+V: paste from clipboard
          if (lc === 'v') {
            navigator.clipboard.readText().then(function(text) {
              if (text) {
                cursor(0);
                if (selectionStart !== -1 && selectionEnd !== -1) deleteSelection();
                selectionStart = -1; selectionEnd = -1;
                line = (line || "").substring(0, cursorPos) + text + (line || "").substring(cursorPos);
                cursorPos += text.length;
                renderInputLine();
                setCursorToInputPos(cursorPos);
                cursor(1);
              }
            }).catch(function(){});
            cursor(1);
            return;
          }

          // Ctrl+A: select all input
          if (lc === 'a') {
            if (line.length > 0) {
              selectionStart = 0; selectionEnd = line.length;
              updateSelectionVisuals(selectionStart, selectionEnd);
            }
            cursor(1);
            return;
          }

          // All other ctrl combos: ignore (don't insert text)
          cursor(1);
          return;
        }

        if (hasAlt) {
          alt = 0;
          var ael = document.getElementById("alt");
          var ael = document.getElementById("alt");
          var ael = document.getElementById("alt");
          if (ael) { ael.style.backgroundColor = "#222"; ael.style.color = "#fff"; }
          // ALT combos: could be extended; for now fall through to insert
        }

        // Typing clears any active selection (replacing selected text)
        if (selectionStart !== -1 && selectionEnd !== -1) {
          deleteSelection();
        }
        selectionStart = -1; selectionEnd = -1;

        // Insert character into line at cursorPos
        line = (line || "").substring(0, cursorPos) + finalChar + (line || "").substring(cursorPos);
        cursorPos += finalChar.length;

        // Advance cursorX, wrapping to next row if we hit screenWidth
        cursorX += finalChar.length;
        while (cursorX >= screenWidth) {
          cursorX -= screenWidth;
          cursorY++;
          if (cursorY >= screenHeight) { cursorY = screenHeight - 1; }
        }

        // Re-render the full visible input line
        renderInputLine();

        if (typeof historyIndex !== 'undefined' && historyIndex !== -1) { historyIndex = -1; tempCommand = ""; }
        cursor(1);
      }

    } // end else (not run+keydown)
  } else {
    if (run) { keydown(k || l); }
  }
}

document.addEventListener('keydown', function (event) {
 if (event.keycode === 32) { event.preventDefault(); }
 press(event);
});


document.addEventListener('keyup', function (event) { pressup(event); });
document.addEventListener('paste', function (event) {
 if (keyon) {
  event.preventDefault();
  var pastedText;
  if (event.clipboardData && event.clipboardData.getData) {
   pastedText = event.clipboardData.getData('text/plain');
  } else if (window.clipboardData && window.clipboardData.getData) {
   pastedText = window.clipboardData.getData('Text');
  }
  if (pastedText) {
   cursor(0);
   if (selectionStart !== -1 && selectionEnd !== -1) deleteSelection();
   selectionStart = -1; selectionEnd = -1;
   line = (line || "").substring(0, cursorPos) + pastedText + (line || "").substring(cursorPos);
   cursorPos += pastedText.length;
   renderInputLine();
   setCursorToInputPos(cursorPos);
   cursor(1);
  }
 }
});

function press(event) { 
 key=""; k=event.keyCode; shift=event.shiftKey;

 // Handle physical CapsLock keypress (keyCode 20)
 if (event.keyCode === 20) {
   // Determine the platform state if available
   var platformState = (typeof event.getModifierState === 'function') ? !!event.getModifierState('CapsLock') : null;

   // Compute the new desired caps state:
   // - If platformState is available, use it.
   // - But some browsers report the previous state on keydown; if platformState equals current caps,
   //   assume the toggle has not yet been applied and flip it.
   var newCaps;
   if (platformState === null) {
     newCaps = !caps; // no platform info -> just toggle
   } else {
     newCaps = platformState;
     if (platformState === caps) {
       // likely timing issue -> flip to reflect the user action
       newCaps = !caps;
     }
   }

   caps = !!newCaps;
   l = document.getElementById("kcaps") || document.getElementById("caps");
   if (l) {
     if (caps) { l.style.backgroundColor = "#fff"; l.style.color = "#000"; }
     else { l.style.backgroundColor = "#222"; l.style.color = "#fff"; }
   }

   // Cancel any transient flash timeout for the CAPS element so it won't reapply a flash style
   try {
     if (keyTimeouts && keyTimeouts['caps']) { clearTimeout(keyTimeouts['caps']); delete keyTimeouts['caps']; }
     // Also clear any stored flash marker on the element
     if (l) l.dataset._flash = '';
   } catch (e) { /* ignore */ }

   // Ensure label updates
   if (typeof updateKeyLabels === 'function') updateKeyLabels();

   // If we just turned it off, explicitly unhighlight the element (clear inline styles)
   if (!caps) {
     unhighlightKey('caps');
   } else {
     // Ensure locked appearance
     if (l) { l.style.backgroundColor = "#fff"; l.style.color = "#000"; }
   }

  // Prevent default browser handling side-effects and stop further processing for this key event
  event.preventDefault && event.preventDefault();
  return;
}

  if (event.ctrlKey && (event.key === 'v' || event.key === 'V')) {
    // Let the browser fire the native paste event (handled by the paste listener)
    return;
  }

 if (event.keyCode === 18 || event.altKey) { event.preventDefault(); }
 if (event.keyCode === 27) { event.preventDefault(); }
 if (event.keyCode === 16) {
  var capsBtn = document.getElementById("caps");
  if (capsBtn) { capsBtn.style.backgroundColor = "#444"; capsBtn.style.color = "#fff"; }
  updateKeyLabels();
 }
 if (event.keyCode === 17 && !ctrl) {
  ctrl=1; ctrlPhysical=true;
  document.getElementById("ctrl").style.backgroundColor = "#0a0";
  document.getElementById("ctrl").style.color = "#000";
  return;
 }
 if (event.keyCode === 18 && !alt) {
  highlightKey(k);
  alt = 1; altPhysical = true;
  document.getElementById("alt").style.backgroundColor = "#0a0";
  document.getElementById("alt").style.color = "#000";
  updateKeyLabels();
 }
 // For Ctrl+key combos, pass specific ones through to button() (Ctrl+C, Ctrl+A)
 // Ctrl+V is handled via the native paste event listener instead
 if (event.ctrlKey) {
  var ctrlKey = event.key ? event.key.toLowerCase() : '';
  if (ctrlKey === 'c' || ctrlKey === 'a') {
   event.preventDefault();
   highlightKey(k);
   button(k, event);
  }
  // All other ctrl combos: let browser handle
  return;
 }
 highlightKey(k);
 button(k, event);
}

function pressup(event) {
  // Prevent browser from handling ALT key - must be done before any conditionals
  if (event.keyCode === 18 || event.altKey) {
    event.preventDefault(); // Prevent browser menu from opening
  }
 
  // Handle physical CTRL key release (unhighlight)
  if (event.keyCode === 17 && ctrlPhysical) {
    ctrl = 0;
    ctrlPhysical = false;
    document.getElementById("ctrl").style.backgroundColor = "#222";
    document.getElementById("ctrl").style.color = "#fff";
    return;
  }

  // Handle physical SHIFT key release (unhighlight CAPS unless caps mode is active)
  if (event.keyCode === 16) {
    shift = 0;
    if (typeof updateKeyLabels === 'function') updateKeyLabels();
    if (!caps) { unhighlightKey('caps'); }
    return;
  }

  // Handle physical ALT key release (unhighlight)
  if (event.keyCode === 18 && altPhysical) {
    alt = 0;
    altPhysical = false;
    document.getElementById("alt").style.backgroundColor = "#222";
    document.getElementById("alt").style.color = "#fff";
    updateKeyLabels();
    return;
  }
 
  // Route keyup to active script if run is set
  if (run && typeof keyup !== 'undefined') {
    var k = String.fromCharCode(event.keyCode);
    keyup(k);
  }
}

function ensureBuffersAndRow(y) {
  if (!window.screenHeight) window.screenHeight = 25;
  if (!window.screenBuffer) window.screenBuffer = [];
  if (!window.styleBuffer) window.styleBuffer = [];
  if (!window.screenBuffer[y]) {
    window.screenBuffer[y] = new Array(32);
    for (var i = 0; i < 32; i++) window.screenBuffer[y][i] = ' ';
  }
  if (!window.styleBuffer[y]) {
    window.styleBuffer[y] = new Array(32);
    for (var i = 0; i < 32; i++) {
      window.styleBuffer[y][i] = {
        color: (window.currentStyle && window.currentStyle.color) || 37,
        bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
        bold: !!(window.currentStyle && window.currentStyle.bold),
        inverse: !!(window.currentStyle && window.currentStyle.inverse)
      };
    }
  }
}


  function safeGet(arr, y, x) {
    if (!arr) return undefined;
    if (typeof y !== 'number' || typeof x !== 'number') return undefined;
    if (!arr[y]) return undefined;
    return arr[y][x];
  }

  // Remove existing ansi-fg-* and ansi-bg-* classes from el
  function removeAnsiColorClasses(el) {
    if (!el || !el.classList) return;
    var toRemove = [];
    el.classList.forEach(function (c) {
      if (/^ansi-fg-\d+$/.test(c) || /^ansi-bg-\d+$/.test(c)) toRemove.push(c);
    });
    toRemove.forEach(function (c) { el.classList.remove(c); });
  }

  // Update DOM cell classes/inline style from styleObj
  function applyStyleToDom(el, styleObj) {
    if (!el) return;
    // remove old ANSI color classes
    removeAnsiColorClasses(el);
    // add new ones if provided
    if (styleObj && typeof styleObj.color !== 'undefined') {
      el.classList.add('ansi-fg-' + String(styleObj.color));
    }
    if (styleObj && typeof styleObj.bgcolor !== 'undefined') {
      el.classList.add('ansi-bg-' + String(styleObj.bgcolor));
    }
    // bold -> inline weight (repo CSS also has ansi-bold, but use inline to be immediate)
    if (styleObj && styleObj.bold) {
      el.style.fontWeight = 'bold';
      el.classList.add('ansi-bold');
    } else {
      el.style.fontWeight = '';
      el.classList.remove('ansi-bold');
    }
    // inverse: add a class to hint repo code; also swap colors if you want
    if (styleObj && styleObj.inverse) {
      el.classList.add('ansi-inverse');
      // leave actual fg/bg class names; repo drawing code interprets inverse sometimes.
    } else {
      el.classList.remove('ansi-inverse');
    }
  }

  // Update just the DOM cell content and style in-place if element exists
  function updateDomCellInPlace(x, y) {
    try {
      var elId = 'c' + y + '_' + x; // repo convention: c{row}_{col}
      var el = document.getElementById(elId);
      var ch = safeGet(window.screenBuffer, y, x);
      var styleObj = safeGet(window.styleBuffer, y, x);

      if (!el) return false;

      // write char (use &nbsp; for space)
      if (typeof ch === 'string') {
        if (ch === '\u00A0' || ch === ' ') el.innerHTML = '&nbsp;';
        else el.textContent = ch;
      } else {
        el.innerHTML = '&nbsp;';
      }

      applyStyleToDom(el, styleObj);
      return true;
    } catch (e) {
      console.error('updateDomCellInPlace error:', e);
      return false;
    }
  }

  // New: setCellStyle(x,y, styleObj) updates styleBuffer and DOM (no char change)

function keyson() { keyon=1; cursor(1); }
function keysoff() { keyon=0; cursor(0); }

function cursor(a) {
  if (a === 1) {
    const existingStyle = styleBuffer[cursorY][cursorX] ? Object.assign({}, styleBuffer[cursorY][cursorX]) : {
      color: currentStyle.color, bgcolor: currentStyle.bgcolor, bold: currentStyle.bold, inverse: currentStyle.inverse
    };
    styleBuffer[cursorY][cursorX] = Object.assign({}, existingStyle);
    styleBuffer[cursorY][cursorX].inverse = true;
    const el = document.getElementById(`c${cursorY}_${cursorX}`);
    if (el) { el.classList.add('qandy-cursor'); }
    cursorOn = 1;
  } else {
    const existingStyle = styleBuffer[cursorY][cursorX] ? Object.assign({}, styleBuffer[cursorY][cursorX]) : {
      color: currentStyle.color, bgcolor: currentStyle.bgcolor, bold: currentStyle.bold, inverse: currentStyle.inverse
    };
    styleBuffer[cursorY][cursorX] = Object.assign({}, existingStyle);
    styleBuffer[cursorY][cursorX].inverse = false;
    const el = document.getElementById(`c${cursorY}_${cursorX}`);
    if (el) el.classList.remove('qandy-cursor');
    cursorOn = 0;  
  }
}

function executeCode(code) {
  try {
    var trimmed = String(code).trim();
    var simpleNameRE = /^[$A-Za-z_][$A-Za-z0-9_]*(?:\s*\.\s*[$A-Za-z_][$A-Za-z0-9_]*)*$/;
    if (simpleNameRE.test(trimmed)) {
      try {
        var value = eval(trimmed);
      } catch (e) {
        print("Error: " + e.message + "\n\n");
        return false;
      }
      if (typeof value === "function") {
        print("ERROR: use: "+trimmed+"()\n\n");
        return true;
      }
      if (value !== undefined) { print(String(value) + "\n\n"); }
      return true;
    }
    var result = eval(code);
    if (result !== undefined) { print(String(result) + "\n\n"); }
    return true;
  } catch (error) {
    print("Error: " + error.message + "\n\n");
    return false;
  }
}

//function executeCode(code) {
// try {
//  const result=eval(code);
//  if (result !== undefined) {
//   print(String(result)+"<br>");
//  }
//  return true;
// } catch (error) {
//  print(`Error: ${error.message}`+"<br>");
//  return false;
// }
//}

function parseANSIString(str) {
  const tokens = [];
  // Match ANSI escape sequences in hex (\x1b), octal (\033 = \x1b), and unicode (\u001b) formats
  const ansiRegex = /(\x1b|\x1b|\u001b)\[([\d;]*)([A-Za-z])/g;
  let lastIndex = 0;
  let match;
  
  while ((match = ansiRegex.exec(str)) !== null) {
    // Add text before the ANSI code
    if (match.index > lastIndex) {
      const text = str.substring(lastIndex, match.index);
      for (let i = 0; i < text.length; i++) {
        tokens.push({ type: 'char', value: text[i] });
      }
    }
    
    // Add the ANSI code
    const params = match[2] ? match[2].split(';').filter(s => s !== '').map(Number) : [0];
    const command = match[3];
    
    if (command === 'm') {
      // SGR (Select Graphic Rendition) - color/style codes
      tokens.push({ type: 'code', codes: params });
    } else if (command === 'H' || command === 'f') {
      // CUP (Cursor Position) - move cursor to row;col
      // Format: \x1b[row;colH or \x1b[row;colf
      const row = params[0] ? params[0] - 1 : 0; // Convert to 0-based
      const col = params[1] ? params[1] - 1 : 0; // Convert to 0-based
      tokens.push({ type: 'cursor', row: row, col: col });
    } else if (command === 'K') {
      // EL (Erase in Line) - clear from cursor to end of line
      // param 0 or missing = clear from cursor to end
      // param 1 = clear from start to cursor
      // param 2 = clear entire line
      const mode = params[0] || 0;
      tokens.push({ type: 'clearline', mode: mode });
    }
    // Other ANSI commands are ignored for now
    
    lastIndex = match.index + match[0].length;
  }
  
  // Add remaining text
  if (lastIndex < str.length) {
    const text = str.substring(lastIndex);
    for (let i = 0; i < text.length; i++) {
      tokens.push({ type: 'char', value: text[i] });
    }
  }
  
  return tokens;
}

function applyANSICode(codes) {
  codes.forEach(code => {
    if (code === 0) {
      // Reset all
      currentStyle.color = 37;
      currentStyle.bgcolor = 40;
      currentStyle.bold = false;
      currentStyle.inverse = false;
    } else if (code === 1) {
      // Bold
      currentStyle.bold = true;
    } else if (code === 7) {
      // Inverse
      currentStyle.inverse = true;
    } else if (code === 27) {
      // No inverse
      currentStyle.inverse = false;
    } else if (code >= 30 && code <= 37) {
      // Foreground color
      currentStyle.color = code;
    } else if (code >= 40 && code <= 47) {
      // Background color
      currentStyle.bgcolor = code;
    }
  });
}

function scrollScreenDown() {
  screenBuffer.shift();
  styleBuffer.shift();
  
  const newLine = [];
  const newStyleLine = [];
  for (let j = 0; j < screenWidth; j++) {
    newLine[j] = ' ';
    newStyleLine[j] = {
      color: currentStyle.color,
      bgcolor: currentStyle.bgcolor,
      bold: currentStyle.bold,
      inverse: currentStyle.inverse
    };
  }
  screenBuffer.push(newLine);
  styleBuffer.push(newStyleLine);
}

// Helper functions

function showFiles() {
  print("ascii.js\n");
  print("sound.js\n");
  print("piano.js\n");
  print("demo.js\n");
  print("q.js\n");
  print("world.js\n");
  print("\n");
  
  // List files from localStorage
  var userFiles = [];
  for (var i = 0; i < localStorage.length; i++) {
    var key = localStorage.key(i);
    if (key.startsWith("qandy_file_")) {
      userFiles.push(key.substring(11)); // Remove "qandy_file_" prefix
    }
  }
  
  if (userFiles.length > 0) {
    print("\x1b[1;32mUSER FILES:\x1b[0m\n");
    for (var j = 0; j < userFiles.length; j++) {
      print(userFiles[j] + "\n");
    }
    print("\n");
  }
}

function triggerPaginationPause() {
  // Prevent re-entering pause state
  if (paginationPaused) return;


  // Ensure buffers initialized
  if (!screenBuffer || screenBuffer.length === 0) initScreen();
  if (!styleBuffer || styleBuffer.length === 0) initScreen();

  // Save visible state we will restore
  const savedCursorX = typeof cursorX !== 'undefined' ? cursorX : 0;
  const savedCursorY = typeof cursorY !== 'undefined' ? cursorY : 0;
  const savedStyle = {
    color: currentStyle.color,
    bgcolor: currentStyle.bgcolor,
    bold: currentStyle.bold,
    inverse: currentStyle.inverse
  };

  // Mark pagination state and disable normal input
  paginationPaused = true;
  keysoff();

  // Reset any printed-line counters so next page starts fresh
  if (typeof printedLinesSinceLastPause !== 'undefined') printedLinesSinceLastPause = 0;

  // Build ANSI-coded pause message:
  // - Move cursor to bottom row (screenHeight), column 1
  // - Erase the entire line (\x1b[2K) or use \x1b[K to clear from cursor to end
  // - Set bright white and bold for visibility, print message, then reset attributes
  const row = Math.max(1, (typeof screenHeight === 'number' ? screenHeight : 25)); // ANSI rows are 1-based
  const pauseMsgPlain = "Press Any Key to Continue:";
  const ansiPause =
    "\x1b[" + row + ";1H" +    // CUP to bottom line, col 1
    "\x1b[2K" +               // Erase entire line
    "\x1b[1;37m" +            // Bold + white foreground
    pauseMsgPlain +
    "\x1b[0m";                // Reset attributes

  // Use draw() to render the ANSI-coded pause message WITHOUT scrolling
  try {
    draw(ansiPause);
  } catch (e) {
    // If draw() fails, fallback to writing into buffers directly (best-effort)
    console.warn("draw() failed in triggerPaginationPause():", e);
    // fallback: write into screenBuffer directly on last line
    const r = Math.min(screenHeight - 1, savedCursorY + 1);
    // clear line
    for (let c = 0; c < screenWidth; c++) {
      screenBuffer[row - 1][c] = ' ';
      styleBuffer[row - 1][c] = {
        color: 37, bgcolor: currentStyle.bgcolor, bold: true, inverse: false
      };
    }
    // write message, clipped to screenWidth
    for (let i = 0; i < pauseMsgPlain.length && i < screenWidth; i++) {
      screenBuffer[row - 1][i] = pauseMsgPlain.charAt(i);
      styleBuffer[row - 1][i] = { color: 37, bgcolor: currentStyle.bgcolor, bold: true, inverse: false };
    }
  }

  // Force a display update so the message is visible now
  try {
    updateDisplay();
  } catch (e) {
    // best-effort DOM refresh fallback
    try { document.getElementById("txt").innerHTML = document.getElementById("txt").innerHTML; } catch (_) {}
  }

  // Restore cursor position and style variables so printing resumes cleanly later.
  cursorX = savedCursorX;
  cursorY = savedCursorY;
  currentStyle.color = savedStyle.color;
  currentStyle.bgcolor = savedStyle.bgcolor;
  currentStyle.bold = savedStyle.bold;
  currentStyle.inverse = savedStyle.inverse;
}

// logical index = position within `line` (0-based)
function logicalToScreen(index) {
  const charsPerLine = screenWidth;
  const baseRow = cursorY - Math.floor(cursorPos / charsPerLine);
  const rowOffset = Math.floor(index / charsPerLine);
  const col = index % charsPerLine;
  const row = baseRow + rowOffset;
  return { row: row, col: col };  // col doesn't use inputStartX!
}

function syncCursorCoordsFromPos() {
  // Recompute cursorX/cursorY from cursorPos using inputPosToScreen helper
  const sc = inputPosToScreen(cursorPos);
  cursorX = sc.x;
  cursorY = sc.y;
  cursorPos = cursorPos; // unchanged
  // visually re-place cursor using existing cursor() routine
  if (cursorOn) {
    cursor(0); // hide previous visual
  }
  cursor(1);   // show at new coords
}

function writeInputSegmentToScreenRow(targetRow, startIdx, length) {
  if (targetRow < 0 || targetRow >= screenHeight) return;
  if (!screenBuffer[targetRow]) {
    screenBuffer[targetRow] = new Array(screenWidth).fill('\u00A0');
  }
  if (!styleBuffer[targetRow]) {
    styleBuffer[targetRow] = new Array(screenWidth);
    for (let x = 0; x < screenWidth; x++) {
      styleBuffer[targetRow][x] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: false,
        inverse: false
      };
    }
  }

  const inputStyle = {
    color: (currentStyle && currentStyle.color) || 37,
    bgcolor: (currentStyle && currentStyle.bgcolor) || 40,
    bold: false,
    inverse: false
  };

  for (let i = 0; i < length; i++) {
    const strIdx = startIdx + i;
    const ch = (strIdx < line.length) ? line.charAt(strIdx) : '\u00A0'; // NBSP when beyond text
    const col = i;
    if (screenBuffer[targetRow][col] !== ch || !styleBuffer[targetRow][col] || styleBuffer[targetRow][col].inverse) {
      screenBuffer[targetRow][col] = ch;
      // set explicit style for input text (non-inverse)
      styleBuffer[targetRow][col] = Object.assign({}, inputStyle);
      // update DOM via pokeCell and pass style so prevCursor can't accidentally capture inverse
      try { pokeCell(col, targetRow, ch, inputStyle); } catch (e) { /* best-effort */ }
    }
  }
}

// Update visual selection between selStart and selEnd (logical indices)

// Update visual selection between selStart and selEnd (logical indices)
function updateSelectionVisuals(selStart, selEnd) {
  if (selStart === -1 || selEnd === -1) return;
  if (selStart > selEnd) { const t = selStart; selStart = selEnd; selEnd = t; }
  const charsPerLine = screenWidth;
  for (let i = selStart; i < selEnd; i++) {
    const { row, col } = logicalToScreen(i);
    if (row < 0 || row >= screenHeight || col < 0 || col >= screenWidth) continue;
    if (!styleBuffer[row]) continue;
    if (!styleBuffer[row][col]) {
      styleBuffer[row][col] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: false,
        inverse: true
      };
      pokeCell(col, row);
    } else if (!styleBuffer[row][col].inverse) {
      styleBuffer[row][col].inverse = true;
      pokeCell(col, row);
    }
  }
  // Clear inverse for cells outside selection in visible area (optional clean pass)
  // (you can optimize this to only clear previously-selected region)
  const totalVisible = Math.min(Math.ceil(Math.max(1, line.length) / charsPerLine), screenHeight);
  const baseRow = cursorY - Math.floor(cursorPos / charsPerLine);
  for (let r = baseRow; r < baseRow + totalVisible; r++) {
    if (!styleBuffer[r]) continue;
    for (let c = 0; c < screenWidth; c++) {
      const logicalIndex = (r - baseRow) * charsPerLine + c;
      if (logicalIndex < selStart || logicalIndex >= selEnd) {
        if (styleBuffer[r][c] && styleBuffer[r][c].inverse) {
          styleBuffer[r][c].inverse = false;
          pokeCell(c, r);
        }
      }
    }
  }
}

function print(inputString) {
  inputString = (typeof inputString === 'undefined' || inputString === null) ? '' : String(inputString);
  // old debug code, may or may not remove
  txt = (typeof txt !== 'undefined' && txt !== null) ? txt + inputString : inputString;
  var wasKeyon = !!keyon;
  keysoff();
  cursor(0);
  var end=draw(inputString, cursorX, cursorY);
  cursorX = end.x;
  cursorY = end.y;
  if (wasKeyon) { keyson(); }
}

function resumePagination() {
  // Clear the pause message by removing last few lines
  if (screenBuffer.length > 0) {
    // Remove the "Press Any Key" message line
    const lastLineIdx = screenBuffer.length - 1;
    for (let x = 0; x < screenWidth; x++) {
      screenBuffer[lastLineIdx][x] = ' ';
      styleBuffer[lastLineIdx][x] = {
        color: 37,
        bgcolor: 40,
        bold: false,
        inverse: false
      };
    }
  }
  
  // Reset pagination state
  paginationPaused = false;
  keyson();  // Re-enable keyboard input
  
  // Clear the screen and reset cursor
  cls();
  
  // Process queued print calls
  const bufferedText = paginationBuffer.slice();  // Copy array
  paginationBuffer = [];  // Clear buffer
  
  // Print all buffered content
  for (let i = 0; i < bufferedText.length; i++) {
    print(bufferedText[i]);
  }
}

function updateDisplay() {
  const txtElement = document.getElementById("txt");
  let htmlContent = '';
  // Render the full visible screen (clamped to available buffer).
  const rowsToRender = Math.min(screenHeight, screenBuffer.length);
  // small helper to escape characters for HTML
  function escapeChar(c) {
    if (c === ' ') return '&nbsp;';
    if (c === '&') return '&amp;';
    if (c === '<') return '&lt;';
    if (c === '>') return '&gt;';
    // keep control chars out of output
    if (c === '\t') return '&nbsp;&nbsp;&nbsp;&nbsp;';
    if (c === '\r' || c === '\n') return '';
    // default: return the character as-is (assumes ASCII printable)
    return c;
  }

  for (let y = 0; y < rowsToRender; y++) {
  // ensure row arrays exist (same as before)
  if (!screenBuffer[y]) { screenBuffer[y] = new Array(screenWidth).fill(' '); }
  if (!styleBuffer[y]) {
    styleBuffer[y] = new Array(screenWidth);
    for (let x = 0; x < screenWidth; x++) {
      styleBuffer[y][x] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: currentStyle.bold,
        inverse: currentStyle.inverse
      };
    }
  }

  let lineHtml = '<span class="qandy-line">';

  for (let x = 0; x < screenWidth; x++) {
    const ch = (screenBuffer[y][x] === undefined || screenBuffer[y][x] === null) ? ' ' : screenBuffer[y][x];
    const style = styleBuffer[y][x] || {
      color: currentStyle.color,
      bgcolor: currentStyle.bgcolor,
      bold: currentStyle.bold,
      inverse: currentStyle.inverse
    };

    // Build the class list for the character (map your ANSI to classes)
    const classes = [];
    if (style.inverse) {
      classes.push('ansi-inverse');
    } else {
      classes.push(`ansi-fg-${style.color}`);   // adjust names to match your CSS
      classes.push(`ansi-bg-${style.bgcolor}`);
    }
    if (style.bold) classes.push('ansi-bold');

    // Escape char for HTML; keep spaces as &nbsp;
    const escapedChar = (ch === ' ') ? '&nbsp;' :
                        (ch === '&') ? '&amp;' :
                        (ch === '<') ? '&lt;' :
                        (ch === '>') ? '&gt;' :
                        ch;

    // Give each cell an id so it can be updated independently later.
    lineHtml += `<span id="c${y}_${x}" class="${classes.join(' ')}">${escapedChar}</span>`;
  }

  lineHtml += '</span><br>';
  htmlContent += lineHtml;
}

  // Fill remaining visible rows with blank lines if buffer is shorter than screenHeight
  for (let y = rowsToRender; y < screenHeight; y++) {
    htmlContent += `<div class="row">&nbsp;</div>`;
  }

  // Write to DOM in one shot
  txtElement.innerHTML = htmlContent;

  //try {
  //  // Remove previous cursor markers (if any)
  //  const prev = document.querySelectorAll('.qandy-cursor');
  //  for (let p = 0; p < prev.length; p++) prev[p].classList.remove('qandy-cursor');

  //  // Add cursor marker to current cursor position (cursorX, cursorY are logical coords)
  //  if (typeof cursorX === 'number' && typeof cursorY === 'number') {
  //    const curEl = document.getElementById(`c${cursorY}_${cursorX}`);
  //    if (curEl) {
  //      curEl.classList.add('qandy-cursor');
  //    }
  //  }
  //} catch (e) {
  //  // Non-fatal: best-effort only
  //  console.warn('Failed to apply qandy cursor marker', e);
  //}
}


function ensureBuffersAndRow(y) {
  if (!window.screenHeight) window.screenHeight = 25;
  if (!window.screenBuffer) window.screenBuffer = [];
  if (!window.styleBuffer) window.styleBuffer = [];
  if (!window.screenBuffer[y]) {
    window.screenBuffer[y] = new Array(32);
    for (var i = 0; i < 32; i++) window.screenBuffer[y][i] = ' ';
  }
  if (!window.styleBuffer[y]) {
    window.styleBuffer[y] = new Array(32);
    for (var i = 0; i < 32; i++) {
      window.styleBuffer[y][i] = {
        color: (window.currentStyle && window.currentStyle.color) || 37,
        bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
        bold: false,
        inverse: false
      };
    }
  }
}

function safeGet(arr, y, x) {
  if (!arr) return undefined;
  if (typeof y !== 'number' || typeof x !== 'number') return undefined;
  if (!arr[y]) return undefined;
  return arr[y][x];
}

function updateDomCell(x, y) {
  try {
    var elId = 'c' + y + '_' + x; // qandy's cell id convention (row_col)
    var el = document.getElementById(elId);
    var ch = safeGet(window.screenBuffer, y, x);
    var style = safeGet(window.styleBuffer, y, x);

    // Convert to safe innerHTML; use &nbsp; for spaces/NBSP so it remains visible
    var html;
    if (typeof ch === 'string') {
      if (ch === '\u00A0' || ch === ' ') html = '&nbsp;';
      else html = ch.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    } else {
      html = '&nbsp;';
    }

    if (el) {
      el.innerHTML = html;
      // apply minimal style hints so the cell looks correct if inverse/bold changed
      if (style && style.inverse) {
        el.style.backgroundColor = '#fff';
        el.style.color = '#000';
      } else {
        el.style.backgroundColor = '';
        el.style.color = '';
      }
      el.style.fontWeight = (style && style.bold) ? 'bold' : '';
      return true;
    } else {
      return false;
    }
  } catch (e) {
    console.error('updateDomCell error:', e);
    return false;
  }
}

// ============================================================================
// OPERATING SYSTEM LEVEL POKE ROUTINES - OPTIMIZED FOR MAXIMUM PERFORMANCE
// ============================================================================

function ensureBuffersAndRow(y) {
  if (!window.screenHeight) window.screenHeight = 25;
  if (!window.screenBuffer) window.screenBuffer = [];
  if (!window.styleBuffer) window.styleBuffer = [];
  if (!window.screenBuffer[y]) {
    window.screenBuffer[y] = new Array(screenWidth);
    for (var i = 0; i < screenWidth; i++) window.screenBuffer[y][i] = ' ';
  }
  if (!window.styleBuffer[y]) {
    window.styleBuffer[y] = new Array(screenWidth);
    for (var i = 0; i < screenWidth; i++) {
      window.styleBuffer[y][i] = {
        color: 37,
        bgcolor: 40,
        bold: false,
        inverse: false
      };
    }
  }
}

// Helper: Fast safe get
function safeGet(arr, y, x) {
  return (arr && arr[y]) ? arr[y][x] : undefined;
}

// ============================================================================
// PRIMARY POKE FUNCTION - Poke character, color, and style all at once
// ============================================================================
window.pokeCell = function(x, y, ch, styleObj) {
  // Validate coordinates
  if (typeof x !== 'number' || typeof y !== 'number') return false;
  if (x < 0 || y < 0 || x >= screenWidth || y >= screenHeight) return false;
  
  ensureBuffersAndRow(y);
  
  // Handle parameter shifting: pokeCell(x, y, styleObj)
  if (typeof ch === 'object' && typeof styleObj === 'undefined') {
    styleObj = ch;
    ch = undefined;
  }
  
  // Getter mode: pokeCell(x, y) returns character
  if (typeof ch === 'undefined' && typeof styleObj === 'undefined') {
    return window.screenBuffer[y][x];
  }
  
  // Update character if provided
  if (typeof ch !== 'undefined') {
    window.screenBuffer[y][x] = (typeof ch === 'string') ? ch : String(ch)[0] || ' ';
  }
  
  // Ensure style exists
  if (!window.styleBuffer[y][x]) {
    window.styleBuffer[y][x] = { color: 37, bgcolor: 40, bold: false, inverse: false };
  }
  
  // Update style if provided
  if (styleObj && typeof styleObj === 'object') {
    var style = window.styleBuffer[y][x];
    if (typeof styleObj.color !== 'undefined') style.color = styleObj.color;
    if (typeof styleObj.bgcolor !== 'undefined') style.bgcolor = styleObj.bgcolor;
    if (typeof styleObj.bold !== 'undefined') style.bold = !!styleObj.bold;
    if (typeof styleObj.inverse !== 'undefined') style.inverse = !!styleObj.inverse;
  }
  
  // Fast DOM update
  updateDomCellInPlace(x, y);
  return true;
};

// ============================================================================
// POKE CHARACTER ONLY - Fastest character-only updates
// ============================================================================
window.pokeChar = function(x, y, ch, count) {
  // Validate
  if (typeof x !== 'number' || typeof y !== 'number') return false;
  if (x < 0 || y < 0 || y >= screenHeight) return false;
  
  // Getter mode
  if (typeof ch === 'undefined') {
    return safeGet(window.screenBuffer, y, x);
  }
  
  // Normalize character
  var char = (typeof ch === 'string') ? ch : String(ch)[0] || ' ';
  
  // Span mode: repeat character across multiple cells
  if (typeof count === 'number' && count > 1) {
    var endX = Math.min(x + count, screenWidth);
    for (var i = x; i < endX; i++) {
      ensureBuffersAndRow(y);
      window.screenBuffer[y][i] = char;
      updateDomCellInPlace(i, y);
    }
    return endX - x; // Return number of cells updated
  }
  
  // Single cell update
  if (x >= screenWidth) return false;
  ensureBuffersAndRow(y);
  window.screenBuffer[y][x] = char;
  updateDomCellInPlace(x, y);
  return true;
};

// ============================================================================
// POKE STYLE ONLY - Update inverse, bold without touching character
// ============================================================================
window.pokeStyle = function(x, y, styleObj, count) {
  // Validate
  if (typeof x !== 'number' || typeof y !== 'number') return false;
  if (x < 0 || y < 0 || y >= screenHeight) return false;
  
  // Getter mode
  if (typeof styleObj === 'undefined') {
    return safeGet(window.styleBuffer, y, x);
  }
  
  // Span mode: apply style across multiple cells
  if (typeof count === 'number' && count > 1) {
    var endX = Math.min(x + count, screenWidth);
    for (var i = x; i < endX; i++) {
      ensureBuffersAndRow(y);
      var style = window.styleBuffer[y][i];
      if (!style) {
        style = window.styleBuffer[y][i] = { color: 37, bgcolor: 40, bold: false, inverse: false };
      }
      if (typeof styleObj.color !== 'undefined') style.color = styleObj.color;
      if (typeof styleObj.bgcolor !== 'undefined') style.bgcolor = styleObj.bgcolor;
      if (typeof styleObj.bold !== 'undefined') style.bold = !!styleObj.bold;
      if (typeof styleObj.inverse !== 'undefined') style.inverse = !!styleObj.inverse;
      updateDomCellInPlace(i, y);
    }
    return endX - x;
  }
  
  // Single cell update
  if (x >= screenWidth) return false;
  ensureBuffersAndRow(y);
  var style = window.styleBuffer[y][x];
  if (!style) {
    style = window.styleBuffer[y][x] = { color: 37, bgcolor: 40, bold: false, inverse: false };
  }
  if (typeof styleObj.color !== 'undefined') style.color = styleObj.color;
  if (typeof styleObj.bgcolor !== 'undefined') style.bgcolor = styleObj.bgcolor;
  if (typeof styleObj.bold !== 'undefined') style.bold = !!styleObj.bold;
  if (typeof styleObj.inverse !== 'undefined') style.inverse = !!styleObj.inverse;
  updateDomCellInPlace(x, y);
  return true;
};

// ============================================================================
// POKE COLOR ONLY - C64-style color memory (fg/bg only)
// ============================================================================
window.pokeColor = function(x, y, fgColor, bgColor, count) {
  // Validate
  if (typeof x !== 'number' || typeof y !== 'number') return false;
  if (x < 0 || y < 0 || y >= screenHeight) return false;
  
  // Getter mode: return {fg, bg}
  if (typeof fgColor === 'undefined') {
    var style = safeGet(window.styleBuffer, y, x);
    return style ? { fg: style.color, bg: style.bgcolor } : undefined;
  }
  
  // Build style object
  var styleObj = {};
  if (typeof fgColor !== 'undefined') styleObj.color = fgColor;
  if (typeof bgColor !== 'undefined') styleObj.bgcolor = bgColor;
  
  // Span mode
  if (typeof count === 'number' && count > 1) {
    return pokeStyle(x, y, styleObj, count);
  }
  
  // Single cell
  return pokeStyle(x, y, styleObj);
};


function ensureBuffersAndRow(y) {
  if (!window.screenHeight) window.screenHeight = 25;
  if (!window.screenBuffer) window.screenBuffer = [];
  if (!window.styleBuffer) window.styleBuffer = [];
  if (!window.screenBuffer[y]) {
    window.screenBuffer[y] = new Array(32);
    for (var i = 0; i < 32; i++) window.screenBuffer[y][i] = ' ';
  }
  if (!window.styleBuffer[y]) {
    window.styleBuffer[y] = new Array(32);
    for (var i = 0; i < 32; i++) {
      window.styleBuffer[y][i] = {
        color: (window.currentStyle && window.currentStyle.color) || 37,
        bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
        bold: !!(window.currentStyle && window.currentStyle.bold),
        inverse: !!(window.currentStyle && window.currentStyle.inverse)
      };
    }
  }
}

function safeGet(arr, y, x) {
  if (!arr) return undefined;
  if (typeof y !== 'number' || typeof x !== 'number') return undefined;
  if (!arr[y]) return undefined;
  return arr[y][x];
}

// Remove existing ansi-fg-* and ansi-bg-* classes from el
function removeAnsiColorClasses(el) {
  if (!el || !el.classList) return;
  var toRemove = [];
  el.classList.forEach(function (c) {
    if (/^ansi-fg-\d+$/.test(c) || /^ansi-bg-\d+$/.test(c)) toRemove.push(c);
  });
  toRemove.forEach(function (c) { el.classList.remove(c); });
}

// New: setCellStyle(x,y, styleObj) updates styleBuffer and DOM (no char change)
window.setCellStyle = function (x, y, styleObj) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new Error('setCellStyle requires numeric x,y: setCellStyle(x,y, { color:.., bgcolor:.., bold:.., inverse:.. })');
  }
  ensureBuffersAndRow(y);
  var row = window.styleBuffer[y];
  if (!row[x]) {
    row[x] = {
      color: (window.currentStyle && window.currentStyle.color) || 37,
      bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
      bold: false,
      inverse: false
    };
  }
  // apply provided fields (only update provided keys)
  if (typeof styleObj.color !== 'undefined') row[x].color = styleObj.color;
  if (typeof styleObj.bgcolor !== 'undefined') row[x].bgcolor = styleObj.bgcolor;
  if (typeof styleObj.bold !== 'undefined') row[x].bold = !!styleObj.bold;
  if (typeof styleObj.inverse !== 'undefined') row[x].inverse = !!styleObj.inverse;

   // If prevCursor points here, update it so cursor restore won't clobber style
  //try {
  //  if (window.prevCursor && window.prevCursor.set && window.prevCursor.x === x && window.prevCursor.y === y) {
  //    window.prevCursor.style = Object.assign({}, row[x]);
  //  }
  //} catch (e) { /* ignore */ }

   // update DOM or fallback
  var domUpdated = updateDomCellInPlace(x, y);
  if (!domUpdated && typeof updateDisplay === 'function') {
    try { updateDisplay(); domUpdated = true; } catch (e) { /* ignore */ }
  }
  return domUpdated;
};

function validateCoords(x, y) {
  return (typeof x === 'number' && typeof y === 'number' && 
          x >= 0 && y >= 0 && x < screenWidth && y < screenHeight);
}

function safeGet(arr, y, x) {
  return (arr && arr[y]) ? arr[y][x] : undefined;
}

window.pokeCell = function(x, y, ch, styleObj) {
  // Fast coordinate validation only
  if (!validateCoords(x, y)) return false;
  
  // Handle parameter shifting: pokeCell(x, y, styleObj)
  if (typeof ch === 'object' && typeof styleObj === 'undefined') {
    styleObj = ch;
    ch = undefined;
  }
  
  // Getter mode: pokeCell(x, y) returns character
  if (typeof ch === 'undefined' && typeof styleObj === 'undefined') {
    return screenBuffer[y][x];
  }
  
  // Update character if provided
  if (typeof ch !== 'undefined') {
    screenBuffer[y][x] = (typeof ch === 'string') ? ch : String(ch)[0] || ' ';
  }
  
  // Update style if provided (direct access, no null checks needed)
  if (styleObj && typeof styleObj === 'object') {
    var style = styleBuffer[y][x];
    if (typeof styleObj.color !== 'undefined') style.color = styleObj.color;
    if (typeof styleObj.bgcolor !== 'undefined') style.bgcolor = styleObj.bgcolor;
    if (typeof styleObj.bold !== 'undefined') style.bold = !!styleObj.bold;
    if (typeof styleObj.inverse !== 'undefined') style.inverse = !!styleObj.inverse;
  }
  
  // Fast DOM update 
  updateDomCellInPlace(x, y);
  return true;
};

 
window.setCellStyle = window.setCellStyle; // already set above
window.poke = function (x, y, ch, styleObj) { return window.pokeCell(x, y, ch, styleObj); };
window.peek = function (x, y) { return safeGet(window.screenBuffer, y, x); };

function ensureRow(y) {
  if (!window.screenBuffer) window.screenBuffer = [];
  if (!window.styleBuffer) window.styleBuffer = [];
  if (!window.screenBuffer[y]) {
    window.screenBuffer[y] = new Array(32);
    for (var i = 0; i < 32; i++) window.screenBuffer[y][i] = ' ';
  }
  if (!window.styleBuffer[y]) {
    window.styleBuffer[y] = new Array(32);
    for (var i = 0; i < 32; i++) {
      window.styleBuffer[y][i] = {
        color: (window.currentStyle && window.currentStyle.color) || 37,
        bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
        bold: false,
        inverse: false
      };
    }
  }
}

function renderCellToDOM(x, y) {
  try {
    var elId = 'c' + y + '_' + x;
    var el = document.getElementById(elId);
    var ch = safeGet(window.screenBuffer, y, x);
    var style = safeGet(window.styleBuffer, y, x);
     // Normalize character for visible HTML
    var safeText;
    if (typeof ch === 'string') {
      if (ch === '\u00A0' || ch === ' ') safeText = '&nbsp;';
      else safeText = escapeHtml(ch);
    } else {
      safeText = '&nbsp;';
    }
     if (el) {
      // apply text
      el.innerHTML = safeText;
       // apply simple style hints
      if (style && style.inverse) {
        el.style.backgroundColor = '#fff';
        el.style.color = '#000';
      } else {
        el.style.backgroundColor = '';
        el.style.color = '';
      }
      el.style.fontWeight = style && style.bold ? 'bold' : '';
      return true;
    } else {
      // fallback: if an updateDisplay function exists, use it to re-render everything
      if (typeof updateDisplay === 'function') {
        try { updateDisplay(); return true; } catch (e) { /* fallthrough */ }
      }
      // else do nothing but return false to indicate DOM not updated in place
      return false;
    }
  } catch (e) {
    console.error('renderCellToDOM error:', e);
    return false;
  }
}

function escapeHtml(s) {
  return String(s).replace(/&/g, '&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function safeGet(arr, y, x) {
  if (!arr) return undefined;
  if (typeof y !== 'number' || typeof x !== 'number') return undefined;
  if (!arr[y]) return undefined;
  return arr[y][x];
}

// Main pokeCell: if ch is provided -> set; if not provided -> return current char
window.pokeCell = function (x, y, ch) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    throw new Error('pokeCell requires numeric x,y coordinates: pokeCell(x,y[,ch])');
  }
   // ensure buffers for that row exist
  if (!window.screenBuffer || !window.styleBuffer) {
    // best-effort: initialize minimal screen if missing
    if (!window.screenHeight) window.screenHeight = 30;
    if (!window.screenBuffer) window.screenBuffer = [];
    if (!window.styleBuffer) window.styleBuffer = [];
  }
  ensureRow(y);
   if (typeof ch === 'undefined') {
    // getter: return the stored character (may be undefined)
    return safeGet(window.screenBuffer, y, x);
  } else {
    // setter: accept only single-character strings (or NBSP)
    if (typeof ch !== 'string' || ch.length === 0) {
      // allow explicit NBSP code
      if (ch === '\u00A0') {
        // ok
      } else {
        // coerce to string and take first codepoint
        ch = String(ch)[0] || ' ';
      }
    }
    // store into buffer (row-major screenBuffer[y][x])
    window.screenBuffer[y][x] = ch;
     // ensure style exists for that cell
    if (!window.styleBuffer[y][x]) {
      window.styleBuffer[y][x] = {
        color: (window.currentStyle && window.currentStyle.color) || 37,
        bgcolor: (window.currentStyle && window.currentStyle.bgcolor) || 40,
        bold: false,
        inverse: false
      };
    }
     // update DOM cell if possible
    var ok = renderCellToDOM(x, y);
     // if DOM cell wasn't found or render failure, try full redraw updateDisplay if available
    if (!ok && typeof updateDisplay === 'function') {
      try { updateDisplay(); ok = true; } catch (e) { /* ignore */ }
    }
     return ok;
  }
};

// Provide PEEK/POKE proxies for linear addressing: addr = y*screenWidth + x
function addrToXY(addr) {
  var y = Math.floor(addr / 32);
  var x = addr - (y * 32);
  return { x: x, y: y };
}

// PEEK proxy (read-only)
window.PEEK = new Proxy({}, {
  get: function (target, prop) {
    var a = Number(prop);
    if (isNaN(a)) return undefined;
    var p = addrToXY(a);
    return safeGet(window.screenBuffer, p.y, p.x);
  },
  has: function() { return true; }
});

// POKE proxy (write)
window.POKE = new Proxy({}, {
  set: function (target, prop, value) {
    var a = Number(prop);
    if (isNaN(a)) {
      // ignore non-numeric props
      target[prop] = value;
      return true;
    }
    var p = addrToXY(a);
    try {
      // call our pokeCell setter
      window.pokeCell(p.x, p.y, value);
    } catch (e) {
      console.error('POKE set error for addr', a, e);
    }
    return true;
  },
  get: function(target, prop) {
    var a = Number(prop);
    if (isNaN(a)) return undefined;
    var p = addrToXY(a);
    return safeGet(window.screenBuffer, p.y, p.x);
  }
});
 
// Usage examples (console):
//   peekCell(10,5)        // returns object with character, codepoint, style, DOM info
//   peekAddr(350)         // converts linear addr -> (x,y) then returns same object
//   peekLog(10,5)         // prints a one-line summary + full object

function peekCell(x,y) {
  // avoid clobbering if already installed
  if (window.peekCellInstalled) return;
  window.peekCellInstalled = true;

  function safeGet(arr, y, x) {
    if (!arr) return undefined;
    if (typeof y !== 'number' || typeof x !== 'number') return undefined;
    if (!arr[y]) return undefined;
    return arr[y][x];
  }

  function normChar(ch) {
    if (typeof ch !== 'string') return { raw: ch, display: String(ch) };
    if (ch === '\u00A0') return { raw: ch, display: '<NBSP>' };
    if (ch === '\n') return { raw: ch, display: '<LF>' };
    if (ch === '\r') return { raw: ch, display: '<CR>' };
    if (ch.length === 0) return { raw: ch, display: '<EMPTY>' };
    var cp = ch.codePointAt(0);
    if (cp < 32 || (cp >= 0x7F && cp <= 0x9F)) {
      return { raw: ch, display: '<CTRL U+' + cp.toString(16).toUpperCase().padStart(4, '0') + '>' };
    }
  }
}

function cursorMoveTo(nx, ny) {
  const old = { x: cursorX, y: cursorY };
  cursorX = Math.max(0, Math.min(screenWidth - 1, nx));
  cursorY = Math.max(0, Math.min(screenHeight - 1, ny));
  if (cursorOn) {
    // restore old cell
    //if (prevCursor.set && styleBuffer[old.y] && styleBuffer[old.y][old.x]) {
    //  styleBuffer[old.y][old.x].inverse = prevCursor.inverse;
    //  pokeCell(old.x, old.y);
    //}
    // mark new one
    if (!styleBuffer[cursorY]) {
      styleBuffer[cursorY] = [];
      for (let x = 0; x < screenWidth; x++) {
        styleBuffer[cursorY][x] = {
          color: currentStyle.color,
          bgcolor: currentStyle.bgcolor,
          bold: currentStyle.bold,
          inverse: currentStyle.inverse
        };
      }
    }
    // prevCursor = { set: true, x: cursorX, y: cursorY, inverse: !!styleBuffer[cursorY][cursorX].inverse };
    pokeInverse(old.x, old.y, false);
    pokeInverse(cursorX, cursorY, true);
  } else {
    // cursor isn't shown  just update logical coords
  }
}

function cls() { 
  const defaultColor = (currentStyle && currentStyle.color) ? currentStyle.color : 37;
  const defaultBg    = (currentStyle && currentStyle.bgcolor) ? currentStyle.bgcolor : 40;
  const clearStyle   = { color: defaultColor, bgcolor: defaultBg, bold: false, inverse: false };
  for (let y = 0; y < screenHeight; y++) {
    pokeChar(0, y, ' ', screenWidth);
    pokeStyle(0, y, clearStyle, screenWidth);
  }
  cursorX = 0;
  cursorY = 0;
  try { document.querySelectorAll('.qandy-cursor').forEach(el => el.classList.remove('qandy-cursor')); } catch (e) {}
}

// system ready

function clearScreen() { cls(); }

window.ANSI=ANSI;
print("\nQandy Pocket\nComputer v1.j\n\n");
cursor(1); 

// Record where the input prompt starts after boot message
inputStartX = cursorX;
inputStartY = cursorY;

SFiles=1;
mySearch=location.search.substr(1).split("&")
for (i=0;i<mySearch.length;i++) {
 nameVal=mySearch[i].split("=");
 for (j in nameVal) { nameVal[j]=unescape(nameVal[j]); } 
 if (nameVal[0]=="run") {
  script=document.createElement('script');
  script.src=nameVal[1];
  document.head.appendChild(script);
  SFiles=0;
 }
}

// if (SFiles) { showFiles(); }

</script></body></html>