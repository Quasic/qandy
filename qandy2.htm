<!DOCTYPE html>
<html><head>
<link rel="stylesheet" type="text/css" href="qandy.css">
</head><body><p><br>
<div id=txt class="txt"></div>
<div id="pop" class="pop" onMouseOver='PopUpVis="visible";' onMouseOut='PopUpVis=PForce; PUV=setTimeout("document.getElementById(\"pop\").style.visibility=PopUpVis;",100);'></div>
<div id="keyboard-container"></div>

<script>
var devteam=1;  // developer mode
var run="";
var txt="";
var mode="txt"; // gfx or txt display

var caps=0;  // caps lock state: 0=lowercase, 1=uppercase, 2=extended graphics
var shift=0; // shift key pressed  
var ctrl=0;  // ctrl key pressed
var alt=0;   // alt key pressed
var ctrlPhysical=false;  // track if ctrl was activated by physical keyboard
var altPhysical=false;   // track if alt was activated by physical keyboard
var keyon=1; // turn keyboard input on/off

// Normal character mapping for lowercase (caps level 0)
// User can edit these to customize keyboard layout
var normalKeys = {
  '1': '1', '2': '2', '3': '3', '4': '4', '5': '5',
  '6': '6', '7': '7', '8': '8', '9': '9', '0': '0',
  'q': 'q', 'w': 'w', 'e': 'e', 'r': 'r', 't': 't',
  'y': 'y', 'u': 'u', 'i': 'i', 'o': 'o', 'p': 'p',
  'a': 'a', 's': 's', 'd': 'd', 'f': 'f', 'g': 'g',
  'h': 'h', 'j': 'j', 'k': 'k', 'l': 'l',
  'z': 'z', 'x': 'x', 'c': 'c', 'v': 'v', 'b': 'b',
  'n': 'n', 'm': 'm',
  '[': '[', ']': ']', ';': ';', '\'': '\'',
  ',': ',', '.': '.', '/': '/', '=': '=', '-': '-',
  '\\': '\\', '`': '`'
};

// Shifted character mapping for uppercase and symbols (caps level 1)
// User can edit these to customize shifted key behavior
var shiftedKeys = {
  '1': '!', '2': '@', '3': '#', '4': '$', '5': '%',
  '6': '^', '7': '&', '8': '*', '9': '(', '0': ')',
  'q': 'Q', 'w': 'W', 'e': 'E', 'r': 'R', 't': 'T',
  'y': 'Y', 'u': 'U', 'i': 'I', 'o': 'O', 'p': 'P',
  'a': 'A', 's': 'S', 'd': 'D', 'f': 'F', 'g': 'G',
  'h': 'H', 'j': 'J', 'k': 'K', 'l': 'L',
  'z': 'Z', 'x': 'X', 'c': 'C', 'v': 'V', 'b': 'B',
  'n': 'N', 'm': 'M',
  '[': '{', ']': '}', ';': ':', '\'': '"',
  ',': '<', '.': '>', '/': '?', '=': '+', '-': '_',
  '\\': '|', '`': '~'
};

// Extended graphic character mapping for caps level 2
// User can edit these to customize extended characters for ASCII/ANSI art
var extendedChars = {
  'q': '┌', 'w': '┬', 'e': '┐', 'r': '─', 't': '╔',
  'a': '├', 's': '┼', 'd': '┤', 'f': '│', 'g': '╠',
  'z': '└', 'x': '┴', 'c': '┘', 'v': '╚', 'b': '╝',
  'y': '╦', 'u': '╗', 'i': '═', 'o': '╣',
  'h': '╬', 'j': '╩', 'k': '║', 'l': '▬',
  'n': '▀', 'm': '▄',
  'p': '●', '1': '↑', '2': '↓', '3': '←', '4': '→',
  '5': '■', '6': '□', '7': '◆', '8': '○',
  '9': '★', '0': '☆', '[': '♠', ']': '♥',
  ';': '♦', '\'': '♣', ',': '✓', '.': '✗',
  '/': '÷', '=': '×', '-': '±', ' ': '·',
  '\\': '¦', '`': '`'
};
var line=""; // input text line
var cursorPos=0; // cursor position in input line for editing
var inputScrollPos=0; // starting position of visible input window

// Command history support (like Linux terminal)
var commandHistory = [];  // Array to store command history
var historyIndex = -1;    // Current position in history (-1 = not browsing, typing new command)
var maxHistorySize = 50;  // Maximum number of commands to remember
var tempCommand = "";     // Temporary storage for command being typed when browsing history

// Text selection state
var selectionStart = -1;  // Start position of selection (-1 = no selection)
var selectionEnd = -1;    // End position of selection
var selectionBgColor = '#ffffff';   // Selection background color
var selectionFgColor = '#000000';   // Selection text color

var screenBuffer = [];
var cursorX = 0;
var cursorY = 0;
var screenWidth = 32;
var screenHeight = 25;

// Pagination support for overflow text
var paginationEnabled = true;  // Enable/disable pagination feature
var paginationPaused = false;  // Is print() currently paused?
var paginationBuffer = [];     // Queued text waiting to be printed
var paginationLinesBeforePause = 22;  // Lines to show before pausing

var styleBuffer = [];
var currentStyle = {
  color: 37,      // white foreground
  bgcolor: 40,    // black background
  bold: false,
  inverse: false
};

var PopX=0;
var PopY=0;
var PopHide="hidden";
var PopAlign="center";
var PForce="hidden";
var mapx=7;
var mapy=11;
var map="";

// Keyboard data structure - array of key objects
var keyboardData = [
  // Row 0: ESC, BACKTICK, BACKSLASH, OPEN, CLOSE, DASH, EQUAL, BACK (y=446)
  {id:"esc", label:"ESC", keyCode:27, x:47, y:446, width:52},
  {id:"backtick", label:"`", keyCode:192, x:103, y:446, width:28},
  {id:"backslash", label:"\\", keyCode:220, x:132, y:446, width:28},
  {id:"open", label:"[", keyCode:219, x:160, y:446, width:28},
  {id:"close", label:"]", keyCode:221, x:189, y:446, width:28},
  {id:"dash", label:"-", keyCode:173, x:218, y:446, width:28},
  {id:"equal", label:"=", keyCode:61, x:247, y:446, width:28},
  {id:"back", label:"BACK", keyCode:8, x:275, y:446, width:52},
  // Row 1: Number keys 1-0 (y=480)
  {id:"n1", label:"1", keyCode:49, x:47, y:480, width:28},
  {id:"n2", label:"2", keyCode:50, x:75, y:480, width:28},
  {id:"n3", label:"3", keyCode:51, x:103, y:480, width:28},
  {id:"n4", label:"4", keyCode:52, x:132, y:480, width:28},
  {id:"n5", label:"5", keyCode:53, x:160, y:480, width:28},
  {id:"n6", label:"6", keyCode:54, x:189, y:480, width:28},
  {id:"n7", label:"7", keyCode:55, x:218, y:480, width:28},
  {id:"n8", label:"8", keyCode:56, x:247, y:480, width:28},
  {id:"n9", label:"9", keyCode:57, x:275, y:480, width:28},
  {id:"n0", label:"0", keyCode:48, x:303, y:480, width:28},
  // Row 2: QWERTY (y=511)
  {id:"q", label:"q", keyCode:81, x:47, y:511, width:28},
  {id:"w", label:"w", keyCode:87, x:75, y:511, width:28},
  {id:"e", label:"e", keyCode:69, x:103, y:511, width:28},
  {id:"r", label:"r", keyCode:82, x:132, y:511, width:28},
  {id:"t", label:"t", keyCode:84, x:160, y:511, width:28},
  {id:"y", label:"y", keyCode:89, x:189, y:511, width:28},
  {id:"u", label:"u", keyCode:85, x:218, y:511, width:28},
  {id:"i", label:"i", keyCode:73, x:247, y:511, width:28},
  {id:"o", label:"o", keyCode:79, x:275, y:511, width:28},
  {id:"p", label:"p", keyCode:80, x:303, y:511, width:28},
  // Row 3: ASDF (y=542)
  {id:"a", label:"a", keyCode:65, x:47, y:542, width:28},
  {id:"s", label:"s", keyCode:83, x:75, y:542, width:28},
  {id:"d", label:"d", keyCode:68, x:103, y:542, width:28},
  {id:"f", label:"f", keyCode:70, x:132, y:542, width:28},
  {id:"g", label:"g", keyCode:71, x:160, y:542, width:28},
  {id:"h", label:"h", keyCode:72, x:189, y:542, width:28},
  {id:"j", label:"j", keyCode:74, x:218, y:542, width:28},
  {id:"k", label:"k", keyCode:75, x:247, y:542, width:28},
  {id:"l", label:"l", keyCode:76, x:275, y:542, width:28},
  {id:"quote", label:"'", keyCode:222, x:303, y:542, width:28},
  // Row 4: ZXCV (y=573)
  {id:"z", label:"z", keyCode:90, x:47, y:573, width:28},
  {id:"x", label:"x", keyCode:88, x:75, y:573, width:28},
  {id:"c", label:"c", keyCode:67, x:103, y:573, width:28},
  {id:"v", label:"v", keyCode:86, x:132, y:573, width:28},
  {id:"b", label:"b", keyCode:66, x:160, y:573, width:28},
  {id:"n", label:"n", keyCode:78, x:189, y:573, width:28},
  {id:"m", label:"m", keyCode:77, x:218, y:573, width:28},
  {id:"colon", label:";", keyCode:59, x:247, y:573, width:28},
  {id:"enter", label:"ENTER", keyCode:13, x:275, y:573, width:52},

  // Row 5: Bottom row with modifiers (y=604)
  {id:"caps", label:"CAPS", keyCode:20, x:47, y:604, width:52},
  {id:"space", label:"SPACE", keyCode:32, x:103, y:604, width:81},
  {id:"ctrl", label:"CTRL", keyCode:17, x:189, y:604, width:28},
  {id:"alt", label:"ALT", keyCode:18, x:218, y:604, width:28},
  {id:"comma", label:",", keyCode:188, x:247, y:604, width:28},
  {id:"dot", label:".", keyCode:190, x:275, y:604, width:28},
  {id:"slash", label:"/", keyCode:191, x:303, y:604, width:28}
];

// safe to delete these?
//var pop4="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9cKHRUjLyS5OncAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAC5JREFUeNrtzkEBAAAEBDD0z6nGieGzJVgn2Xo09UxAQEBAQEBAQEBAQEBAQOAAuq4EI/9axwQAAAAASUVORK5CYII=";
//var k64="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAaCAYAAABGiCfwAAAACXBIWXMAAAsSAAALEgHS3X78AAAAKElEQVRIie3NMQEAAAgDILV/51nBywsK0Enqy7xNMplMJpPJZDLZ0QI7tAMxEF7bywAAAABJRU5ErkJggg==";
//var l64="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAAAYCAYAAAC1Ft6mAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAOklEQVRYhe3PgQkAIRDAsPf33/lcQrBIMkG7ZuZ7yX874DRDdYbqDNUZqjNUZ6jOUJ2hOkN1huoM1W10mgMt7zY1rwAAAABJRU5ErkJggg==";
//var m64="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG0AAAAYCAYAAADwF3MkAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAVUlEQVRoge3RwQkAIBDAMHX/nc8ZfEkhmaDQPTOLlvM7gHemBZkWZFqQaUGmBZkWZFqQaUGmBZkWZFqQaUGmBZkWZFqQaUGmBZkWZFqQaUGmBZkWdAFuuAMtk7qVEgAAAABJRU5ErkJggg==";

img=document.createElement('img');
img.id="qpc"; img.src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAMklEQVRYhe3OMQEAMAjEwKei2wHxRQbLxUCu3u2fxc7mHAAAAAAAAAAAAAAAAAAAIEkGzIgCpxq6s7YAAAAASUVORK5CYII="; 
img.style.width="300px"; img.style.height="600px"; img.style.zIndex="0"; 
img.style.position="absolute";
document.body.appendChild(img);

initKeyboard(); function initKeyboard() {
 // Create keyboard buttons dynamically from keyboard data array
 keyboardData.forEach(function(key) {
  var btn = document.createElement('div');
  btn.id = key.id;
  btn.innerHTML = key.label;
  
  // Assign appropriate CSS class based on width
  if (key.width === 28) {
   btn.className = 'k1';
  } else if (key.width === 40) {
   // Check if it's the ENTER key specifically
   if (key.id === 'enter') {
    btn.className = 'k-enter';  // ENTER key
   } else {
    btn.className = 'k-ctrl';  // CAPS key and other 40px keys
   }
  } else if (key.width === 52) {
   btn.className = 'k2';
  } else if (key.width === 81) {
   btn.className = 'k-space';  // SPACE key
  } else if (key.width === 109) {
   btn.className = 'k4';
  }
  
  // Set explicit width for custom-sized keys
  if (key.width === 40 || key.width === 81) {
   btn.style.width = key.width + 'px';
  }
  
  // Reduce font size for CTRL and ALT keys to fit text better
  if (key.id === 'ctrl' || key.id === 'alt') {
   btn.style.fontSize = '9px';
  }
  
  // Position the button
  btn.style.left = key.x + 'px';
  btn.style.top = key.y + 'px';
  
  // Add click handler
  btn.onclick = function() { button(key.keyCode); };
  
  // Append to keyboard container
  document.getElementById('keyboard-container').appendChild(btn);
 });
 
 // Position the QPC and other elements
 document.getElementById("qpc").style.top = "32px"; 
 document.getElementById("qpc").style.left = "32px";
}

// Create a mapping from keyCode to element ID for quick lookup
var keyCodeToId = {};
keyboardData.forEach(function(key) {
  keyCodeToId[key.keyCode] = key.id;
});

// Store timeout IDs for each key to handle rapid key presses
var keyTimeouts = {};

// Function to highlight a virtual key
function highlightKey(keyCode) {
  var elementId = keyCodeToId[keyCode];
  if (!elementId) return; // Key not in virtual keyboard
  
  var element = document.getElementById(elementId);
  if (!element) return; // Element not found
  
  // Clear any existing timeout for this key to prevent race conditions
  if (keyTimeouts[elementId]) {
    clearTimeout(keyTimeouts[elementId]);
  }
  
  // Apply hover effect (using the same color as :hover in CSS)
  element.style.backgroundColor = '#444';
  
  // Set a timeout to restore original color
  keyTimeouts[elementId] = setTimeout(function() {
    unhighlightKey(elementId);
    delete keyTimeouts[elementId]; // Clean up timeout reference
  }, 200); // 200ms flash effect
}

// Function to unhighlight a virtual key
function unhighlightKey(elementId) {
  var element = document.getElementById(elementId);
  if (!element) return;
  
  // Restore original background by clearing inline style
  // This allows CSS stylesheet rules to take effect again
  element.style.backgroundColor = '';
}

tiles(); function tiles() {
 Z=0;
 for (Y=0; Y<=mapy; Y++) {
  for (X=0; X<=mapx; X++) {
   T=document.createElement("img");
   T.id="T"+Z; T.src="t/Ga.png"; 
   T.height=32; T.width=32;
   T.className="tile";
   T.onmousedown=new Function("ClickTile("+(Z)+",this.parentNode)");     
   document.body.appendChild(T);
   Z++;
  }
 }
}

resize(); function resize() {
 // Position text element based on mode
 if (mode=="gfx") {
  up=32+(404-(document.getElementById('txt').offsetHeight));
  left=32+22+300;
  document.getElementById("txt").style.left=left+"px";
  document.getElementById("txt").style.top=up+"px";
 } else {
  left=32+22;
  up=32+(402-(document.getElementById('txt').offsetHeight));
  document.getElementById("txt").style.left="54px";
  document.getElementById("txt").style.top=up+"px";
 }
 const textElement=document.getElementById("txt");
 textElement.scrollTop=textElement.scrollHeight;
 Z=0; for (Y=0; Y<=mapy; Y++) {
  for (X=0; X<=mapx; X++) {
   e=document.getElementById("T"+Z).style.top=50+(Y*32)+"px";  
   e=document.getElementById("T"+Z).style.left=54+(X*32)+"px"; 
   Z++;
  }
 }
}

document.addEventListener('keydown', function () { press(); });
document.addEventListener('keyup', function () { pressup(); });
document.addEventListener('paste', function (event) {
 if (keyon) {
  event.preventDefault();
  var pastedText;
  if (event.clipboardData && event.clipboardData.getData) {
   pastedText = event.clipboardData.getData('text/plain');
  } else if (window.clipboardData && window.clipboardData.getData) {
   pastedText = window.clipboardData.getData('Text');
  }
  if (pastedText) {
   line += pastedText;
   cursorPos = line.length; // Update cursor position to end
   updateDisplay();
   // Scroll to bottom to show cursor
   const textElement = document.getElementById("txt");
   textElement.scrollTop = textElement.scrollHeight;
  }
 }
});
function press() { 
 key=""; k=event.keyCode; shift=event.shiftKey;
 
 // Handle physical CTRL key press (highlight while pressed)
 if (event.keyCode === 17 && !ctrl) {
  ctrl = 1;
  ctrlPhysical = true;
  document.getElementById("ctrl").style.backgroundColor = "#0a0";
  document.getElementById("ctrl").style.color = "#000";
  return;
 }
 
 // Handle physical ALT key press (highlight while pressed)
 if (event.keyCode === 18 && !alt) {
  event.preventDefault(); // Prevent browser menu from opening
  alt = 1;
  altPhysical = true;
  document.getElementById("alt").style.backgroundColor = "#0a0";
  document.getElementById("alt").style.color = "#000";
  return;
 }
 
 // Handle Ctrl+C for copy
 if (event.ctrlKey && event.key === 'c') {
  event.preventDefault();
  if (selectionStart !== -1 && selectionEnd !== -1) {
   const start = Math.min(selectionStart, selectionEnd);
   const end = Math.max(selectionStart, selectionEnd);
   const selectedText = line.substring(start, end);
   navigator.clipboard.writeText(selectedText).then(() => {
    print("\x1b[32mCopied to clipboard!\x1b[0m\n");
   }).catch(err => {
    print("\x1b[31mCopy failed\x1b[0m\n");
   });
  } else if (line.length > 0) {
   // Copy entire line if no selection
   navigator.clipboard.writeText(line).then(() => {
    print("\x1b[32mCopied entire input to clipboard!\x1b[0m\n");
   }).catch(err => {
    print("\x1b[31mCopy failed\x1b[0m\n");
   });
  }
  return;
 }
 
 // Don't handle keydown if Ctrl is pressed (let paste event handle it)
 if (event.ctrlKey) { return; }
 
 // Highlight the virtual key for visual feedback
 highlightKey(k);
 
 button(k);
}

function pressup() {
 // Handle physical CTRL key release (unhighlight)
 if (event.keyCode === 17 && ctrlPhysical) {
  ctrl = 0;
  ctrlPhysical = false;
  document.getElementById("ctrl").style.backgroundColor = "#222";
  document.getElementById("ctrl").style.color = "#fff";
  return;
 }
 
 // Handle physical ALT key release (unhighlight)
 if (event.keyCode === 18 && altPhysical) {
  alt = 0;
  altPhysical = false;
  document.getElementById("alt").style.backgroundColor = "#222";
  document.getElementById("alt").style.color = "#fff";
  return;
 }
 
 // Route keyup to active script if run is set
 if (run && typeof keyup !== 'undefined') {
  var k = String.fromCharCode(event.keyCode);
  keyup(k);
 }
}

function button(b) {
 // Handle pagination resume - any key continues
 if (paginationPaused) {
   resumePagination();
   return;
 }
 
 k=""; l=""; switch (b) {
  case 17: k="ctrl"; break;   // CTRL key
  case 18: k="alt"; break;    // ALT key  
  case 37: k="left"; break;
  case 38: k="up"; break;
  case 39: k="right"; break;
  case 40: k="down"; break;
  case 36: k="home"; break;
  case 35: k="end"; break;
  case 27: k="esc"; break;
  case 13: k="enter"; break;
  case  8: k="back"; break;
  case 46: k="delete"; break;
  case 20: k="caps"; break;
  case 49: if (shift||caps===1) { k="!"; l=k; } else if (caps===2) { l=extendedChars['1']; k=l; } else { k="1"; l=k; } break;  
  case 50: if (shift||caps===1) { k="@"; l=k; } else if (caps===2) { l=extendedChars['2']; k=l; } else { k="2"; l=k; } break;  
  case 51: if (shift||caps===1) { k="#"; l=k; } else if (caps===2) { l=extendedChars['3']; k=l; } else { k="3"; l=k; } break;  
  case 52: if (shift||caps===1) { k="$"; l=k; } else if (caps===2) { l=extendedChars['4']; k=l; } else { k="4"; l=k; } break;  
  case 53: if (shift||caps===1) { k="%"; l=k; } else if (caps===2) { l=extendedChars['5']; k=l; } else { k="5"; l=k; } break;  
  case 54: if (shift||caps===1) { k="^"; l=k; } else if (caps===2) { l=extendedChars['6']; k=l; } else { k="6"; l=k; } break;  
  case 55: if (shift||caps===1) { k="&"; l=k; } else if (caps===2) { l=extendedChars['7']; k=l; } else { k="7"; l=k; } break;
  case 56: if (shift||caps===1) { k="*"; l=k; } else if (caps===2) { l=extendedChars['8']; k=l; } else { k="8"; l=k; } break;
  case 57: if (shift||caps===1) { k="("; l=k; } else if (caps===2) { l=extendedChars['9']; k=l; } else { k="9"; l=k; } break;
  case 48: if (shift||caps===1) { k=")"; l=k; } else if (caps===2) { l=extendedChars['0']; k=l; } else { k="0"; l=k; } break;
  case 81: if (shift||caps===1) { k="Q"; l=k; } else if (caps===2) { l=extendedChars['q']; k=l; } else { k="q"; l=k; } break; 
  case 87: if (shift||caps===1) { k="W"; l=k; } else if (caps===2) { l=extendedChars['w']; k=l; } else { k="w"; l=k; } break; 
  case 69: if (shift||caps===1) { k="E"; l=k; } else if (caps===2) { l=extendedChars['e']; k=l; } else { k="e"; l=k; } break; 
  case 82: if (shift||caps===1) { k="R"; l=k; } else if (caps===2) { l=extendedChars['r']; k=l; } else { k="r"; l=k; } break; 
  case 84: if (shift||caps===1) { k="T"; l=k; } else if (caps===2) { l=extendedChars['t']; k=l; } else { k="t"; l=k; } break; 
  case 89: if (shift||caps===1) { k="Y"; l=k; } else if (caps===2) { l=extendedChars['y']; k=l; } else { k="y"; l=k; } break; 
  case 85: if (shift||caps===1) { k="U"; l=k; } else if (caps===2) { l=extendedChars['u']; k=l; } else { k="u"; l=k; } break; 
  case 73: if (shift||caps===1) { k="I"; l=k; } else if (caps===2) { l=extendedChars['i']; k=l; } else { k="i"; l=k; } break; 
  case 79: if (shift||caps===1) { k="O"; l=k; } else if (caps===2) { l=extendedChars['o']; k=l; } else { k="o"; l=k; } break; 
  case 80: if (shift||caps===1) { k="P"; l=k; } else if (caps===2) { l=extendedChars['p']; k=l; } else { k="p"; l=k; } break; 
  case 65: if (shift||caps===1) { k="A"; l=k; } else if (caps===2) { l=extendedChars['a']; k=l; } else { k="a"; l=k; } break; 
  case 83: if (shift||caps===1) { k="S"; l=k; } else if (caps===2) { l=extendedChars['s']; k=l; } else { k="s"; l=k; } break; 
  case 68: if (shift||caps===1) { k="D"; l=k; } else if (caps===2) { l=extendedChars['d']; k=l; } else { k="d"; l=k; } break; 
  case 70: if (shift||caps===1) { k="F"; l=k; } else if (caps===2) { l=extendedChars['f']; k=l; } else { k="f"; l=k; } break; 
  case 71: if (shift||caps===1) { k="G"; l=k; } else if (caps===2) { l=extendedChars['g']; k=l; } else { k="g"; l=k; } break; 
  case 72: if (shift||caps===1) { k="H"; l=k; } else if (caps===2) { l=extendedChars['h']; k=l; } else { k="h"; l=k; } break; 
  case 74: if (shift||caps===1) { k="J"; l=k; } else if (caps===2) { l=extendedChars['j']; k=l; } else { k="j"; l=k; } break; 
  case 75: if (shift||caps===1) { k="K"; l=k; } else if (caps===2) { l=extendedChars['k']; k=l; } else { k="k"; l=k; } break; 
  case 76: if (shift||caps===1) { k="L"; l=k; } else if (caps===2) { l=extendedChars['l']; k=l; } else { k="l"; l=k; } break; 
  case 90: if (shift||caps===1) { k="Z"; l=k; } else if (caps===2) { l=extendedChars['z']; k=l; } else { k="z"; l=k; } break; 
  case 88: if (shift||caps===1) { k="X"; l=k; } else if (caps===2) { l=extendedChars['x']; k=l; } else { k="x"; l=k; } break; 
  case 67: if (shift||caps===1) { k="C"; l=k; } else if (caps===2) { l=extendedChars['c']; k=l; } else { k="c"; l=k; } break; 
  case 86: if (shift||caps===1) { k="V"; l=k; } else if (caps===2) { l=extendedChars['v']; k=l; } else { k="v"; l=k; } break; 
  case 66: if (shift||caps===1) { k="B"; l=k; } else if (caps===2) { l=extendedChars['b']; k=l; } else { k="b"; l=k; } break; 
  case 78: if (shift||caps===1) { k="N"; l=k; } else if (caps===2) { l=extendedChars['n']; k=l; } else { k="n"; l=k; } break;  
  case 77: if (shift||caps===1) { k="M"; l=k; } else if (caps===2) { l=extendedChars['m']; k=l; } else { k="m"; l=k; } break;
  case  61: if (shift||caps===1) { k="equal"; l="+"; } else if (caps===2) { k="equal"; l=extendedChars['=']; } else { k="="; l=k; } break; 
  case 191: if (shift||caps===1) { k="slash"; l="?"; } else if (caps===2) { k="slash"; l=extendedChars['/']; } else { k="/"; l=k; } break; 
  case  59: if (shift||caps===1) { k="colon"; l=":"; } else if (caps===2) { k="colon"; l=extendedChars[';']; } else { k=";"; l=k; } break; 
  case 222: if (shift||caps===1) { k="quote"; l="\""; } else if (caps===2) { k="quote"; l=extendedChars['\'']; } else { k="\'"; l=k; } break; 
  case  32: if (shift||caps===1) { k="space"; l=" "; } else if (caps===2) { k="space"; l=extendedChars[' ']; } else { k=" "; l=k; } break;
  case 188: if (shift||caps===1) { k="comma"; l="<"; } else if (caps===2) { k="comma"; l=extendedChars[',']; } else { k=","; l=k; } break;
  case 190: if (shift||caps===1) { k="dot";   l=">"; } else if (caps===2) { k="dot"; l=extendedChars['.']; } else { k="."; l=k; } break;
  case 173: if (shift||caps===1) { k="dash";  l="_"; } else if (caps===2) { k="dash"; l=extendedChars['-']; } else { k="-"; l=k; } break;
  case 219: if (shift||caps===1) { k="open";  l="{"; } else if (caps===2) { k="open"; l=extendedChars['[']; } else { k="["; l=k; } break;
  case 221: if (shift||caps===1) { k="close"; l="}"; } else if (caps===2) { k="close"; l=extendedChars[']']; } else { k="]"; l=k; } break;
  case 192: if (shift||caps===1) { k="backtick"; l="~"; } else if (caps===2) { k="backtick"; l=extendedChars['`']; } else { k="`"; l=k; } break;
  case 220: if (shift||caps===1) { k="backslash"; l="|"; } else if (caps===2) { k="backslash"; l=extendedChars['\\']; } else { k="\\"; l=k; } break;  
 }
 if (k==="esc") {
  // Universal ESC handler: terminate any running script and return to OS
  if (run) {
   // Script is running - terminate it
   run = "";
   if (typeof document !== 'undefined' && document.getElementById("run")) {
    document.getElementById("run").innerHTML = run;
   }
   // Clear screen and show termination message
   cls();
   print("\x1b[1;33m[Script terminated by ESC key]\x1b[0m\n\n");
   // Prevent key from being passed to the terminated script
   k = "";
  }
  // If no script running, ESC does nothing (old screen toggle removed)
 } else if (k==="ctrl") {
  // Toggle ctrl key state
  ctrl = ctrl ? 0 : 1;
  if (ctrl) {
   document.getElementById("ctrl").style.backgroundColor = "#0a0";
   document.getElementById("ctrl").style.color = "#000";
  } else {
   document.getElementById("ctrl").style.backgroundColor = "#222";
   document.getElementById("ctrl").style.color = "#fff";
  }
 } else if (k==="alt") {
  // Toggle alt key state
  alt = alt ? 0 : 1;
  if (alt) {
   document.getElementById("alt").style.backgroundColor = "#0a0";
   document.getElementById("alt").style.color = "#000";
  } else {
   document.getElementById("alt").style.backgroundColor = "#222";
   document.getElementById("alt").style.color = "#fff";
  }
 } else {
  if (k==="caps") {
   // Cycle through three states: 0 (lowercase) -> 1 (uppercase) -> 2 (extended graphics)
   // The modulo operation wraps from 2 back to 0
   caps = (caps + 1) % 3;
   
   // Update all key labels based on caps lock state
   if (caps === 0) {
    // Lowercase
    document.getElementById("open").innerHTML = "[";
    document.getElementById("close").innerHTML = "]";
    document.getElementById("n1").innerHTML = "1";
    document.getElementById("n2").innerHTML = "2";
    document.getElementById("n3").innerHTML = "3";
    document.getElementById("n4").innerHTML = "4";
    document.getElementById("n5").innerHTML = "5";
    document.getElementById("n6").innerHTML = "6";
    document.getElementById("n7").innerHTML = "7";
    document.getElementById("n8").innerHTML = "8";
    document.getElementById("n9").innerHTML = "9";
    document.getElementById("n0").innerHTML = "0";
    document.getElementById("q").innerHTML = "q";
    document.getElementById("w").innerHTML = "w";
    document.getElementById("e").innerHTML = "e";
    document.getElementById("r").innerHTML = "r";
    document.getElementById("t").innerHTML = "t";
    document.getElementById("y").innerHTML = "y";
    document.getElementById("u").innerHTML = "u";
    document.getElementById("i").innerHTML = "i";
    document.getElementById("o").innerHTML = "o";
    document.getElementById("p").innerHTML = "p";
    document.getElementById("a").innerHTML = "a";
    document.getElementById("s").innerHTML = "s";
    document.getElementById("d").innerHTML = "d";
    document.getElementById("f").innerHTML = "f";
    document.getElementById("g").innerHTML = "g";
    document.getElementById("h").innerHTML = "h";
    document.getElementById("j").innerHTML = "j";
    document.getElementById("k").innerHTML = "k";
    document.getElementById("l").innerHTML = "l";
    document.getElementById("z").innerHTML = "z";
    document.getElementById("x").innerHTML = "x";
    document.getElementById("c").innerHTML = "c";
    document.getElementById("v").innerHTML = "v";
    document.getElementById("b").innerHTML = "b";
    document.getElementById("n").innerHTML = "n";
    document.getElementById("m").innerHTML = "m";
    document.getElementById("equal").innerHTML = "=";
    document.getElementById("slash").innerHTML = "/";
    document.getElementById("colon").innerHTML = ";";
    document.getElementById("quote").innerHTML = "'";
    document.getElementById("comma").innerHTML = ",";
    document.getElementById("dot").innerHTML = ".";
    document.getElementById("dash").innerHTML = "-";
    document.getElementById("backtick").innerHTML = "`";
    document.getElementById("backslash").innerHTML = "\\";
    document.getElementById("caps").style.backgroundColor = "#222";
    document.getElementById("caps").style.color = "#fff";
   } else if (caps === 1) {
    // Uppercase
    document.getElementById("open").innerHTML = "{";
    document.getElementById("close").innerHTML = "}";
    document.getElementById("n1").innerHTML = "!";
    document.getElementById("n2").innerHTML = "@";
    document.getElementById("n3").innerHTML = "#";
    document.getElementById("n4").innerHTML = "$";
    document.getElementById("n5").innerHTML = "%";
    document.getElementById("n6").innerHTML = "^";
    document.getElementById("n7").innerHTML = "&";
    document.getElementById("n8").innerHTML = "*";
    document.getElementById("n9").innerHTML = "(";
    document.getElementById("n0").innerHTML = ")";
    document.getElementById("q").innerHTML = "Q";
    document.getElementById("w").innerHTML = "W";
    document.getElementById("e").innerHTML = "E";
    document.getElementById("r").innerHTML = "R";
    document.getElementById("t").innerHTML = "T";
    document.getElementById("y").innerHTML = "Y";
    document.getElementById("u").innerHTML = "U";
    document.getElementById("i").innerHTML = "I";
    document.getElementById("o").innerHTML = "O";
    document.getElementById("p").innerHTML = "P";
    document.getElementById("a").innerHTML = "A";
    document.getElementById("s").innerHTML = "S";
    document.getElementById("d").innerHTML = "D";
    document.getElementById("f").innerHTML = "F";
    document.getElementById("g").innerHTML = "G";
    document.getElementById("h").innerHTML = "H";
    document.getElementById("j").innerHTML = "J";
    document.getElementById("k").innerHTML = "K";
    document.getElementById("l").innerHTML = "L";
    document.getElementById("z").innerHTML = "Z";
    document.getElementById("x").innerHTML = "X";
    document.getElementById("c").innerHTML = "C";
    document.getElementById("v").innerHTML = "V";
    document.getElementById("b").innerHTML = "B";
    document.getElementById("n").innerHTML = "N";
    document.getElementById("m").innerHTML = "M";
    document.getElementById("equal").innerHTML = "+";
    document.getElementById("slash").innerHTML = "?";
    document.getElementById("colon").innerHTML = ":";
    document.getElementById("quote").innerHTML = '"';
    document.getElementById("comma").innerHTML = "<";
    document.getElementById("dot").innerHTML = ">";
    document.getElementById("dash").innerHTML = "_";
    document.getElementById("backtick").innerHTML = "~";
    document.getElementById("backslash").innerHTML = "|";
    document.getElementById("caps").style.backgroundColor = "#444";
    document.getElementById("caps").style.color = "#000";
   } else {
    // Extended graphics (caps === 2)
    document.getElementById("open").innerHTML = extendedChars['['];
    document.getElementById("close").innerHTML = extendedChars[']'];
    document.getElementById("n1").innerHTML = extendedChars['1'];
    document.getElementById("n2").innerHTML = extendedChars['2'];
    document.getElementById("n3").innerHTML = extendedChars['3'];
    document.getElementById("n4").innerHTML = extendedChars['4'];
    document.getElementById("n5").innerHTML = extendedChars['5'];
    document.getElementById("n6").innerHTML = extendedChars['6'];
    document.getElementById("n7").innerHTML = extendedChars['7'];
    document.getElementById("n8").innerHTML = extendedChars['8'];
    document.getElementById("n9").innerHTML = extendedChars['9'];
    document.getElementById("n0").innerHTML = extendedChars['0'];
    document.getElementById("q").innerHTML = extendedChars['q'];
    document.getElementById("w").innerHTML = extendedChars['w'];
    document.getElementById("e").innerHTML = extendedChars['e'];
    document.getElementById("r").innerHTML = extendedChars['r'];
    document.getElementById("t").innerHTML = extendedChars['t'];
    document.getElementById("y").innerHTML = extendedChars['y'];
    document.getElementById("u").innerHTML = extendedChars['u'];
    document.getElementById("i").innerHTML = extendedChars['i'];
    document.getElementById("o").innerHTML = extendedChars['o'];
    document.getElementById("p").innerHTML = extendedChars['p'];
    document.getElementById("a").innerHTML = extendedChars['a'];
    document.getElementById("s").innerHTML = extendedChars['s'];
    document.getElementById("d").innerHTML = extendedChars['d'];
    document.getElementById("f").innerHTML = extendedChars['f'];
    document.getElementById("g").innerHTML = extendedChars['g'];
    document.getElementById("h").innerHTML = extendedChars['h'];
    document.getElementById("j").innerHTML = extendedChars['j'];
    document.getElementById("k").innerHTML = extendedChars['k'];
    document.getElementById("l").innerHTML = extendedChars['l'];
    document.getElementById("z").innerHTML = extendedChars['z'];
    document.getElementById("x").innerHTML = extendedChars['x'];
    document.getElementById("c").innerHTML = extendedChars['c'];
    document.getElementById("v").innerHTML = extendedChars['v'];
    document.getElementById("b").innerHTML = extendedChars['b'];
    document.getElementById("n").innerHTML = extendedChars['n'];
    document.getElementById("m").innerHTML = extendedChars['m'];
    document.getElementById("equal").innerHTML = extendedChars['='];
    document.getElementById("slash").innerHTML = extendedChars['/'];
    document.getElementById("colon").innerHTML = extendedChars[';'];
    document.getElementById("quote").innerHTML = extendedChars['\''];
    document.getElementById("comma").innerHTML = extendedChars[','];
    document.getElementById("dot").innerHTML = extendedChars['.'];
    document.getElementById("dash").innerHTML = extendedChars['-'];
    document.getElementById("backtick").innerHTML = extendedChars['`'];
    document.getElementById("backslash").innerHTML = extendedChars['\\'];
    document.getElementById("caps").style.backgroundColor = "#888";
    document.getElementById("caps").style.color = "#000";
   }
  } else {
   // Handle arrow key cursor movement
   if (k === "left") {
    if (shift) {
     // Selection mode - extend selection left
     if (selectionStart === -1) {
      // Start new selection
      selectionStart = Math.max(0, cursorPos - 1);
      selectionEnd = cursorPos;
     } else {
      // Extend existing selection
      if (cursorPos > 0) {
       selectionStart = Math.min(selectionStart, cursorPos - 1);
      }
     }
    }
    
    if (cursorPos > 0) {
     cursorPos--;
    }
    
    // Update selection after cursor moves
    if (shift && selectionStart !== -1 && selectionEnd !== -1) {
     selectionStart = Math.max(0, Math.min(selectionStart, cursorPos));
     // Clear selection if start >= end
     if (selectionStart >= selectionEnd) {
      selectionStart = -1;
      selectionEnd = -1;
     }
    } else if (!shift) {
     // Clear selection if not holding shift
     selectionStart = -1;
     selectionEnd = -1;
    }
   } else if (k === "right") {
    if (shift) {
     // Selection mode - extend selection right
     if (selectionStart === -1) {
      // Start new selection
      selectionStart = cursorPos;
      selectionEnd = cursorPos + 1;
     } else {
      // Extend existing selection
      if (cursorPos < line.length) {
       selectionEnd = Math.max(selectionEnd, cursorPos + 1);
      }
     }
    }
    
    if (cursorPos < line.length) {
     cursorPos++;
    }
    
    // Clear selection if start >= end or not holding shift
    if (shift && selectionStart !== -1 && selectionEnd !== -1) {
     selectionEnd = Math.max(selectionStart, cursorPos);
     // Clear selection if start >= end
     if (selectionStart >= selectionEnd) {
      selectionStart = -1;
      selectionEnd = -1;
     }
    } else if (!shift) {
     // Clear selection if not holding shift
     selectionStart = -1;
     selectionEnd = -1;
    }
   } else if (k === "up") {
    // Arrow Up - command history (previous) or move cursor to line above
    const cleanInput = line.replace(/\n/g, '').replace(/\r/g, '');
    const charsPerLine = screenWidth;
    const currentLine = Math.floor(cursorPos / charsPerLine);
    const currentColumn = cursorPos % charsPerLine;
    
    // If on first line and not in selection mode, navigate command history
    if (currentLine === 0 && !shift && keyon) {
     if (commandHistory.length > 0) {
      // Save current command if starting to browse history
      if (historyIndex === -1) {
       tempCommand = line;
       historyIndex = commandHistory.length;
      }
      
      // Move to previous command in history
      if (historyIndex > 0) {
       historyIndex--;
       line = commandHistory[historyIndex];
       cursorPos = line.length;
       inputScrollPos = 0;
      }
     }
    } else {
     // Multi-line navigation
     if (shift) {
      // Selection mode
      if (selectionStart === -1) {
       selectionStart = cursorPos;
      }
     }
     
     if (currentLine > 0) {
      // Not on first line, can move up
      const prevLineStart = (currentLine - 1) * charsPerLine;
      const prevLineLength = Math.min(charsPerLine, cleanInput.length - prevLineStart);
      
      // Move to same column on line above, or end of line if column doesn't exist
      const newPos = prevLineStart + Math.min(currentColumn, prevLineLength);
      cursorPos = newPos;
     }
     
     if (shift && selectionStart !== -1) {
      selectionEnd = cursorPos;
      // Normalize selection
      if (selectionStart > selectionEnd) {
       const temp = selectionStart;
       selectionStart = selectionEnd;
       selectionEnd = temp;
      }
     } else if (!shift) {
      selectionStart = -1;
      selectionEnd = -1;
     }
    }
   } else if (k === "down") {
    // Arrow Down - command history (next) or move cursor to line below
    const cleanInput = line.replace(/\n/g, '').replace(/\r/g, '');
    const charsPerLine = screenWidth;
    const currentLine = Math.floor(cursorPos / charsPerLine);
    const currentColumn = cursorPos % charsPerLine;
    const totalLines = Math.ceil(cleanInput.length / charsPerLine);
    
    // If on last line and not in selection mode, navigate command history
    if (currentLine >= totalLines - 1 && !shift && keyon) {
     if (historyIndex !== -1) {
      // Move to next command in history
      if (historyIndex < commandHistory.length - 1) {
       historyIndex++;
       line = commandHistory[historyIndex];
       cursorPos = line.length;
       inputScrollPos = 0;
      } else if (historyIndex === commandHistory.length - 1) {
       // At newest history entry, go back to what user was typing
       historyIndex = -1;
       line = tempCommand;
       cursorPos = line.length;
       inputScrollPos = 0;
       tempCommand = "";
      }
     }
    } else {
     // Multi-line navigation
     if (shift) {
      // Selection mode
      if (selectionStart === -1) {
       selectionStart = cursorPos;
      }
     }
     
     if (currentLine < totalLines - 1) {
      // Not on last line, can move down
      const nextLineStart = (currentLine + 1) * charsPerLine;
      const nextLineLength = Math.min(charsPerLine, cleanInput.length - nextLineStart);
      
      // Move to same column on line below, or end of line if column doesn't exist
      const newPos = nextLineStart + Math.min(currentColumn, nextLineLength);
      cursorPos = newPos;
     }
     
     if (shift && selectionStart !== -1) {
      selectionEnd = cursorPos;
      // Normalize selection
      if (selectionStart > selectionEnd) {
       const temp = selectionStart;
       selectionStart = selectionEnd;
       selectionEnd = temp;
      }
     } else if (!shift) {
      selectionStart = -1;
      selectionEnd = -1;
     }
    }
   } else if (k === "home") {
    if (shift) {
     if (selectionStart === -1) {
      selectionStart = cursorPos;
     }
     const charsPerLine = screenWidth;
     const currentLine = Math.floor(cursorPos / charsPerLine);
     const lineStart = currentLine * charsPerLine;
     cursorPos = lineStart;
     selectionEnd = cursorPos;
     // Normalize selection
     if (selectionStart > selectionEnd) {
      const temp = selectionStart;
      selectionStart = selectionEnd;
      selectionEnd = temp;
     }
    } else {
     const charsPerLine = screenWidth;
     const currentLine = Math.floor(cursorPos / charsPerLine);
     const lineStart = currentLine * charsPerLine;
     cursorPos = lineStart;
     selectionStart = -1;
     selectionEnd = -1;
    }
   } else if (k === "end") {
    if (shift) {
     if (selectionStart === -1) {
      selectionStart = cursorPos;
     }
     const charsPerLine = screenWidth;
     const currentLine = Math.floor(cursorPos / charsPerLine);
     const lineEnd = Math.min((currentLine + 1) * charsPerLine, line.length);
     cursorPos = lineEnd;
     selectionEnd = cursorPos;
     // Normalize selection
     if (selectionStart > selectionEnd) {
      const temp = selectionStart;
      selectionStart = selectionEnd;
      selectionEnd = temp;
     }
    } else {
     const charsPerLine = screenWidth;
     const currentLine = Math.floor(cursorPos / charsPerLine);
     const lineEnd = Math.min((currentLine + 1) * charsPerLine, line.length);
     cursorPos = lineEnd;
     selectionStart = -1;
     selectionEnd = -1;
    }
   } else if (k === "back") {
    // Backspace - delete character before cursor
    if (cursorPos > 0) {
     line = line.substring(0, cursorPos - 1) + line.substring(cursorPos);
     cursorPos--;
    }
    // Clear selection
    selectionStart = -1;
    selectionEnd = -1;
   } else if (k === "delete") {
    // Check for Shift+Delete (cut operation)
    if (shift && selectionStart !== -1 && selectionEnd !== -1) {
     // Cut operation: copy then delete
     const start = Math.min(selectionStart, selectionEnd);
     const end = Math.max(selectionStart, selectionEnd);
     const selectedText = line.substring(start, end);
     
     // Copy to clipboard
     navigator.clipboard.writeText(selectedText).then(() => {
      // Delete the selected text
      line = line.substring(0, start) + line.substring(end);
      cursorPos = start;
      selectionStart = -1;
      selectionEnd = -1;
      updateDisplay();
      print("\x1b[32mCut to clipboard!\x1b[0m\n");
     }).catch(err => {
      print("\x1b[31mCut failed\x1b[0m\n");
     });
     return; // Don't call updateDisplay again
    }
    // Delete selected text (without copy)
    else if (selectionStart !== -1 && selectionEnd !== -1) {
     const start = Math.min(selectionStart, selectionEnd);
     const end = Math.max(selectionStart, selectionEnd);
     line = line.substring(0, start) + line.substring(end);
     cursorPos = start;
     selectionStart = -1;
     selectionEnd = -1;
    }
    // Normal delete - remove character at cursor position
    else if (cursorPos < line.length) {
     line = line.substring(0, cursorPos) + line.substring(cursorPos + 1);
    }
   } else {
    if (k === "enter") {
     if (keyon) {
      // Add command to history (skip empty commands and duplicates)
      if (line.trim().length > 0) {
       // Don't add if it's the same as the last command
       if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== line) {
        commandHistory.push(line);
        // Limit history size
        if (commandHistory.length > maxHistorySize) {
         commandHistory.shift();
        }
       }
      }
      // Reset history navigation
      historyIndex = -1;
      tempCommand = "";
      
      if (run) {
       // Program is running
       txt = txt + line + "<br>";
       input(line);
       line = "";
       cursorPos = 0;
       inputScrollPos = 0;
       print("");
      } else {
       // OS command mode
       print(line); print("\n");
       if (line.slice(-3) === ".js") {
        // Load external .js file
        keyon = 0;
        txt = txt + line + "<br>";
        const prg = document.createElement('script');
        prg.src = line;
        prg.onload = () => { keyon = 1; };
        prg.onerror = () => { 
         print("Error loading program\n");
         keyon = 1;
        };
        document.head.appendChild(prg);
        line = "";
        cursorPos = 0;
        inputScrollPos = 0;
       } else if (line.substr(0, 3) === "cls") {
        initScreen();
        line = "";
        cursorPos = 0;
        inputScrollPos = 0;
       } else if (line.substr(0, 4) === "help") {
        // display list of install .js files
        showFiles(); line="";        
       } else {
        // Execute command/code
        executeCode(line);
        line = "";
        cursorPos = 0;
        inputScrollPos = 0;
       }
      }
     }
    } else if (l) {
     // Insert character at cursor position
     if (keyon) {
      // Prepend modifier keys if active (from virtual or physical keyboard)
      let finalChar = l;
      let hasCtrl = ctrl || (typeof event !== 'undefined' && event.ctrlKey);
      let hasAlt = alt || (typeof event !== 'undefined' && event.altKey);
      
      if (hasCtrl || hasAlt) {
       let modifiers = [];
       if (hasCtrl) modifiers.push("ctrl");
       if (hasAlt) modifiers.push("alt");
       finalChar = modifiers.join(" ") + " " + l;
       // Reset virtual keyboard modifier keys after use (they're consumed)
       if (ctrl) {
        ctrl = 0;
        document.getElementById("ctrl").style.backgroundColor = "#222";
        document.getElementById("ctrl").style.color = "#fff";
       }
       if (alt) {
        alt = 0;
        document.getElementById("alt").style.backgroundColor = "#222";
        document.getElementById("alt").style.color = "#fff";
       }
      }
      line = line.substring(0, cursorPos) + finalChar + line.substring(cursorPos);
      cursorPos += finalChar.length;
      // Clear selection when typing
      selectionStart = -1;
      selectionEnd = -1;
      // Reset history navigation when user types
      historyIndex = -1;
      tempCommand = "";
     }
    }
   }
   if (run) { keydown(k); }
  }
 }
 updateDisplay();
}

function executeCode(code) {
 try {
  const result=eval(code);
  if (result !== undefined) {
   print(String(result)+"<br>");
  }
  return true;
 } catch (error) {
  print(`Error: ${error.message}`+"<br>");
  return false;
 }
}

function parseANSIString(str) {
  const tokens = [];
  // Match ANSI escape sequences in hex (\x1b), octal (\033 = \x1b), and unicode (\u001b) formats
  const ansiRegex = /(\x1b|\x1b|\u001b)\[([\d;]*)([A-Za-z])/g;
  let lastIndex = 0;
  let match;
  
  while ((match = ansiRegex.exec(str)) !== null) {
    // Add text before the ANSI code
    if (match.index > lastIndex) {
      const text = str.substring(lastIndex, match.index);
      for (let i = 0; i < text.length; i++) {
        tokens.push({ type: 'char', value: text[i] });
      }
    }
    
    // Add the ANSI code
    const params = match[2] ? match[2].split(';').filter(s => s !== '').map(Number) : [0];
    const command = match[3];
    
    if (command === 'm') {
      // SGR (Select Graphic Rendition) - color/style codes
      tokens.push({ type: 'code', codes: params });
    } else if (command === 'H' || command === 'f') {
      // CUP (Cursor Position) - move cursor to row;col
      // Format: \x1b[row;colH or \x1b[row;colf
      const row = params[0] ? params[0] - 1 : 0; // Convert to 0-based
      const col = params[1] ? params[1] - 1 : 0; // Convert to 0-based
      tokens.push({ type: 'cursor', row: row, col: col });
    } else if (command === 'K') {
      // EL (Erase in Line) - clear from cursor to end of line
      // param 0 or missing = clear from cursor to end
      // param 1 = clear from start to cursor
      // param 2 = clear entire line
      const mode = params[0] || 0;
      tokens.push({ type: 'clearline', mode: mode });
    }
    // Other ANSI commands are ignored for now
    
    lastIndex = match.index + match[0].length;
  }
  
  // Add remaining text
  if (lastIndex < str.length) {
    const text = str.substring(lastIndex);
    for (let i = 0; i < text.length; i++) {
      tokens.push({ type: 'char', value: text[i] });
    }
  }
  
  return tokens;
}

function applyANSICode(codes) {
  codes.forEach(code => {
    if (code === 0) {
      // Reset all
      currentStyle.color = 37;
      currentStyle.bgcolor = 40;
      currentStyle.bold = false;
      currentStyle.inverse = false;
    } else if (code === 1) {
      // Bold
      currentStyle.bold = true;
    } else if (code === 7) {
      // Inverse
      currentStyle.inverse = true;
    } else if (code === 27) {
      // No inverse
      currentStyle.inverse = false;
    } else if (code >= 30 && code <= 37) {
      // Foreground color
      currentStyle.color = code;
    } else if (code >= 40 && code <= 47) {
      // Background color
      currentStyle.bgcolor = code;
    }
  });
}

function scrollScreenDown() {
  screenBuffer.shift();
  styleBuffer.shift();
  
  const newLine = [];
  const newStyleLine = [];
  for (let j = 0; j < screenWidth; j++) {
    newLine[j] = ' ';
    newStyleLine[j] = {
      color: currentStyle.color,
      bgcolor: currentStyle.bgcolor,
      bold: currentStyle.bold,
      inverse: currentStyle.inverse
    };
  }
  screenBuffer.push(newLine);
  styleBuffer.push(newStyleLine);
}

const ANSI={
 colors: { 30: 'black', 31: 'red', 32: 'green', 33: 'yellow', 34: 'blue', 35: 'magenta', 36: 'cyan', 37: 'white' },
 bgColors: { 40: 'black', 41: 'red', 42: 'green', 43: 'yellow', 44: 'blue', 45: 'magenta', 46: 'cyan', 47: 'white' },
  
 render: function(text) {
  let html=''; let currentColor='white'; let currentBgColor='black'; let bold=false; let inverse=false; let cursorX=0; let cursorY=0;
  const ansiRegex = /\x1b\[([\d;]*)([A-Za-z])/g; let lastIndex = 0; let match;
  while ((match = ansiRegex.exec(text)) !== null) {
   html += this.escapeHtml(text.substring(lastIndex, match.index));
   const params = match[1] ? match[1].split(';').map(Number) : [0];
   const command = match[2];
   if (command === 'm') {
    params.forEach(param => {
    if (param === 0) {
     currentColor = 'white';
     currentBgColor = 'black';
     bold = false;
     inverse = false;
    } else if (param === 1) {
     bold = true;
    } else if (param === 7) {
     inverse = true;
    } else if (param === 27) {
     inverse = false;
    } else if (param >= 30 && param <= 37) {
     currentColor = this.colors[param];
    } else if (param >= 40 && param <= 47) {
     currentBgColor = this.bgColors[param];
    }
   });
  } else if (command === 'H' || command === 'f') {
   cursorY = params[0] || 0;
   cursorX = params[1] || 0;
  } else if (command === 'A') {
   cursorY = Math.max(0, cursorY - (params[0] || 1));
  } else if (command === 'B') {
   cursorY += (params[0] || 1);
  } else if (command === 'C') {
   cursorX += (params[0] || 1);
  } else if (command === 'D') {
   cursorX = Math.max(0, cursorX - (params[0] || 1));
  } else if (command === 'J') {
   if (params[0] === 2) {
    html=''; // Clear screen @@
   }
  } else if (command === 'K') {
 }
 lastIndex = match.index + match[0].length;
 }
 html += this.escapeHtml(text.substring(lastIndex));
 let classes = [];
 if (bold) classes.push('ansi-bold');
 if (inverse) classes.push('ansi-inverse');
 classes.push(`ansi-${currentColor}`);
 classes.push(`ansi-bg-${currentBgColor}`);
 if (classes.length > 0) { html=`<span class="${classes.join(' ')}">${html}</span>`; }
 return html;
},

escapeHtml: function(text) {
 const map = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#039;'
 };
 return text.replace(/[&<>"']/g, m => map[m]);
},
codes: {
 reset: '\x1b[0m',
 bold: '\x1b[1m',
 inverse: '\x1b[7m',
 black: '\x1b[30m',
 red: '\x1b[31m',
 green: '\x1b[32m',
 yellow: '\x1b[33m',
 blue: '\x1b[34m',
 magenta: '\x1b[35m',
 cyan: '\x1b[36m',
 white: '\x1b[37m',
 bgBlack: '\x1b[40m',
 bgRed: '\x1b[41m',
 bgGreen: '\x1b[42m',
 bgYellow: '\x1b[43m',
 bgBlue: '\x1b[44m',
 bgMagenta: '\x1b[45m',
 bgCyan: '\x1b[46m',
 bgWhite: '\x1b[47m',
 cursorHome: '\x1b[H',
 cursorPos: (row, col) => `\x1b[${row};${col}H`,
 cursorUp: (n = 1) => `\x1b[${n}A`,
 cursorDown: (n = 1) => `\x1b[${n}B`,
 cursorForward: (n = 1) => `\x1b[${n}C`,
 cursorBack: (n = 1) => `\x1b[${n}D`,
 clearScreen: '\x1b[2J',
 clearLine: '\x1b[K',
 pageBreak: '\f'  // Form Feed (ASCII 12, 0x0C) - explicit page break for pagination
}};

// system functions

function showFiles() {
  print("\n");
  print("ascii.js\n");
  print("sound.js\n");
  print("piano.js\n");
  print("demo.js\n");
  print("q.js\n");
  print("world.js\n");
  print("\n");
  
  // List files from localStorage
  var userFiles = [];
  for (var i = 0; i < localStorage.length; i++) {
    var key = localStorage.key(i);
    if (key.startsWith("qandy_file_")) {
      userFiles.push(key.substring(11)); // Remove "qandy_file_" prefix
    }
  }
  
  if (userFiles.length > 0) {
    print("\x1b[1;32mUSER FILES:\x1b[0m\n");
    for (var j = 0; j < userFiles.length; j++) {
      print(userFiles[j] + "\n");
    }
    print("\n");
  }
}

function triggerPaginationPause() {
  // Pauses pagination output and displays "Press Any Key to Continue" prompt.
  // Can be triggered by: line count threshold (20 lines) OR Form Feed character (\f)
  paginationPaused = true;
  keyon = 0;  // Disable normal keyboard input
  
  // Save current style
  const savedStyle = {
    color: currentStyle.color,
    bgcolor: currentStyle.bgcolor,
    bold: currentStyle.bold,
    inverse: currentStyle.inverse
  };
  
  // Print pause message in bright color
  currentStyle.color = 32;  // Green
  currentStyle.bold = true;
  const pauseMsg = "\n--- Press Any Key to Continue ---";
  for (let i = 0; i < pauseMsg.length; i++) {
    if (pauseMsg[i] === '\n') {
      cursorX = 0;
      cursorY++;
    } else {
      if (cursorX >= screenWidth) {
        cursorX = 0;
        cursorY++;
      }
      if (cursorY >= screenHeight) {
        scrollScreenDown();
        cursorY = screenHeight - 1;
      }
      if (screenBuffer[cursorY] && styleBuffer[cursorY]) {
        screenBuffer[cursorY][cursorX] = pauseMsg[i];
        styleBuffer[cursorY][cursorX] = {
          color: currentStyle.color,
          bgcolor: currentStyle.bgcolor,
          bold: currentStyle.bold,
          inverse: currentStyle.inverse
        };
        cursorX++;
      }
    }
  }
  
  // Restore style
  currentStyle.color = savedStyle.color;
  currentStyle.bgcolor = savedStyle.bgcolor;
  currentStyle.bold = savedStyle.bold;
  currentStyle.inverse = savedStyle.inverse;
  
  updateDisplay();
}

function print(inputString) {
  // If pagination is paused, queue the text for later
  if (paginationPaused) {
    paginationBuffer.push(inputString);
    return;
  }
  
  // Make sure buffers are initialized
  if (!screenBuffer || screenBuffer.length === 0) {
    initScreen();
  }
  
  // Parse ANSI codes in input string
  const tokens = parseANSIString(inputString);
  
  // Build plain text (no ANSI codes) for txt variable
  let plainText = '';
  for (const token of tokens) {
    if (token.type === 'char') {
      plainText += token.value;
    }
  }
  txt = txt + plainText;
  
  // Process each token
  for (const token of tokens) {
    if (token.type === 'code') {
      // Update current style
      applyANSICode(token.codes);
    } else if (token.type === 'cursor') {
      // Cursor positioning (CUP) - move cursor to specified row/col
      cursorY = Math.min(Math.max(0, token.row), screenHeight - 1);
      cursorX = Math.min(Math.max(0, token.col), screenWidth - 1);
    } else if (token.type === 'clearline') {
      // Clear line from cursor position
      if (token.mode === 0) {
        // Clear from cursor to end of line
        for (let x = cursorX; x < screenWidth; x++) {
          if (screenBuffer[cursorY]) {
            screenBuffer[cursorY][x] = ' ';
            styleBuffer[cursorY][x] = {
              color: currentStyle.color,
              bgcolor: currentStyle.bgcolor,
              bold: currentStyle.bold,
              inverse: currentStyle.inverse
            };
          }
        }
      } else if (token.mode === 1) {
        // Clear from start of line to cursor
        for (let x = 0; x <= cursorX; x++) {
          if (screenBuffer[cursorY]) {
            screenBuffer[cursorY][x] = ' ';
            styleBuffer[cursorY][x] = {
              color: currentStyle.color,
              bgcolor: currentStyle.bgcolor,
              bold: currentStyle.bold,
              inverse: currentStyle.inverse
            };
          }
        }
      } else if (token.mode === 2) {
        // Clear entire line
        for (let x = 0; x < screenWidth; x++) {
          if (screenBuffer[cursorY]) {
            screenBuffer[cursorY][x] = ' ';
            styleBuffer[cursorY][x] = {
              color: currentStyle.color,
              bgcolor: currentStyle.bgcolor,
              bold: currentStyle.bold,
              inverse: currentStyle.inverse
            };
          }
        }
      }
    } else if (token.type === 'char') {
      const char = token.value;
      
      // Handle Form Feed (FF) - triggers explicit page break for pagination
      if (char === '\f') {
        if (paginationEnabled) {
          // Form Feed explicitly triggers pagination
          triggerPaginationPause();
          return;  // Exit and wait for key press
        } else {
          // If pagination disabled, treat as newline
          cursorX = 0;
          cursorY++;
          if (cursorY >= screenHeight) {
            scrollScreenDown();
            cursorY = screenHeight - 1;
          }
        }
        continue;
      }
      
      // Handle newline - DON'T store it, just move cursor
      if (char === '\n') {
        cursorX = 0;
        cursorY++;
        
        // Check if we should pause for pagination (line count threshold)
        if (paginationEnabled && cursorY >= paginationLinesBeforePause) {
          triggerPaginationPause();
          return;  // Exit and wait for key press
        }
        
        // Auto-scroll at screen height
        if (cursorY >= screenHeight) {
          scrollScreenDown();
          cursorY = screenHeight - 1;
        }
        continue;
      }
      
      // Handle carriage return
      if (char === '\r') {
        cursorX = 0;
        continue;
      }
      
      // Check if we need to scroll before writing
      if (cursorY >= screenHeight) {
        scrollScreenDown();
        cursorY = screenHeight - 1;
      }
      
      // Auto-wrap at screen width
      if (cursorX >= screenWidth) {
        cursorX = 0;
        cursorY++;
        
        // Check again if we need to scroll
        if (cursorY >= screenHeight) {
          scrollScreenDown();
          cursorY = screenHeight - 1;
        }
      }
      
      // Store character and style in buffers
      if (screenBuffer[cursorY] && styleBuffer[cursorY]) {
        screenBuffer[cursorY][cursorX] = char;
        styleBuffer[cursorY][cursorX] = {
          color: currentStyle.color,
          bgcolor: currentStyle.bgcolor,
          bold: currentStyle.bold,
          inverse: currentStyle.inverse
        };
        cursorX++;
      }
    }
  }
  
  updateDisplay();
}

function resumePagination() {
  // Clear the pause message by removing last few lines
  if (screenBuffer.length > 0) {
    // Remove the "Press Any Key" message line
    const lastLineIdx = screenBuffer.length - 1;
    for (let x = 0; x < screenWidth; x++) {
      screenBuffer[lastLineIdx][x] = ' ';
      styleBuffer[lastLineIdx][x] = {
        color: 37,
        bgcolor: 40,
        bold: false,
        inverse: false
      };
    }
  }
  
  // Reset pagination state
  paginationPaused = false;
  keyon = 1;  // Re-enable keyboard input
  
  // Clear the screen and reset cursor
  initScreen();
  
  // Process queued print calls
  const bufferedText = paginationBuffer.slice();  // Copy array
  paginationBuffer = [];  // Clear buffer
  
  // Print all buffered content
  for (let i = 0; i < bufferedText.length; i++) {
    print(bufferedText[i]);
  }
}


function updateDisplay() {
  if (!screenBuffer || screenBuffer.length === 0) { initScreen(); }
  const txtElement = document.getElementById("txt");
  let htmlContent = '';
  const rowsToRender = cursorY;
  
  for (let y = 0; y < rowsToRender; y++) {
    let lineContent = '';
    let currentSpanStyle = null;
    let spanContent = '';
    
    for (let x = 0; x < screenWidth; x++) {
      const char = screenBuffer[y][x];
      const style = styleBuffer[y][x];
      
      // Build style identifier for this character
      const styleKey = `${style.color}-${style.bgcolor}-${style.bold}-${style.inverse}`;
      
      // If style changed, close previous span and open new one
      if (currentSpanStyle !== styleKey) {
        if (spanContent.length > 0) {
          // Close previous span
          lineContent += spanContent + '</span>';
          spanContent = '';
        }
        
        // Open new span with current style
        let classes = [];
        
        if (style.inverse) {
          // Swap foreground and background when inverse
          classes.push(`ansi-${ANSI.bgColors[style.bgcolor]}`);
          classes.push(`ansi-bg-${ANSI.colors[style.color]}`);
        } else {
          classes.push(`ansi-${ANSI.colors[style.color]}`);
          classes.push(`ansi-bg-${ANSI.bgColors[style.bgcolor]}`);
        }
        
        if (style.bold) {
          classes.push('ansi-bold');
        }
        
        lineContent += `<span class="${classes.join(' ')}">`;
        currentSpanStyle = styleKey;
      }
      
      // Escape HTML and add to span content
      const escapedChar = char
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      spanContent += escapedChar;
    }
    
    // Close final span
    if (spanContent.length > 0) {
      lineContent += spanContent + '</span>';
    }
    
    // Trim trailing spaces before the final </span>
    lineContent = lineContent.replace(/\s+<\/span>$/, '</span>');
    htmlContent += lineContent + '<br>';
  }
  
  if (keyon) {
    let cleanInput = line.replace(/\n/g, '').replace(/\r/g, '');
    
    // Calculate how many display lines we need
    const charsPerLine = screenWidth;
    const numLines = Math.max(1, Math.ceil(cleanInput.length / charsPerLine));
    
    // Helper function to escape HTML characters
    const escapeHtml = (str) => str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/ /g, '&nbsp;');
    
    // Render input across multiple wrapped lines
    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {
      let lineStart = lineIndex * charsPerLine;
      let lineEnd = Math.min(lineStart + charsPerLine, cleanInput.length);
      let displayLine = cleanInput.substring(lineStart, lineEnd);
      
      let lineHtml = '';
      
      // Build this line character by character
      for (let charIndex = 0; charIndex < charsPerLine; charIndex++) {
        let charPos = lineStart + charIndex;
        
        if (charIndex < displayLine.length) {
          // We have a character to display
          let char = displayLine[charIndex];
          
          // Check if this character is selected
          const isSelected = selectionStart !== -1 && 
                             charPos >= Math.min(selectionStart, selectionEnd) && 
                             charPos < Math.max(selectionStart, selectionEnd);
          
          if (charPos === cursorPos) {
            // This is the cursor position - invert colors
            lineHtml += '<span style="background-color: white; color: black;">' + 
                        escapeHtml(char) + 
                        '</span>';
          } else if (isSelected) {
            // Selected text - use selection colors
            lineHtml += `<span style="background-color: ${selectionBgColor}; color: ${selectionFgColor};">` + 
                        escapeHtml(char) + 
                        '</span>';
          } else {
            // Normal character
            lineHtml += escapeHtml(char);
          }
        } else if (charPos === cursorPos && charPos === cleanInput.length) {
          // Cursor is at the end of input (after last character)
          lineHtml += '<span style="background-color: white; color: black;">&nbsp;</span>';
        } else {
          // Empty space (input doesn't extend this far on this line)
          lineHtml += '&nbsp;';
        }
      }
      
      htmlContent += lineHtml + '<br>';
    }
  }
  
  txtElement.innerHTML = htmlContent;
  txtElement.scrollTop = txtElement.scrollHeight;
}

function cls() { 
  screenBuffer = [];  // Reset global screenBuffer (removed 'var' to avoid shadowing)
  initScreen(); 
  // Reset pagination state
  paginationPaused = false;
  paginationBuffer = [];
  keyon = 1;
}

function gfx(scr) { a=0; for (b=0; b<=mapy; b++) { for (c=0; c<=mapx; c++) { e=document.getElementById("T"+a).src="t/"+scr.charAt(a*2)+scr.charAt((a*2)+1)+".png"; a++; }}}
function hpop() { document.getElementById("pop").style.visibility="hidden"; }
function pop(htm) {
 e=document.getElementById("pop").innerHTML="<p>"+htm;
 TopYPos=32+22; TopXPos=32+22;
 
 PopAlign="center";
 
 switch (PopAlign) {
  case "char":
   PopY=TopYPos+(PY*32)+8; PopX=TopXPos+(PX*32)+32; 
   if (PopY<TopYPos) { PopY=TopYPos; } if (PopY<TopYPos+10) { PopY=TopYPos+10; }
   if (PopX<TopXPos) { PopX=TopXPos; } if (PopX<TopXPos+10) { PopX=TopXPos+10; }
   if (PopX+document.getElementById("pop").scrollWidth>TopXPos+256) { PopX=(TopXPos+256)-document.getElementById("PopUp").scrollWidth; }
   if (PopY+document.getElementById("pop").scrollHeight>TopYPos+384) { PopY=(TopYPos+384)-document.getElementById("PopUp").scrollHeight; }
   break;
   // width: 256px; height: 384px;
  case "center":
   PopX=TopXPos+((256-document.getElementById("pop").scrollWidth)/2);
   PopY=TopYPos+((384-document.getElementById("pop").scrollHeight)/2);
   break;
  case "click":
   PopY=Math.floor(PopClick/(MapSizeX+1));
   PopX=PopClick-(PopY*(MapSizeX+1));
   PopY=(PopY*32)+22; PopX=(PopX*32)+22;
   if (PopX+document.getElementById("PopUp").scrollWidth>TopXPos+424) { PopX=(TopXPos+424)-document.getElementById("PopUp").scrollWidth; }
   if (PopY+document.getElementById("PopUp").scrollHeight>TopYPos+300) { PopY=(TopYPos+300)-document.getElementById("PopUp").scrollHeight; }
   break;
 }  
 document.getElementById("pop").style.top=PopY; 
 document.getElementById("pop").style.left=PopX;
 document.getElementById("pop").style.visibility="visible";
 //poptimer=setTimeout('document.getElementById("pop").style.visibility="visible";',200);
}

function char(C,O,Z) {
 Y=Math.floor(Z/(mapx+1)); X=Z-(Y*(mapx+1)); Y--;
 idface="cf"+C; idbody="cb"+C; idwpn="cw"+C; idarm="ca"+C; idhat="ch"+C;
 face=""; body=""; wpn=""; arm=""; hat="";

 if (O.indexOf("A")>-1) { face="A"+O.charAt(O.indexOf("A")+1); }
 if (O.indexOf("B")>-1) { face="B"+O.charAt(O.indexOf("B")+1); }
 if (O.indexOf("E")>-1) { face="E"+O.charAt(O.indexOf("E")+1); }
 if (O.indexOf("F")>-1) { face="F"+O.charAt(O.indexOf("F")+1); }

 if (O.indexOf("C")>-1) { body="C"+O.charAt(O.indexOf("C")+1); }
 if (O.indexOf("D")>-1) { body="D"+O.charAt(O.indexOf("D")+1); }
 if (O.indexOf("G")>-1) { body="G"+O.charAt(O.indexOf("G")+1); }
 if (O.indexOf("H")>-1) { body="H"+O.charAt(O.indexOf("H")+1); }

 if (document.getElementById("cb"+C)) {
  e=document.getElementById("cb"+C).src="c/"+body+".png";
  e=document.getElementById("cb"+C).style.top=32+22+(Y*32)+"px";
  e=document.getElementById("cb"+C).style.left=(32+22+(X*32))+"px";
 } else {
  chr=document.createElement("img");
  chr.id="cb"+C; chr.src="c/"+body+".png";
  chr.className="char";  
  chr.style.position="absolute"; chr.style.height=64; chr.style.width=32;
  chr.style.top=32+22+(Y*32)+"px"; chr.style.left=(32+22+(X*32))+"px";
  chr.onclick=function() { chr.onmousedown=new Function("ClickChar("+(PZ)+",this.parentNode)"); }
  chr.style.zIndex="150";  
  document.body.appendChild(chr);
 }
 if (document.getElementById("cf"+C)) {
  e=document.getElementById("cf"+C).src="c/"+face+".png";
  e=document.getElementById("cf"+C).style.top=32+22+(Y*32)+"px";
  e=document.getElementById("cf"+C).style.left=(32+22+(X*32))+"px";
 } else {
  chr=document.createElement("img");
  chr.id="cf"+C; chr.src="c/"+face+".png";
  chr.className="char";  
  chr.style.position="absolute"; chr.style.height=64; chr.style.width=32;
  chr.style.top=32+22+(Y*32)+"px"; chr.style.left=(32+22+(X*32))+"px";
  chr.onclick=function() { chr.onmousedown=new Function("ClickChar("+(PZ)+",this.parentNode)"); }
  chr.style.zIndex="151";
  document.body.appendChild(chr);
 }

 if (O.indexOf("I")>-1) { hat="I"+O.charAt(O.indexOf("I")+1); }
 if (O.indexOf("J")>-1) { hat="J"+O.charAt(O.indexOf("J")+1); }
 if (hat) {
  if (document.getElementById("ch"+C)) {
   e=document.getElementById("ch"+C).src="c/"+hat+".png";
   e=document.getElementById("ch"+C).style.top=32+22+(Y*32)+"px";
   e=document.getElementById("ch"+C).style.left=(32+22+(X*32))+"px";
  } else {
   chr=document.createElement("img");
   chr.id="ch"+C; chr.src="c/"+hat+".png";
   chr.className="char";  
   chr.style.position="absolute"; chr.style.height=64; chr.style.width=32;
   chr.style.top=32+22+(Y*32)+"px"; chr.style.left=(32+22+(X*32))+"px";
   chr.onclick=function() { chr.onmousedown=new Function("ClickChar("+(PZ)+",this.parentNode)"); }
   chr.style.zIndex="152";
   document.body.appendChild(chr);
  } 
 } else {
  if (document.getElementById("ch"+PName)) { document.getElementById("ch"+PName).remove(); } 
 }
}

function ItemID(I) {
 switch (I) {
  case "Aa": return "Travel Boots"; break;
  case "Ab": return "Hiking Boots"; break;
  case "Ac": return "Swamp Boots"; break;
  case "Ad": return "Mountain Boots"; break;
  case "Ae": return "Lava Boots"; break;
  case "Bd": return "Bucket"; break;
  case "Be": return "Lantern"; break;
  case "Cg": return "Log"; break;
  case "Ek": return "Bucket of Tar"; break;
  case "El": return "Bucket of Water"; break;
  case "Fa": return "Tomato"; break;
  case "Fb": return "Tomatoes"; break;
  case "Fc": return "Tomatoes"; break;
  case "Fd": return "Tomatoes"; break;
  case "Jc": return "Candy"; break;
  case "Ka": return "Plant"; break;
  case "Kf": return "Bread"; break;
  case "La": return "DevTeam Hat"; break;
  case "Lb": return "Player Hat"; break;
  case "Lc": return "Player Hat"; break;
  case "Ld": return "Red Bandana"; break;
  case "Lg": return "Blue Bandana"; break;
  case "Ma": return "Cylon Helmet"; break;
  case "Mb": return "Cylon Helmet"; break;
  case "Md": return "Mask"; break;
  case "Ob": return "Shield"; break; 
  case "Pj": return "Sword"; break;
  case "Re": return "Medicine"; break;
   
  case "Va": return "Spider"; break;
  case "Vb": return "Mosquito"; break;
  case "Vc": return "Scorpion"; break;
  case "Vd": return "Fire Ant"; break;
  case "Yb": return "Cart"; break;
  case "Yc": return "Furnace"; break;
  case "Ye": return "Seeds"; break;
  case "Yi": return "Goblin Village"; break;  
  case "Ze": return "Teleport"; break
  case "Zf": return "Sign"; break
  case "Zg": return "Pier"; break  
  case "Zi": return "Fire Pit"; break;  
  case "Zj": return "Fire"; break;
  case "Zh": return "Well"; break;
  case "Zm": return "City"; break
 } 
}

function ClickTile(Z) {
 Y=Math.floor(Z/mapx); X=Z-(Y*mapx); 
 if (run) { MenuTile(Z); }
}

function ClickChar(Z) {
 if (run) { MenuChar(Z); }
}

// system ready

initScreen();
function initScreen() {
  screenBuffer = [];
  styleBuffer = [];
  cursorX = 0;
  cursorY = 0;
  
  for (let i = 0; i < screenHeight; i++) {
    screenBuffer[i] = [];
    styleBuffer[i] = [];
    for (let j = 0; j < screenWidth; j++) {
      screenBuffer[i][j] = ' ';
      styleBuffer[i][j] = {
        color: currentStyle.color,
        bgcolor: currentStyle.bgcolor,
        bold: currentStyle.bold,
        inverse: currentStyle.inverse
      };
    }
  }
}

window.ANSI=ANSI;
print("\nQandy Pocket\nComputer v1.j\n"); 

SFiles=1;
mySearch=location.search.substr(1).split("&")
for (i=0;i<mySearch.length;i++) {
 nameVal=mySearch[i].split("=");
 for (j in nameVal) { nameVal[j]=unescape(nameVal[j]); } 
 if (nameVal[0]=="run") {
  script=document.createElement('script');
  script.src=nameVal[1];
  document.head.appendChild(script);
  SFiles=0;
 }
}
if (SFiles) { showFiles(); }

</script></body></html>