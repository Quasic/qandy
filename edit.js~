
run="edit.js";

var editorState = {
  lines: [""],
  cursorLine: 0,
  cursorCol: 0,
  filename: "untitled.js",
  modified: false,
  mode: "edit", // "edit", "dialog"
  viewOffsetLine: 0,
  maxLines: 22, // Maximum visible lines in editor (screen is 25 lines: 1 menu + 22 edit + 1 status + 1 blank)
  maxCols: 29, // Maximum visible columns
  message: "",
  dialogType: "", // "save", "open", "new"
  dialogInput: "",
  selectionStartLine: -1,
  selectionStartCol: -1,
  selectionEndLine: -1,
  selectionEndCol: -1,
  clipboard: ""
};

// Menu structure for menus.js API
var editorMenus = [
  {
    title: "File",
    items: [
      { label: "Load", action: "open" },
      { label: "Save", action: "save" },
      { label: "Quit", action: "exit" }
    ]
  }
];

// Initialize editor
function initEditor(filename) {
  // Define hotkeys for ALT+letter combinations
  var editorHotkeys = {
    "s": "save",      // ALT+S = Save
    "l": "open",      // ALT+L = Load (open)
    "n": "new",       // ALT+N = New
    "d": "list",      // ALT+D = Directory (list files)
    "x": "exit",      // ALT+X = Exit
    "r": "execute"    // ALT+R = Run/Execute
  };
  
  // Initialize menu system with callback and hotkeys
  initMenus(editorMenus, "alt", handleMenuAction, editorHotkeys);
  
  if (filename) {
    editorState.filename = filename;
    loadFile(filename);
  }
  editorState.mode = "edit";
  editorState.modified = false;
  renderEditor();
}

// Handle menu action callback from menus.js
function handleMenuAction(action, item) {
  if (action === "new") {
    menuNew();
  } else if (action === "open") {
    menuOpen();
  } else if (action === "save") {
    menuSave();
  } else if (action === "list") {
    menuList();
  } else if (action === "exit") {
    menuExit();
  } else if (action === "deleteLine") {
    deleteLine();
  } else if (action === "clearAll") {
    clearAll();
  } else if (action === "execute") {
    runCode();
  }
  renderEditor();
}

// Load file from localStorage
function loadFile(filename) {
  var content = localStorage.getItem("qandy_file_" + filename);
  if (content !== null) {
    editorState.lines = content.split("\n");
    if (editorState.lines.length === 0) {
      editorState.lines = [""];
    }
    editorState.cursorLine = 0;
    editorState.cursorCol = 0;
    editorState.viewOffsetLine = 0;
    editorState.modified = false;
    editorState.message = "Loaded: " + filename;
  } else {
    editorState.message = "File not found: " + filename;
  }
}

// Save file to localStorage
function saveFile(filename) {
  var content = editorState.lines.join("\n");
  localStorage.setItem("qandy_file_" + filename, content);
  editorState.filename = filename;
  editorState.modified = false;
  editorState.message = "Saved: " + filename;
}

// List all files in localStorage
function listFiles() {
  var files = [];
  for (var i = 0; i < localStorage.length; i++) {
    var key = localStorage.key(i);
    if (key.startsWith("qandy_file_")) {
      files.push(key.substring(11)); // Remove "qandy_file_" prefix
    }
  }
  return files;
}

// Render the editor screen
function renderEditor() {
  // Temporarily disable pagination during editor rendering
  var savedPaginationEnabled = paginationEnabled;
  paginationEnabled = false;
  
  cls();
  
  // Ensure keyon stays 0 during edit operations
  keyon = 0;
  
  // Render menu bar using menus.js API
  renderMenuBar(editorState.maxCols);
  
  // Render editor area or dialog
  if (editorState.mode === "dialog") {
    renderDialog();
  } else {
    renderEditArea();
  }
  
  // Render status bar
  renderStatusBar();
  
  // Restore pagination setting
  paginationEnabled = savedPaginationEnabled;
}


// Render edit area
function renderEditArea() {
  // Calculate visible line range
  var startLine = editorState.viewOffsetLine;
  var endLine = Math.min(startLine + editorState.maxLines, editorState.lines.length);
  
  // Render lines
  for (var i = startLine; i < endLine; i++) {
    var line = editorState.lines[i];
    var displayLine = line.substring(0, editorState.maxCols);
    
    // Show cursor and/or selection on current line
    if (i === editorState.cursorLine && editorState.mode === "edit") {
      // Build line with selection highlighting
      var result = "";
      for (var col = 0; col < displayLine.length; col++) {
        var ch = displayLine[col];
        var isSelected = isPositionSelected(i, col);
        var isCursor = (col === editorState.cursorCol);
        
        if (isCursor && !isSelected) {
          result += "\x1b[7m" + ch + "\x1b[0m";
        } else if (isSelected) {
          result += "\x1b[44m" + ch + "\x1b[0m"; // Blue background for selection
        } else {
          result += ch;
        }
      }
      
      // Handle cursor at end of line
      if (editorState.cursorCol === displayLine.length) {
        result += "\x1b[7m \x1b[0m";
      }
      
      print(result + "\n");
    } else {
      // Render other lines with selection highlighting
      var result = "";
      for (var col = 0; col < displayLine.length; col++) {
        var ch = displayLine[col];
        if (isPositionSelected(i, col)) {
          result += "\x1b[44m" + ch + "\x1b[0m";
        } else {
          result += ch;
        }
      }
      print(result + "\n");
    }
  }
  
  // Fill remaining lines
  for (var i = endLine - startLine; i < editorState.maxLines; i++) {
    print("~\n");
  }
}

// Check if a position is within the current selection
function isPositionSelected(line, col) {
  if (editorState.selectionStartLine === -1 || editorState.selectionEndLine === -1) {
    return false;
  }
  
  var startLine = editorState.selectionStartLine;
  var startCol = editorState.selectionStartCol;
  var endLine = editorState.selectionEndLine;
  var endCol = editorState.selectionEndCol;
  
  // Normalize selection (ensure start is before end)
  if (startLine > endLine || (startLine === endLine && startCol > endCol)) {
    var temp = startLine;
    startLine = endLine;
    endLine = temp;
    temp = startCol;
    startCol = endCol;
    endCol = temp;
  }
  
  // Check if position is in selection
  if (line < startLine || line > endLine) {
    return false;
  }
  if (line === startLine && line === endLine) {
    return col >= startCol && col < endCol;
  }
  if (line === startLine) {
    return col >= startCol;
  }
  if (line === endLine) {
    return col < endCol;
  }
  return true;
}

// Clear selection
function clearSelection() {
  editorState.selectionStartLine = -1;
  editorState.selectionStartCol = -1;
  editorState.selectionEndLine = -1;
  editorState.selectionEndCol = -1;
}

// Start or update selection
function updateSelection(startLine, startCol, endLine, endCol) {
  editorState.selectionStartLine = startLine;
  editorState.selectionStartCol = startCol;
  editorState.selectionEndLine = endLine;
  editorState.selectionEndCol = endCol;
}

// Get selected text
function getSelectedText() {
  if (editorState.selectionStartLine === -1 || editorState.selectionEndLine === -1) {
    return "";
  }
  
  var startLine = editorState.selectionStartLine;
  var startCol = editorState.selectionStartCol;
  var endLine = editorState.selectionEndLine;
  var endCol = editorState.selectionEndCol;
  
  // Normalize selection
  if (startLine > endLine || (startLine === endLine && startCol > endCol)) {
    var temp = startLine;
    startLine = endLine;
    endLine = temp;
    temp = startCol;
    startCol = endCol;
    endCol = temp;
  }
  
  if (startLine === endLine) {
    return editorState.lines[startLine].substring(startCol, endCol);
  }
  
  var result = [];
  for (var i = startLine; i <= endLine; i++) {
    var line = editorState.lines[i];
    if (i === startLine) {
      result.push(line.substring(startCol));
    } else if (i === endLine) {
      result.push(line.substring(0, endCol));
    } else {
      result.push(line);
    }
  }
  return result.join("\n");
}

// Delete selected text
function deleteSelectedText() {
  if (editorState.selectionStartLine === -1 || editorState.selectionEndLine === -1) {
    return false;
  }
  
  var startLine = editorState.selectionStartLine;
  var startCol = editorState.selectionStartCol;
  var endLine = editorState.selectionEndLine;
  var endCol = editorState.selectionEndCol;
  
  // Normalize selection
  if (startLine > endLine || (startLine === endLine && startCol > endCol)) {
    var temp = startLine;
    startLine = endLine;
    endLine = temp;
    temp = startCol;
    startCol = endCol;
    endCol = temp;
  }
  
  if (startLine === endLine) {
    // Single line selection
    var line = editorState.lines[startLine];
    editorState.lines[startLine] = line.substring(0, startCol) + line.substring(endCol);
    editorState.cursorLine = startLine;
    editorState.cursorCol = startCol;
  } else {
    // Multi-line selection
    var firstPart = editorState.lines[startLine].substring(0, startCol);
    var lastPart = editorState.lines[endLine].substring(endCol);
    editorState.lines[startLine] = firstPart + lastPart;
    editorState.lines.splice(startLine + 1, endLine - startLine);
    editorState.cursorLine = startLine;
    editorState.cursorCol = startCol;
  }
  
  clearSelection();
  editorState.modified = true;
  return true;
}

// Render dialog box
function renderDialog() {
  var dialogLines = 5;
  // Center some blank lines
  for (var i = 0; i < (editorState.maxLines - dialogLines) / 2; i++) {
    print("\n");
  }
  
  print("\x1b[47;30m"); // White background, black text
  print("════════════════════════════\n");
  if (editorState.dialogType === "save") {
    print(" Save File As:             \n");
  } else if (editorState.dialogType === "open") {
    print(" Open File:                \n");
  } else if (editorState.dialogType === "new") {
    print(" New File:                 \n");
  }
  print(" " + editorState.dialogInput + "_");
  // Pad line
  for (var i = editorState.dialogInput.length; i < 27; i++) {
    print(" ");
  }
  print("\n");
  print("════════════════════════════\n");
  print(" [Enter] OK  [Esc] Cancel   \x1b[0m\n");
  
  // Fill remaining lines
  for (var i = 0; i < editorState.maxLines - dialogLines - (editorState.maxLines - dialogLines) / 2; i++) {
    print("\n");
  }
}

// Message timer management
var messageTimer = null;

// Render status bar at bottom
function renderStatusBar() {
  print("\x1b[47;30m"); // White background, black text
  var status = " " + editorState.filename;
  if (editorState.modified) status += "*";
  status += " | Ln:" + (editorState.cursorLine + 1) + " Col:" + (editorState.cursorCol + 1);
  
  if (editorState.message) {
    status += " | " + editorState.message;
  }
  
  // Pad to full width
  while (status.length < editorState.maxCols) {
    status += " ";
  }
  print(status.substring(0, editorState.maxCols) + "\x1b[0m\n");
  
  // Clear message after display with single timer
  if (editorState.message) {
    if (messageTimer) {
      clearTimeout(messageTimer);
    }
    messageTimer = setTimeout(function() {
      editorState.message = "";
      messageTimer = null;
    }, 3000);
  }
}

// Menu actions
function menuNew() {
  editorState.mode = "dialog";
  editorState.dialogType = "new";
  editorState.dialogInput = "untitled.js";
  renderEditor();
}

function menuOpen() {
  editorState.mode = "dialog";
  editorState.dialogType = "open";
  editorState.dialogInput = "";
  renderEditor();
}

function menuSave() {
  editorState.mode = "dialog";
  editorState.dialogType = "save";
  editorState.dialogInput = editorState.filename;
  renderEditor();
}

function menuList() {
  cls();
  print("\x1b[1;36m");
  print("═══════════════════════════════\n");
  print("  FILES IN STORAGE\n");
  print("═══════════════════════════════\x1b[0m\n\n");
  
  var files = listFiles();
  if (files.length === 0) {
    print("\x1b[33mNo files found in storage.\x1b[0m\n\n");
  } else {
    for (var i = 0; i < files.length; i++) {
      print("\x1b[32m" + files[i] + "\x1b[0m\n");
    }
    print("\n");
  }
  
  // Also show built-in files
  print("\x1b[1;36m");
  print("═══════════════════════════════\n");
  print("  BUILT-IN PROGRAMS\n");
  print("═══════════════════════════════\x1b[0m\n\n");
  print("ansi-demo.js\n");
  print("ansi-edit.js\n");
  print("ascii.js\n");
  print("demo.js\n");
  print("q.js\n");
  print("world.js\n");
  print("\n");
  print("\x1b[33mPress any key to return...\x1b[0m\n");
  // Don't set keyon=1, editor needs to handle its own input
}

function menuExit() {
  cls();
  print("\x1b[32mEditor closed.\x1b[0m\n");
  print("\nType a .js filename to run a program\n");
  run = "";  // Clear run variable to return to OS mode
  keyon = 1; // Re-enable keyboard input for OS mode
}

function deleteLine() {
  if (editorState.lines.length > 1) {
    editorState.lines.splice(editorState.cursorLine, 1);
    if (editorState.cursorLine >= editorState.lines.length) {
      editorState.cursorLine = editorState.lines.length - 1;
    }
    editorState.modified = true;
    editorState.message = "Line deleted";
  }
  // closeMenu() now handled by menus.js
  renderEditor();
}

function clearAll() {
  editorState.lines = [""];
  editorState.cursorLine = 0;
  editorState.cursorCol = 0;
  editorState.viewOffsetLine = 0;
  editorState.modified = true;
  editorState.message = "All cleared";
  // closeMenu() now handled by menus.js
  renderEditor();
}

function runCode() {
  // closeMenu() now handled by menus.js
  
  // Helper function to wait for keypress and return to editor
  var waitForKeyAndReturnToEditor = function() {
    // Temporarily enable keyon for the "press any key" prompt
    var originalKeyon = keyon;
    keyon = 1;
    var originalInput = input;
    input = function() {
      input = originalInput;
      keyon = 0;  // Return to editor mode
      renderEditor();
    };
  };
  
  try {
    var code = editorState.lines.join("\n");
    cls();
    print("\x1b[1;32mExecuting code...\x1b[0m\n\n");
    // Note: eval() is used here for the development environment
    // This allows dynamic code execution in the emulator context
    eval(code);
    print("\n\n\x1b[33mPress any key to return to editor...\x1b[0m\n");
    waitForKeyAndReturnToEditor();
  } catch (err) {
    print("\x1b[1;31mError: " + err.message + "\x1b[0m\n");
    print("\n\x1b[33mPress any key to return to editor...\x1b[0m\n");
    waitForKeyAndReturnToEditor();
  }
}

// Handle keyboard input
function keydown(k) {
  // Handle dialog mode
  if (editorState.mode === "dialog") {
    handleDialogKey(k);
    return;
  }
  
  // Check if this key is for the menu system (menus.js API)
  if (isMenuKey(k)) {
    processMenuKey(k);
    renderEditor();
    return;
  }
  
  // Handle edit mode
  handleEditKey(k);
}

// Handle dialog keyboard input
function handleDialogKey(k) {
  if (k === "\x1b" || k === "esc") { // Escape
    editorState.mode = "edit";
    editorState.dialogInput = "";
    renderEditor();
  } else if (k === "\r" || k === "\n" || k === "enter") { // Enter
    // Process dialog action
    if (editorState.dialogType === "save") {
      if (editorState.dialogInput) {
        saveFile(editorState.dialogInput);
      }
    } else if (editorState.dialogType === "open") {
      if (editorState.dialogInput) {
        loadFile(editorState.dialogInput);
      }
    } else if (editorState.dialogType === "new") {
      editorState.filename = editorState.dialogInput || "untitled.js";
      editorState.lines = [""];
      editorState.cursorLine = 0;
      editorState.cursorCol = 0;
      editorState.modified = false;
    }
    editorState.mode = "edit";
    editorState.dialogInput = "";
    renderEditor();
  } else if (k === "\x7F" || k === "\b") { // Backspace
    if (editorState.dialogInput.length > 0) {
      editorState.dialogInput = editorState.dialogInput.slice(0, -1);
      renderEditor();
    }
  } else if (k.length === 1 && k >= " ") {
    editorState.dialogInput += k;
    renderEditor();
  }
}


// Handle edit mode keyboard input
function handleEditKey(k) {
  // Menu activation is now handled by menus.js via isMenuKey/processMenuKey
  
  // Parse modifier keys
  var hasShift = k.indexOf("shift ") === 0;
  var hasCtrl = k.indexOf("ctrl ") !== -1;
  var baseKey = k;
  
  // Strip modifiers to get base key
  if (hasShift || hasCtrl) {
    var parts = k.split(" ");
    baseKey = parts[parts.length - 1];
  }
  
  // Handle CTRL+C (copy)
  if (hasCtrl && (baseKey === "c" || baseKey === "C")) {
    var selectedText = getSelectedText();
    if (selectedText) {
      // Use internal clipboard
      editorState.clipboard = selectedText;
      editorState.message = "Copied to clipboard!";
      renderEditor();
    }
    return;
  }
  
  // Handle CTRL+V (paste)
  if (hasCtrl && (baseKey === "v" || baseKey === "V")) {
    // Delete selection if any
    if (editorState.selectionStartLine !== -1) {
      deleteSelectedText();
    }
    
    // Use internal clipboard
    if (editorState.clipboard) {
      pasteText(editorState.clipboard);
    } else {
      editorState.message = "Clipboard is empty!";
      renderEditor();
    }
    return;
  }
  
  // Handle HOME key
  if (baseKey === "home") {
    if (hasShift) {
      // Start or extend selection
      if (editorState.selectionStartLine === -1) {
        updateSelection(editorState.cursorLine, editorState.cursorCol,
                       editorState.cursorLine, 0);
      } else {
        editorState.selectionEndLine = editorState.cursorLine;
        editorState.selectionEndCol = 0;
      }
    } else {
      clearSelection();
    }
    editorState.cursorCol = 0;
    renderEditor();
    return;
  }
  
  // Handle END key
  if (baseKey === "end") {
    var lineLength = editorState.lines[editorState.cursorLine].length;
    if (hasShift) {
      // Start or extend selection
      if (editorState.selectionStartLine === -1) {
        updateSelection(editorState.cursorLine, editorState.cursorCol,
                       editorState.cursorLine, lineLength);
      } else {
        editorState.selectionEndLine = editorState.cursorLine;
        editorState.selectionEndCol = lineLength;
      }
    } else {
      clearSelection();
    }
    editorState.cursorCol = lineLength;
    renderEditor();
    return;
  }
  
  // Handle DELETE key
  if (baseKey === "delete") {
    // SHIFT+DELETE = cut to clipboard
    if (hasShift && editorState.selectionStartLine !== -1) {
      var selectedText = getSelectedText();
      if (selectedText) {
        // Use internal clipboard
        editorState.clipboard = selectedText;
        deleteSelectedText();
        editorState.message = "Cut to clipboard!";
        renderEditor();
      }
      return;
    }
    
    // Regular DELETE - delete selection or character at cursor
    if (editorState.selectionStartLine !== -1) {
      deleteSelectedText();
      renderEditor();
    } else if (editorState.cursorCol < editorState.lines[editorState.cursorLine].length) {
      var line = editorState.lines[editorState.cursorLine];
      editorState.lines[editorState.cursorLine] = 
        line.substring(0, editorState.cursorCol) + 
        line.substring(editorState.cursorCol + 1);
      editorState.modified = true;
      renderEditor();
    } else if (editorState.cursorLine < editorState.lines.length - 1) {
      // Join with next line
      var currLine = editorState.lines[editorState.cursorLine];
      var nextLine = editorState.lines[editorState.cursorLine + 1];
      editorState.lines[editorState.cursorLine] = currLine + nextLine;
      editorState.lines.splice(editorState.cursorLine + 1, 1);
      editorState.modified = true;
      renderEditor();
    }
    return;
  }
  
  // Arrow keys with SHIFT selection
  if (baseKey === "up" || k === "↑") {
    if (editorState.cursorLine > 0) {
      if (hasShift) {
        if (editorState.selectionStartLine === -1) {
          updateSelection(editorState.cursorLine, editorState.cursorCol,
                         editorState.cursorLine - 1, 
                         Math.min(editorState.cursorCol, editorState.lines[editorState.cursorLine - 1].length));
        } else {
          var newCol = Math.min(editorState.cursorCol, editorState.lines[editorState.cursorLine - 1].length);
          editorState.selectionEndLine = editorState.cursorLine - 1;
          editorState.selectionEndCol = newCol;
        }
      } else {
        clearSelection();
      }
      editorState.cursorLine--;
      editorState.cursorCol = Math.min(editorState.cursorCol, editorState.lines[editorState.cursorLine].length);
      adjustViewOffset();
      renderEditor();
    }
    return;
  }
  
  if (baseKey === "down" || k === "↓") {
    if (editorState.cursorLine < editorState.lines.length - 1) {
      if (hasShift) {
        if (editorState.selectionStartLine === -1) {
          updateSelection(editorState.cursorLine, editorState.cursorCol,
                         editorState.cursorLine + 1,
                         Math.min(editorState.cursorCol, editorState.lines[editorState.cursorLine + 1].length));
        } else {
          var newCol = Math.min(editorState.cursorCol, editorState.lines[editorState.cursorLine + 1].length);
          editorState.selectionEndLine = editorState.cursorLine + 1;
          editorState.selectionEndCol = newCol;
        }
      } else {
        clearSelection();
      }
      editorState.cursorLine++;
      editorState.cursorCol = Math.min(editorState.cursorCol, editorState.lines[editorState.cursorLine].length);
      adjustViewOffset();
      renderEditor();
    }
    return;
  }
  
  if (baseKey === "left" || k === "←" || k === "\x08") {
    if (hasShift) {
      // Selection mode
      if (editorState.selectionStartLine === -1) {
        // Start new selection
        if (editorState.cursorCol > 0) {
          updateSelection(editorState.cursorLine, editorState.cursorCol,
                         editorState.cursorLine, editorState.cursorCol - 1);
        } else if (editorState.cursorLine > 0) {
          updateSelection(editorState.cursorLine, 0,
                         editorState.cursorLine - 1, 
                         editorState.lines[editorState.cursorLine - 1].length);
        }
      } else {
        // Extend selection
        if (editorState.cursorCol > 0) {
          editorState.selectionEndLine = editorState.cursorLine;
          editorState.selectionEndCol = editorState.cursorCol - 1;
        } else if (editorState.cursorLine > 0) {
          editorState.selectionEndLine = editorState.cursorLine - 1;
          editorState.selectionEndCol = editorState.lines[editorState.cursorLine - 1].length;
        }
      }
    } else {
      clearSelection();
    }
    
    // Move cursor
    if (editorState.cursorCol > 0) {
      editorState.cursorCol--;
    } else if (editorState.cursorLine > 0) {
      editorState.cursorLine--;
      editorState.cursorCol = editorState.lines[editorState.cursorLine].length;
      adjustViewOffset();
    }
    renderEditor();
    return;
  }
  
  if (baseKey === "right" || k === "→") {
    if (hasShift) {
      // Selection mode
      if (editorState.selectionStartLine === -1) {
        // Start new selection
        if (editorState.cursorCol < editorState.lines[editorState.cursorLine].length) {
          updateSelection(editorState.cursorLine, editorState.cursorCol,
                         editorState.cursorLine, editorState.cursorCol + 1);
        } else if (editorState.cursorLine < editorState.lines.length - 1) {
          updateSelection(editorState.cursorLine, editorState.cursorCol,
                         editorState.cursorLine + 1, 0);
        }
      } else {
        // Extend selection
        if (editorState.cursorCol < editorState.lines[editorState.cursorLine].length) {
          editorState.selectionEndLine = editorState.cursorLine;
          editorState.selectionEndCol = editorState.cursorCol + 1;
        } else if (editorState.cursorLine < editorState.lines.length - 1) {
          editorState.selectionEndLine = editorState.cursorLine + 1;
          editorState.selectionEndCol = 0;
        }
      }
    } else {
      clearSelection();
    }
    
    // Move cursor
    if (editorState.cursorCol < editorState.lines[editorState.cursorLine].length) {
      editorState.cursorCol++;
    } else if (editorState.cursorLine < editorState.lines.length - 1) {
      editorState.cursorLine++;
      editorState.cursorCol = 0;
      adjustViewOffset();
    }
    renderEditor();
    return;
  }
  
  // Backspace
  if (k === "\x7F" || k === "\b" || k === "back") {
    // Delete selection if any
    if (editorState.selectionStartLine !== -1) {
      deleteSelectedText();
      renderEditor();
      return;
    }
    
    if (editorState.cursorCol > 0) {
      var line = editorState.lines[editorState.cursorLine];
      editorState.lines[editorState.cursorLine] = 
        line.substring(0, editorState.cursorCol - 1) + 
        line.substring(editorState.cursorCol);
      editorState.cursorCol--;
      editorState.modified = true;
      renderEditor();
    } else if (editorState.cursorLine > 0) {
      // Join with previous line
      var prevLine = editorState.lines[editorState.cursorLine - 1];
      var currLine = editorState.lines[editorState.cursorLine];
      editorState.lines[editorState.cursorLine - 1] = prevLine + currLine;
      editorState.lines.splice(editorState.cursorLine, 1);
      editorState.cursorLine--;
      editorState.cursorCol = prevLine.length;
      editorState.modified = true;
      adjustViewOffset();
      renderEditor();
    }
    return;
  }
  
  // Enter - new line
  if (k === "\r" || k === "\n" || k === "enter") {
    // Delete selection if any
    if (editorState.selectionStartLine !== -1) {
      deleteSelectedText();
    }
    
    var line = editorState.lines[editorState.cursorLine];
    var before = line.substring(0, editorState.cursorCol);
    var after = line.substring(editorState.cursorCol);
    editorState.lines[editorState.cursorLine] = before;
    editorState.lines.splice(editorState.cursorLine + 1, 0, after);
    editorState.cursorLine++;
    editorState.cursorCol = 0;
    editorState.modified = true;
    adjustViewOffset();
    renderEditor();
    return;
  }
  
  // Regular character input
  if (k.length === 1 && k >= " ") {
    // Delete selection if any
    if (editorState.selectionStartLine !== -1) {
      deleteSelectedText();
    }
    
    var line = editorState.lines[editorState.cursorLine];
    editorState.lines[editorState.cursorLine] = 
      line.substring(0, editorState.cursorCol) + 
      k + 
      line.substring(editorState.cursorCol);
    editorState.cursorCol++;
    editorState.modified = true;
    renderEditor();
  }
}

// Helper function to paste text
function pasteText(text) {
  if (!text) return;
  
  var lines = text.split("\n");
  if (lines.length === 1) {
    // Single line paste
    var line = editorState.lines[editorState.cursorLine];
    editorState.lines[editorState.cursorLine] = 
      line.substring(0, editorState.cursorCol) + 
      text + 
      line.substring(editorState.cursorCol);
    editorState.cursorCol += text.length;
  } else {
    // Multi-line paste
    var line = editorState.lines[editorState.cursorLine];
    var before = line.substring(0, editorState.cursorCol);
    var after = line.substring(editorState.cursorCol);
    
    // First line
    editorState.lines[editorState.cursorLine] = before + lines[0];
    
    // Middle lines
    for (var i = 1; i < lines.length - 1; i++) {
      editorState.lines.splice(editorState.cursorLine + i, 0, lines[i]);
    }
    
    // Last line
    editorState.lines.splice(editorState.cursorLine + lines.length - 1, 0, 
                            lines[lines.length - 1] + after);
    
    editorState.cursorLine += lines.length - 1;
    editorState.cursorCol = lines[lines.length - 1].length;
  }
  
  editorState.modified = true;
  editorState.message = "Pasted!";
  adjustViewOffset();
  renderEditor();
}

// Adjust view offset for scrolling
function adjustViewOffset() {
  // Ensure cursor line is never negative
  if (editorState.cursorLine < 0) {
    editorState.cursorLine = 0;
  }
  
  // Adjust view offset to keep cursor visible
  if (editorState.cursorLine < editorState.viewOffsetLine) {
    editorState.viewOffsetLine = editorState.cursorLine;
  } else if (editorState.cursorLine >= editorState.viewOffsetLine + editorState.maxLines) {
    editorState.viewOffsetLine = editorState.cursorLine - editorState.maxLines + 1;
  }
  
  // Ensure view offset is never negative
  if (editorState.viewOffsetLine < 0) {
    editorState.viewOffsetLine = 0;
  }
}

// Start the editor
cls();
print("\x1b[1;36m╔═══════════════════════════════╗\n");
print("║   QANDY DOS-STYLE EDITOR      ║\n");
print("╚═══════════════════════════════╝\x1b[0m\n\n");
print("Press \x1b[1;33mALT\x1b[0m to open menu\n");
print("Or use hotkeys: \x1b[1;33mALT+S\x1b[0m=Save, \x1b[1;33mALT+L\x1b[0m=Load, \x1b[1;33mALT+X\x1b[0m=Exit\n");
print("Use \x1b[1;33mArrow Keys\x1b[0m to navigate\n");
print("Press \x1b[1;33mEnter\x1b[0m for new line\n");
print("Press \x1b[1;33mBackspace\x1b[0m to delete\n\n");
print("Starting editor...\n");

// Set run variable to indicate this program is running
run = "edit.js";

// Disable default keyboard handling
keyon = 0;

// Define input function (required by qandy2.htm but not used by editor)
function input(text) {
  // Editor handles all input through keydown, so this is a no-op
}

// Initialize and start
setTimeout(function() {
  initEditor();
}, 1000);
